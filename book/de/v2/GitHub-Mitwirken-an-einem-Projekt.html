---
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: de
  chapter:
    title: GitHub
    number: 6
  section:
    title: Mitwirken an einem Projekt
    number: 2
    cs_number: '6.2'
    previous: book/de/v2/GitHub-Einrichten-und-Konfigurieren-eines-Kontos
    next: book/de/v2/GitHub-Ein-Projekt-betreuen
title: Git - Mitwirken an einem Projekt

---
<h2 id="_mitwirken_an_einem_projekt">Mitwirken an einem Projekt</h2>
<div class="paragraph">
<p>Nun, da unser Konto eingerichtet ist, lassen Sie uns einige Details durchgehen, die nützlich sein könnten, um Ihnen zu helfen, zu einem bestehenden Projekt beizutragen.</p>
</div>
<div class="sect3">
<h3 id="_forken_von_projekten">Forken von Projekten</h3>
<div class="paragraph">
<p>
Wenn Sie zu einem bestehenden Projekt beitragen möchten, zu dem Sie keine Push-Berechtigungen haben, können Sie das Projekt „forken“.
Wenn Sie ein Projekt „forken“, erstellt GitHub eine Kopie des Projekts, die ganz Ihnen gehört; es befindet sich in Ihrem Namensraum (engl. namespace), und Sie können Daten dorthin „hochladen“ (engl. push).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Anmerkung</div>
</td>
<td class="content">
<div class="paragraph">
<p>In der Vergangenheit war der Begriff „Fork“ in diesem Zusammenhang etwas Negatives und bedeutete, dass jemand ein Open-Source-Projekt in eine andere Richtung lenkt, manchmal ein konkurrierendes Projekt erstellt und die Beitragenden aufgespaltet hat.
In GitHub ist ein „Fork“ schlichtweg das gleiche Projekt in Ihrem eigenen Namensraum, so dass Sie Änderungen an einem Projekt öffentlich vornehmen können, um einen transparenten Ansatz zu verfolgen.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Auf diese Weise müssen sich Projekte nicht darum kümmern, Benutzer als Beteiligte hinzuzufügen, um ihnen Push-Zugriff zu geben.
Jeder kann ein Projekt forken, dorthin pushen und seine Änderungen wieder in das originale Repository einbringen, indem er einen sogenannten Pull-Request erstellt, den wir als nächstes behandeln werden.
Das eröffnet einen Diskussionsfaden mit Code-Review. Der Eigentümer und der Mitwirkende können dann über die Änderung kommunizieren, bis der Eigentümer mit ihr zufrieden ist und sie daraufhin zusammenführen (engl. merge) kann.</p>
</div>
<div class="paragraph">
<p>Um ein Projekt abzuspalten (engl. fork), gehen Sie auf die Projektseite und klicken Sie auf die Schaltfläche „Fork“ oben rechts auf der Seite.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{ "book/en/v2/images/forkbutton.png" | relative_url }}" alt="Die Schaltfläche „Fork“">
</div>
<div class="title">Abbildung 88. Die Schaltfläche „Fork“</div>
</div>
<div class="paragraph">
<p>Nach ein paar Sekunden werden Sie auf Ihre neue Projektseite weitergeleitet, mit Ihrer eigenen beschreibbaren Kopie des Codes.</p>
</div>
</div>
<div class="sect3">
<h3 id="ch06-github_flow">Der GitHub Workflow</h3>
<div class="paragraph">
<p>
GitHub ist auf einen bestimmten Collaboration-Workflow ausgerichtet, der sich auf Pull-Requests konzentriert.
Dieser Ablauf funktioniert unabhängig davon, ob Sie eng in einem Team, in einem einzigen gemeinsamen Repository, mit einem global verteilten Unternehmen oder einem Netzwerk von Fremden, über Dutzende von Forks, zusammenarbeiten und zu einem Projekt beitragen.
Es ist um den Workflow aus <a href="ch00/_topic_branch">Themen-Branches</a> konzentriert, der in Kapitel 3 <a href="ch00/ch03-git-branching">Git Branching</a> ausführlich besprochen wurde.</p>
</div>
<div class="paragraph">
<p>Im Prinzip funktioniert der Ablauf so:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Forken Sie das Projekt.</p>
</li>
<li>
<p>Erstellen Sie lokal einen Themen-Branch aus <code>master</code>.</p>
</li>
<li>
<p>Machen Sie einige Commits, um das Projekt zu überarbeiten.</p>
</li>
<li>
<p>Pushen Sie diesen Branch zu Ihrem GitHub-Projekt.</p>
</li>
<li>
<p>Eröffnen Sie einen Pull-Request auf GitHub.</p>
</li>
<li>
<p>Diskutieren Sie die optionale Fortsetzung des Commits.</p>
</li>
<li>
<p>Der Projekteigentümer mergt oder schließt den Pull Request.</p>
</li>
<li>
<p>Synchronisieren Sie den aktualisierten Master wieder mit Ihrem Fork.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Das ist im Grunde genommen der Integration-Manager-Workflow aus Kapitel 5 <a href="ch00/_integration_manager">Integrationsmanager</a>, aber anstatt E-Mails zur Kommunikation und Überprüfung von Änderungen zu verwenden, verwenden Teammitglieder die webbasierten Tools von GitHub.</p>
</div>
<div class="paragraph">
<p>Schauen wir uns ein Beispiel an, wie man mit diesem Workflow eine Anpassung an einem Open-Source-Projekt vorschlägt, das auf GitHub gehostet wird.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Hinweis</div>
</td>
<td class="content">
<div class="paragraph">
<p>Sie können für die meisten Aktionen das offizielle Werkzeug <strong>GitHub CLI</strong> anstatt die GitHub Weboberfläche nutzen.
Das Werkzeug kann auf Windows, MacOS und Linux Systemen genutzt werden.
Gehen sie zu <a href="https://cli.github.com/" target="_blank" rel="noopener">GitHub CLI homepage</a> für weitere Informationen, Installationsanleitungen und Handbücher.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h4 id="_anlegen_eines_pull_requests">Anlegen eines Pull-Requests</h4>
<div class="paragraph">
<p>Tony ist auf der Suche nach Code, der auf seinem programmierbaren Arduino-Mikrocontroller läuft und hat auf GitHub unter <a href="https://github.com/schacon/blink" class="bare">https://github.com/schacon/blink</a> eine tolle Programmdatei gefunden.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{ "book/en/v2/images/blink-01-start.png" | relative_url }}" alt="Das Projekt, zu dem wir beitragen wollen">
</div>
<div class="title">Abbildung 89. Das Projekt, zu dem wir beitragen wollen</div>
</div>
<div class="paragraph">
<p>Das einzige Problem ist, dass die Blinkfrequenz zu schnell ist.
Wir finden es viel angenehmer, 3 Sekunden statt 1 Sekunde zwischen den einzelnen Zustandsänderungen zu warten.
Lassen Sie uns also das Programm verbessern und es als Änderungsvorschlag an das Projekt zurücksenden.</p>
</div>
<div class="paragraph">
<p>Zuerst klicken wir, wie bereits erwähnt, auf die Schaltfläche 'Fork', um unsere eigene Kopie des Projekts zu erhalten.
Unser Benutzername hier ist „tonychacon“, also ist unsere Kopie dieses Projekts unter <a href="https://github.com/tonychacon/blink" class="bare">https://github.com/tonychacon/blink</a> zu finden und dort könnten wir es bearbeiten.
Wir werden es aber lokal klonen, einen Themenzweig erstellen, den Code ändern und schließlich diese Änderung wieder auf GitHub übertragen.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clone https://github.com/tonychacon/blink <b class="conum">(1)</b>
Cloning into 'blink'...

$ cd blink
$ git checkout -b slow-blink <b class="conum">(2)</b>
Switched to a new branch 'slow-blink'

$ sed -i '' 's/1000/3000/' blink.ino (macOS) <b class="conum">(3)</b>
# If you're on a Linux system, do this instead:
# $ sed -i 's/1000/3000/' blink.ino <b class="conum">(3)</b>

$ git diff --word-diff <b class="conum">(4)</b>
diff --git a/blink.ino b/blink.ino
index 15b9911..a6cc5a5 100644
--- a/blink.ino
+++ b/blink.ino
@@ -18,7 +18,7 @@ void setup() {
// the loop routine runs over and over again forever:
void loop() {
  digitalWrite(led, HIGH);   // turn the LED on (HIGH is the voltage level)
  [-delay(1000);-]{+delay(3000);+}               // wait for a second
  digitalWrite(led, LOW);    // turn the LED off by making the voltage LOW
  [-delay(1000);-]{+delay(3000);+}               // wait for a second
}

$ git commit -a -m 'Change delay to 3 seconds' <b class="conum">(5)</b>
[slow-blink 5ca509d] Change delay to 3 seconds
 1 file changed, 2 insertions(+), 2 deletions(-)

$ git push origin slow-blink <b class="conum">(6)</b>
Username for 'https://github.com': tonychacon
Password for 'https://tonychacon@github.com':
Counting objects: 5, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 340 bytes | 0 bytes/s, done.
Total 3 (delta 1), reused 0 (delta 0)
To https://github.com/tonychacon/blink
 * [new branch]      slow-blink -&gt; slow-blink</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Wir klonen unsere Fork des Projekts lokal.</p>
</li>
<li>
<p>Wir erstellen einen Branch mit prägnantem Namen.</p>
</li>
<li>
<p>Wir nehmen unsere Anpassung am Code vor.</p>
</li>
<li>
<p>Wir überprüfen, ob die Änderung gut ist.</p>
</li>
<li>
<p>Wir commiten unsere Änderung in den Themen-Branch.</p>
</li>
<li>
<p>Wir pushen unseren neuen Themen-Branch zurück zu unserer GitHub-Fork.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Wenn wir nun zu unserem Fork auf GitHub zurückkehren, können wir sehen, dass GitHub bemerkt hat, dass wir einen neuen Themenzweig gepusht haben und zeigt uns einen großen grünen Button, um unsere Änderungen zu überprüfen und einen Pull Request zum ursprünglichen Projekt zu öffnen.</p>
</div>
<div class="paragraph">
<p>Sie können alternativ auch die Seite „Branches“ bei <code><a href="https://github.com/&lt;user&gt;/&lt;project&gt;/branches" class="bare">https://github.com/&lt;user&gt;/&lt;project&gt;/branches</a></code> aufzurufen, um Ihre Branch auszuwählen und von dort aus einen neuen Pull Request zu öffnen.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{ "book/en/v2/images/blink-02-pr.png" | relative_url }}" alt="Die Schaltfläche Pull Request">
</div>
<div class="title">Abbildung 90. Die Schaltfläche Pull Request</div>
</div>
<div class="paragraph">
<p>
Wenn wir auf die grüne Schaltfläche klicken, sehen wir einen Bildschirm, auf dem Sie aufgefordert werden, Ihrem Pull Request einen Titel und eine Beschreibung zu geben.
Es ist fast immer sinnvoll, sich ein bisschen Mühe zu geben, da eine gute Beschreibung dem Eigentümer des ursprünglichen Projekts hilft, festzustellen, was Sie versucht haben, ob Ihre vorgeschlagenen Änderungen korrekt sind und ob die Annahme der Änderungen das ursprüngliche Projekt verbessern würde.</p>
</div>
<div class="paragraph">
<p>Wir erhalten auch eine Liste der Commits in unserem Themen-Branch, die dem <code>master</code> Branch <strong>„voraus“</strong> (engl. ahead) sind (in diesem Fall nur der eine) und ein vereinheitlichtes Diff aller Änderungen, die vorgenommen werden, falls dieser Branch vom Projektleiter gemergt wird.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{ "book/en/v2/images/blink-03-pull-request-open.png" | relative_url }}" alt="Seite zur Erstellung von Pull-Requests">
</div>
<div class="title">Abbildung 91. Seite zur Erstellung von Pull-Requests</div>
</div>
<div class="paragraph">
<p>Wenn Sie in diesem Fenster auf die Schaltfläche 'Create pull request' klicken, wird der Eigentümer/Leiter des Projekts, für das Sie eine Abspaltung (engl. Fork) vorgenommen haben, benachrichtigt, dass jemand eine Änderung vorschlägt, und verlinkt auf eine Seite, die alle diese Informationen enthält.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Anmerkung</div>
</td>
<td class="content">
<div class="paragraph">
<p>Pull-Requests werden zwar häufig für öffentliche Projekte wie dieses verwendet, wenn der Beitragende eine vollständige Änderung fertig hat, sie werden jedoch auch zu Beginn des Entwicklungszyklus in internen Projekten verwendet.
Da Sie den Themenzweig auch <strong>nach</strong> dem Öffnen des Pull-Requests weiter bearbeiten können, wird er oft früh geöffnet und als Möglichkeit genutzt, um die Arbeit als Team in einem Gesamtkontext zu iterieren, anstatt ihn erst am Ende des Prozesses zu öffnen.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h4 id="_iteration_eines_pull_requests">Iteration eines Pull-Requests</h4>
<div class="paragraph">
<p>An dieser Stelle kann sich der Projektverantwortliche die vorgeschlagene Änderung ansehen und mergen, ablehnen oder kommentieren.
Nehmen wir an, er mag die Idee, würde aber eine etwas längere Zeit bevorzugen, in der das Licht aus ist.</p>
</div>
<div class="paragraph">
<p>Während diese Unterhaltung über E-Mail in den in Kapitel5 <a href="ch00/ch05-distributed-git">Verteiltes Git</a> dargestellten Workflows stattfinden kann, geschieht dies bei GitHub online.
Der Projektverantwortliche kann das vereinheitlichte Diff überprüfen und einen Kommentar hinterlassen, indem er auf eine der Zeilen klickt.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{ "book/en/v2/images/blink-04-pr-comment.png" | relative_url }}" alt="Pull-Request Zeilen-Kommentar">
</div>
<div class="title">Abbildung 92. Kommentar zu einer bestimmten Codezeile in einem Pull-Request</div>
</div>
<div class="paragraph">
<p>Sobald der Betreuer diesen Kommentar abgibt, erhält die Person, die den Pull-Request geöffnet hat (und auch alle anderen, die das Repository beobachten), eine Benachrichtigung.
Wir werden das später noch einmal anpassen, aber wenn er E-Mail-Benachrichtigungen eingeschaltet hat, bekommt Tony eine E-Mail wie diese:</p>
</div>
<div id="_email_notification" class="imageblock">
<div class="content">
<img src="{{ "book/en/v2/images/blink-04-email.png" | relative_url }}" alt="E-Mail-Benachrichtigung">
</div>
<div class="title">Abbildung 93. Kommentare, als E-Mail-Benachrichtigungen gesendet</div>
</div>
<div class="paragraph">
<p>Jeder kann auch allgemeine Kommentare zum Pull Request hinterlassen.
Auf der <a href="ch00/_pr_discussion">Pull Request Diskussions-Seite</a> sehen wir ein Beispiel dafür, wie der Projektleiter sowohl eine Zeile Code kommentiert als auch einen allgemeinen Kommentar im Diskussionsbereich hinterlässt.
Sie sehen, dass auch die Code-Kommentare in das Diskussionsfenster eingebracht werden.</p>
</div>
<div id="_pr_discussion" class="imageblock">
<div class="content">
<img src="{{ "book/en/v2/images/blink-05-general-comment.png" | relative_url }}" alt="Pull Request Diskussions-Seite">
</div>
<div class="title">Abbildung 94. Pull Request Diskussions-Seite</div>
</div>
<div class="paragraph">
<p>Jetzt kann der Beitragende sehen, was er tun muss, damit seine Änderung akzeptiert wird.
Zum Glück ist das sehr einfach.
Wo Sie über E-Mail Ihre Daten erneut in die Mailingliste eintragen müssen, committen Sie mit GitHub einfach erneut in den Themen-Branch und pushen, wodurch der Pull-Request automatisch aktualisiert wird.
Im <a href="ch00/_pr_final">finalen Pull-Request</a> sehen Sie auch, dass der alte Code-Kommentar in dem aktualisierten Pull-Request zusammengeklappt wurde, da er auf eine inzwischen geänderte Zeile gemacht wurde.</p>
</div>
<div class="paragraph">
<p>Das Hinzufügen von Commits zu einem bestehenden Pull Request löst keine weitere Benachrichtigung aus. Nachdem Tony seine Korrekturen gepusht hat, beschließt er, einen Kommentar zu hinterlassen, um den Projektträger darüber zu informieren, dass er die gewünschte Änderung vorgenommen hat.</p>
</div>
<div id="_pr_final" class="imageblock">
<div class="content">
<img src="{{ "book/en/v2/images/blink-06-final.png" | relative_url }}" alt="finaler Pull-Request">
</div>
<div class="title">Abbildung 95. finaler Pull-Request</div>
</div>
<div class="paragraph">
<p>Eine bemerkenswerte Besonderheit ist, dass Sie den „vereinheitlichten“ Diff erhalten, wenn Sie auf die Registerkarte „Files Changed“ in diesem Pull-Request klicken – d.h. die gesamte aggregierte Differenz, die in Ihren Hauptbranch eingebracht würde, wenn dieser Themenzweig gemergt würde.
Im Sinne von <code>git diff</code> zeigt es Ihnen grundsätzlich automatisch <code>git diff master…&lt;branch&gt;</code> für den Branch, auf dem dieser Pull Request basiert.
Siehe Kapitel 5 <a href="ch00/_what_is_introduced">Festlegen, was eingebracht wird</a> für weitere Informationen über diese Art von Diff.</p>
</div>
<div class="paragraph">
<p>Außerdem prüft GitHub, ob der Pull-Request sauber mergen würde und stellt eine Schaltfläche zur Verfügung, mit der Sie den Merge auf dem Server durchführen können.
Diese Schaltfläche erscheint nur, wenn Sie Schreibzugriff auf das Repository haben und ein trivialer Merge möglich ist.
Wenn Sie darauf klicken, führt GitHub einen „non-fast-forward“-Merge durch, was bedeutet, dass selbst wenn es sich bei dem Merge um einen schnellen Vorlauf (engl. fast-forward) handeln <strong>könnte</strong>, immer noch ein Merge-Commit erstellt wird.</p>
</div>
<div class="paragraph">
<p>Wenn Sie möchten, können Sie den Branch einfach herunterladen (engl. pull) und lokal zusammenführen (engl. merge).
Wenn Sie diesen Zweig mit dem <code>master</code> Branch verschmelzen und ihn nach GitHub pushen, wird der Pull Request automatisch geschlossen.</p>
</div>
<div class="paragraph">
<p>Das ist der grundsätzliche Workflow, den die meisten GitHub-Projekte verwenden.
Themen-Branches werden erstellt, Pull-Requests werden geöffnet, es folgt eine Diskussion, möglicherweise wird eine weitere Überarbeitung des Zweiges durchgeführt und schließlich wird der Request entweder geschlossen oder zusammengeführt.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Anmerkung</div>
</td>
<td class="content">
<div class="title">Nicht nur Forks</div>
<div class="paragraph">
<p>Es ist wichtig zu erwähnen, dass Sie auch einen Pull-Request zwischen zwei Zweigen im selben Repository öffnen können.
Wenn Sie mit jemandem an einer Funktion arbeiten und beide Schreibrechte auf das Projekt haben, können Sie einen Themenzweig in das Repository verschieben und einen Pull-Request darauf an den <code>master</code> Branch desselben Projekts öffnen, um den Code-Review- und Diskussionsprozess einzuleiten.
Es ist kein Forking notwendig.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_erweiterte_pull_requests">Erweiterte Pull-Requests</h3>
<div class="paragraph">
<p>Nachdem wir nun die Grundlagen für einen Beitrag zu einem Projekt auf GitHub erläutert haben, möchten wir Ihnen einige interessante Tipps und Tricks zu Pull-Requests geben, damit Sie diese effektiver nutzen können.</p>
</div>
<div class="sect4">
<h4 id="_pull_requests_als_patches">Pull-Requests als Patches</h4>
<div class="paragraph">
<p>Es ist wichtig zu verstehen, dass viele Projekte Pull-Requests nicht wirklich als eine Reihe perfekter Patches betrachten, die sauber angewendet werden sollten, wobei die meisten Mailinglisten-basierten Projekte an Patch-Serienbeiträge denken.
Die meisten GitHub-Projekte betrachten Pull-Request-Branches als iterative Dialoge um eine beabsichtigte Änderung, die zu einem vereinheitlichten Diff führt, welches durch das Mergen angewendet wird.</p>
</div>
<div class="paragraph">
<p>Das ist ein wichtiger Unterschied, denn im Allgemeinen wird die Änderung vorgeschlagen, bevor der Code perfektioniert ist, was bei Beiträgen von Patch-Serien auf Mailinglistenbasis weitaus seltener ist.
So kann früher mit den Betreuern gesprochen werden, damit die richtige Lösung eher eine Gemeinschaftsarbeit ist.
Wenn Code mit einem Pull-Request vorgeschlagen wird und die Maintainer oder die Community eine Änderung vorschlagen, wird die Patch-Serie im Allgemeinen nicht neu aufgerollt, sondern der Unterschied wird als neuer Commit an den Branch weitergegeben (gepusht), wodurch der Dialog im intakten Kontext der vorherigen Arbeit fortgesetzt wird.</p>
</div>
<div class="paragraph">
<p>Wenn Sie beispielsweise zurückgehen und sich den <a href="ch00/_pr_final">finalen Pull-Request</a> erneut ansehen, werden Sie feststellen, dass der Beitragende seinen Commit nicht umbasiert hat (engl. rebase) und einen weiteren Pull-Request geöffnet hat.
Stattdessen wurden neue Commits hinzugefügt und sie in den bestehenden Zweig gepusht.
Wenn Sie also in Zukunft auf diesen Pull Request zurückblicken, können Sie leicht den gesamten Kontext finden, in dem die Entscheidungen getroffen wurden.
Wenn Sie auf der Website auf die Schaltfläche „Merge“ klicken, wird gezielt ein Merge-Commit erstellt, der auf den Pull-Request verweist, so dass Sie leicht zurückkehren und bei Bedarf die ursprüngliche Diskussion durchsuchen können.</p>
</div>
</div>
<div class="sect4">
<h4 id="_mit_dem_upstream_schritt_halten">Mit dem Upstream Schritt halten</h4>
<div class="paragraph">
<p>Wenn Ihr Pull-Request veraltet ist oder anderweitig nicht sauber zusammengeführt wird,  sollten Sie ihn reparieren, damit der Betreuer ihn leicht mergen kann.
GitHub wird das für Sie testen und Sie am Ende jedes Pull Requests darüber informieren, ob das Merge trivial ist oder nicht.</p>
</div>
<div id="_pr_fail" class="imageblock">
<div class="content">
<img src="{{ "book/en/v2/images/pr-01-fail.png" | relative_url }}" alt="PR merge Fehlschlag">
</div>
<div class="title">Abbildung 96. Pull Request lässt sich nicht sauber mergen</div>
</div>
<div class="paragraph">
<p>Wenn Sie etwa „<a href="ch00/_pr_fail">Pull Request lässt sich nicht sauber mergen</a>“ sehen, sollten Sie Ihren Branch so reparieren, dass er grün wird und der Maintainer keine zusätzliche Arbeit leisten muss.</p>
</div>
<div class="paragraph">
<p>Sie haben zwei grundsätzliche Möglichkeiten, wie Sie das realisieren können.
Sie können Ihren Branch entweder auf den Ziel-Branch rebasen (normalerweise den <code>master</code> Branch des von Ihnen geforkten Repositorys), oder Sie können den Ziel-Branch mit Ihrem Branch mergen.</p>
</div>
<div class="paragraph">
<p>Die meisten Entwickler auf GitHub werden sich aus den gleichen Gründen für Letzteres entscheiden, die wir im vorherigen Abschnitt erläutert haben.
Was wichtig ist, ist die Verlaufskontrolle und der endgültige Merge, so dass das Rebasing nicht viel mehr bringt als eine etwas aufgeräumtere Historie. Im Gegenzug ist es <strong>viel</strong> schwieriger und fehleranfälliger.</p>
</div>
<div class="paragraph">
<p>Wenn Sie im Ziel-Branch mergen wollen, um Ihren Pull-Request zusammenzuführen zu können, sollten Sie das ursprüngliche Repository als neuen Remote hinzufügen. Dann machen Sie ein <code>git fetch</code> davon, führen den Hauptzweig dieses Repositorys in Ihren Themen-Branch zusammen, beheben alle Probleme und pushen Sie es schließlich wieder in den gleichen Branch, in dem Sie den Pull-Request geöffnet hatten.</p>
</div>
<div class="paragraph">
<p>Nehmen wir zum Beispiel an, dass der ursprüngliche Autor in dem von uns zuvor verwendeten Beispiel „tonychacon“ eine Änderung vorgenommen hat, die zu einem Konflikt im Pull-Request führt.
Gehen wir diese Schritte einzeln durch.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git remote add upstream https://github.com/schacon/blink <b class="conum">(1)</b>

$ git fetch upstream <b class="conum">(2)</b>
remote: Counting objects: 3, done.
remote: Compressing objects: 100% (3/3), done.
Unpacking objects: 100% (3/3), done.
remote: Total 3 (delta 0), reused 0 (delta 0)
From https://github.com/schacon/blink
 * [new branch]      master     -&gt; upstream/master

$ git merge upstream/master <b class="conum">(3)</b>
Auto-merging blink.ino
CONFLICT (content): Merge conflict in blink.ino
Automatic merge failed; fix conflicts and then commit the result.

$ vim blink.ino <b class="conum">(4)</b>
$ git add blink.ino
$ git commit
[slow-blink 3c8d735] Merge remote-tracking branch 'upstream/master' \
    into slower-blink

$ git push origin slow-blink <b class="conum">(5)</b>
Counting objects: 6, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (6/6), done.
Writing objects: 100% (6/6), 682 bytes | 0 bytes/s, done.
Total 6 (delta 2), reused 0 (delta 0)
To https://github.com/tonychacon/blink
   ef4725c..3c8d735  slower-blink -&gt; slow-blink</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Das Original-Repository als Remote mit der Bezeichnung <code>upstream</code> hinzufügen.</p>
</li>
<li>
<p>Die neueste Arbeit von diesem Remote abrufen (engl. fetch).</p>
</li>
<li>
<p>Den Haupt-Branch dieses Repositorys mit dem Themen-Branch mergen.</p>
</li>
<li>
<p>Den aufgetretenen Konflikt beheben.</p>
</li>
<li>
<p>Zum gleichen Themen-Branch zurück pushen.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Sobald Sie das getan haben, wird der Pull-Request automatisch aktualisiert und erneut überprüft, um festzustellen, ob er sauber zusammengeführt werden kann.</p>
</div>
<div id="_pr_merge_fix" class="imageblock">
<div class="content">
<img src="{{ "book/en/v2/images/pr-02-merge-fix.png" | relative_url }}" alt="PR fixed">
</div>
<div class="title">Abbildung 97. Pull-Request wird nun sauber zusammengeführt</div>
</div>
<div class="paragraph">
<p>Einer der großen Pluspunkte von Git ist, dass man das kontinuierlich tun kann.
Wenn Sie ein sehr lang laufendes Projekt haben, können Sie leicht immer wieder aus dem Zielbranch heraus mergen und müssen sich nur mit Konflikten befassen, die seit dem letzten Mal, als Sie zusammengeführt haben, aufgetreten sind; was den Prozess sehr überschaubar macht.</p>
</div>
<div class="paragraph">
<p>Wenn Sie den Branch unbedingt rebasen wollen, um ihn aufzuräumen, können Sie das natürlich tun, aber es wird dringend empfohlen, den Branch, auf dem der Pull-Request bereits geöffnet ist, nicht zwangsweise zu pushen.
Wenn von Anderen gepullt wurde und weitere Arbeiten daran durchgeführt wurden, stößt man auf alle in Kapitel 3, <a href="ch00/_rebase_peril">Die Gefahren des Rebasing</a> beschriebenen Probleme.
Schieben Sie stattdessen den rebasierten Branch zu einem neuen Branch auf GitHub und öffnen Sie einen brandneuen Pull Request mit Bezug auf den alten Branch und schließen Sie dann das Original.</p>
</div>
</div>
<div class="sect4">
<h4 id="_referenzen">Referenzen</h4>
<div class="paragraph">
<p>Möglicherweise lautet Ihre nächste Frage: „Wie verweise ich auf den alten Pull-Request?“.
Es stellt sich heraus, dass es viele, viele Möglichkeiten gibt, auf andere Dinge Bezug zu nehmen, und zwar fast überall dort, wo man in GitHub schreiben kann.</p>
</div>
<div class="paragraph">
<p>Beginnen wir mit der Frage, wie man einen anderen Pull-Request oder ein Issue vergleicht.
Alle Pull-Requests und Issues sind mit Nummern versehen und innerhalb des Projekts eindeutig.
Beispielsweise ist es nicht möglich, Pull Request #3 <em>und</em> Issue #3 anzulegen.
Wenn Sie auf einen Pull-Request oder ein Issue von einem anderen verweisen möchten, können Sie einfach <code><mark>&lt;num&gt;</mark></code> in einen Kommentar oder eine Beschreibung eingeben.
Sie können auch präziser sein, wenn die Issue- oder Pull-Anforderung an einem anderen Ort liegt; schreiben Sie <code>Benutzername&lt;num&gt;</code>, wenn Sie sich auf ein Issue oder Pull Request beziehen, in einen Fork des Repositorys, in dem Sie sich befinden, oder <code>Benutzername/repo#&lt;num&gt;</code>, um auf etwas in einem anderen Repository zu verweisen.</p>
</div>
<div class="paragraph">
<p>Schauen wir uns ein Beispiel an.
Angenommen, wir haben den Branch aus dem vorherigen Beispiel rebasiert, einen neuen Pull-Request für ihn erstellt und jetzt wollen wir die alte Pull-Anforderung aus der neuen aufrufen.
Wir möchten auch auf ein Problem in der Fork des Repositorys und auf ein Problem in einem ganz anderen Projekt verweisen.
Wir können die Beschreibung wie bei <a href="ch00/_pr_references">Querverweise in einem Pull-Request</a> eingeben.</p>
</div>
<div id="_pr_references" class="imageblock">
<div class="content">
<img src="{{ "book/en/v2/images/mentions-01-syntax.png" | relative_url }}" alt="PR references">
</div>
<div class="title">Abbildung 98. Querverweise in einem Pull-Request</div>
</div>
<div class="paragraph">
<p>Wenn wir diese Pull-Anfrage einreichen, werden wir sehen, dass alles wie in „<a href="ch00/_pr_references_render">Querverweise, die in einem Pull-Request erzeugt wurden</a>“ dargestellt wird.</p>
</div>
<div id="_pr_references_render" class="imageblock">
<div class="content">
<img src="{{ "book/en/v2/images/mentions-02-render.png" | relative_url }}" alt="PR references rendered">
</div>
<div class="title">Abbildung 99. Querverweise, die in einem Pull-Request erzeugt wurden</div>
</div>
<div class="paragraph">
<p>Bitte beachten Sie, dass die vollständige GitHub-URL, die wir dort eingegeben haben, auf die benötigten Informationen gekürzt wurde.</p>
</div>
<div class="paragraph">
<p>Wenn Tony nun zurück geht und den ursprünglichen Pull-Request schließt, können wir sehen, dass GitHub automatisch ein Trackback-Ereignis in der Pull-Request Zeitleiste erstellt hat, indem er ihn im neuen Pull-Request erwähnt.
Das bedeutet, dass jeder, der diesen Pull-Request aufruft, sieht, dass er geschlossen ist. Er kann leicht auf denjenigen zurückgreifen, der ihn ersetzt hat.
Der Link wird in etwa wie in „<a href="ch00/_pr_closed">Zurück zum neuen Pull-Request in der geschlossenen Pull-Request Zeitleiste</a>“ aussehen.</p>
</div>
<div id="_pr_closed" class="imageblock">
<div class="content">
<img src="{{ "book/en/v2/images/mentions-03-closed.png" | relative_url }}" alt="PR closed">
</div>
<div class="title">Abbildung 100. Zurück zum neuen Pull-Request in der geschlossenen Pull-Request Zeitleiste</div>
</div>
<div class="paragraph">
<p>Zusätzlich zu den Issue-Nummern können Sie auch auf einen bestimmten Commit per SHA-1 referenzieren.
Sie müssen einen vollen 40-stelligen SHA-1 angeben, aber wenn GitHub das in einem Kommentar sieht, wird er direkt auf den Commit verlinken.
Wie bei Issues können Sie auch hier auf Commits in Forks oder anderen Repositorys verweisen.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_github_variante_von_markdown">GitHub-Variante von Markdown</h3>
<div class="paragraph">
<p>Die Verknüpfung mit anderen Issues ist nur der Anfang von interessanten Dingen, die Sie mit fast jeder Textbox auf GitHub machen können.
In Issue- und Pull-Request-Beschreibungen, Kommentaren, Code-Kommentaren und mehr, können Sie das sogenannte „GitHub Flavored Markdown“ verwenden.
Markdown fühlt sich an wie das Schreiben in Klartext, hat aber umfangreiche Darstellungs-Optionen.</p>
</div>
<div class="paragraph">
<p>Im <a href="ch00/_example_markdown">Beispiel für GitHub-Variante von Markdown, geschrieben und gerendert</a> finden Sie ein Muster, wie Kommentare oder Text geschrieben und dann mit Markdown gerendert werden können.</p>
</div>
<div id="_example_markdown" class="imageblock">
<div class="content">
<img src="{{ "book/en/v2/images/markdown-01-example.png" | relative_url }}" alt="Example Markdown">
</div>
<div class="title">Abbildung 101. Beispiel für GitHub-Variante von Markdown, geschrieben und gerendert</div>
</div>
<div class="paragraph">
<p>Die GitHub-Variante von Markdown bietet mehr Möglichkeiten, als die normale Markdown-Syntax.
Alle diese Funktionen können sehr nützlich sein, wenn Sie hilfreiche Pull-Request, Issue-Kommentare oder Beschreibungen erstellen.</p>
</div>
<div class="sect4">
<h4 id="_aufgabenlisten">Aufgabenlisten</h4>
<div class="paragraph">
<p>Die wirklich praktische GitHub-spezifische Markdown-Funktion, vor allem für die Verwendung in Pull-Requests, ist die Aufgabenliste.
Eine Aufgabenliste ist eine Liste von Kontrollkästchen für alle Vorgänge, die Sie erledigen möchten.
Wenn Sie sie in einen Issue oder Pull-Request einfügen, werden normalerweise Punkte angezeigt, die Sie erledigen sollten, bevor Sie den Vorgang als erledigt betrachten.</p>
</div>
<div class="paragraph">
<p>Sie können eine Task-Liste wie folgt anlegen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">- [X] Write the code
- [ ] Write all the tests
- [ ] Document the code</code></pre>
</div>
</div>
<div class="paragraph">
<p>Wenn wir das in die Beschreibung unseres Pull Request oder Issue aufnehmen, sehen wir, dass es wie in <a href="ch00/_eg_task_lists">Aufgabenliste in Markdown-Kommentar, gerendert</a> dargestellt wird.</p>
</div>
<div id="_eg_task_lists" class="imageblock">
<div class="content">
<img src="{{ "book/en/v2/images/markdown-02-tasks.png" | relative_url }}" alt="Example Task List">
</div>
<div class="title">Abbildung 102. Aufgabenliste in Markdown-Kommentar, gerendert</div>
</div>
<div class="paragraph">
<p>Diese Funktion wird häufig in Pull Requests verwendet, um zu verdeutlichen, was alles Sie auf dem Branch erledigen möchten, bevor der Pull Request bereit für die Zusammenführung ist.
Der wirklich coole Teil ist, dass Sie einfach auf die Kontrollkästchen klicken können, um den Kommentar zu aktualisieren – Sie müssen den Markdown nicht direkt bearbeiten, um Aufgaben als erledigt zu markieren.</p>
</div>
<div class="paragraph">
<p>Darüber hinaus sucht GitHub nach Aufgabenlisten in Ihren Issues und Pull Requests und zeigt sie als Metadaten zu den Seiten, auf denen sie stehen, an.
Wenn Sie z.B. einen Pull-Request mit Aufgabenliste haben und sich die Übersichtsseite aller Pull-Requests ansehen, können Sie sehen, wie weit er abgearbeitet ist.
Das hilft den Teilnehmern, Pull-Requests in Teilaufgaben aufzuschlüsseln und anderen Teilnehmern, den Fortschritt der Branch zu verfolgen.
Ein Beispiel dafür finden Sie bei: <a href="ch00/_task_list_progress">Task-Liste (Zusammenfassung) in der Pull-Request-Liste</a>.</p>
</div>
<div id="_task_list_progress" class="imageblock">
<div class="content">
<img src="{{ "book/en/v2/images/markdown-03-task-summary.png" | relative_url }}" alt="Example Task List">
</div>
<div class="title">Abbildung 103. Task-Liste (Zusammenfassung) in der Pull-Request-Liste</div>
</div>
<div class="paragraph">
<p>Diese Funktion ist unglaublich nützlich, wenn Sie einen Pull Request frühzeitig öffnen und damit Ihren Fortschritt bei der Realisierung des Features verfolgen (engl. track).</p>
</div>
</div>
<div class="sect4">
<h4 id="_code_schnipsel">Code-Schnipsel</h4>
<div class="paragraph">
<p>Sie können auch Code-Schnipsel zu Kommentaren hinzufügen.
Es ist dann besonders praktisch, wenn Sie etwas präsentieren möchten, das Sie versuchen <em>könnten</em>, bevor Sie es tatsächlich als Commit auf Ihrem Branch einbauen.
Das wird auch oft verwendet, um Beispielcode hinzuzufügen, der verrät, was nicht funktioniert oder was dieser Pull-Request umsetzen könnte.</p>
</div>
<div class="paragraph">
<p>Um ein Code-Schnipsel hinzuzufügen, müssen Sie ihn in zwei 3-fach Backticks (<code>`</code>) „einzäunen“.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">```java
for(int i=0 ; i &lt; 5 ; i++)
{
   System.out.println("i is : " + i);
}
```</code></pre>
</div>
</div>
<div class="paragraph">
<p>Wenn Sie den Namen der Programmiersprache hinzufügen, wie wir es mit <code>java</code> getan haben, wird GitHub versuchen, die Syntax hervorzuheben.
Wie im Beispiel oben, würde es zu <a href="ch00/_md_code">„eingezäuntes“, gerendertes Code-Schnipsel-Beispiel</a> gerendert werden.</p>
</div>
<div id="_md_code" class="imageblock">
<div class="content">
<img src="{{ "book/en/v2/images/markdown-04-fenced-code.png" | relative_url }}" alt="Rendered fenced code">
</div>
<div class="title">Abbildung 104. „eingezäuntes“, gerendertes Code-Schnipsel-Beispiel</div>
</div>
</div>
<div class="sect4">
<h4 id="_quoten_zitieren">Quoten (Zitieren)</h4>
<div class="paragraph">
<p>Wenn Sie auf einen kleinen Teil eines langen Kommentars reagieren wollen, können Sie selektiv aus dem anderen Kommentar zitieren, indem Sie den Zeilen das Zeichen <code>&gt;</code> voranstellen.
Es ist sogar so häufig und nützlich, dass es eine Tastenkombination dafür gibt.
Wenn Sie Text in einem Kommentar markieren, auf den Sie direkt antworten möchten, und die Taste <code>r</code> drücken, wird dieser Text in der Kommentarbox für Sie zitiert.</p>
</div>
<div class="paragraph">
<p>Zitate (engl. quotes) sehen in etwa so aus:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">&gt; Whether 'tis Nobler in the mind to suffer
&gt; The Slings and Arrows of outrageous Fortune,

How big are these slings and in particular, these arrows?</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nach dem Rendern sieht der Kommentar wie folgt aus: <a href="ch00/_md_quote">gerendertes Zitat-Beispiel</a>.</p>
</div>
<div id="_md_quote" class="imageblock">
<div class="content">
<img src="{{ "book/en/v2/images/markdown-05-quote.png" | relative_url }}" alt="Rendered quoting">
</div>
<div class="title">Abbildung 105. gerendertes Zitat-Beispiel</div>
</div>
</div>
<div class="sect4">
<h4 id="_emojis">Emojis</h4>
<div class="paragraph">
<p>Abschließend, Sie können auch Emojis in Ihren Kommentaren verwenden.
Das wird in der Praxis sehr häufig in Kommentaren verwendet. Sie werden es in vielen GitHub-Issues und Pull-Requests sehen.
Es gibt sogar einen Emoji-Helfer in GitHub.
Wenn Sie einen Kommentar eingeben und mit einem <code>:</code> (Doppelpunkt) beginnen, hilft Ihnen ein Autokomplettierer, das Gesuchte schnell zu finden.</p>
</div>
<div id="_md_emoji_auto" class="imageblock">
<div class="content">
<img src="{{ "book/en/v2/images/markdown-06-emoji-complete.png" | relative_url }}" alt="Emoji autocompleter">
</div>
<div class="title">Abbildung 106. Autokomplettierer für Emojis in Aktion</div>
</div>
<div class="paragraph">
<p>Emojis haben die Erscheinungsform von <code>:&lt;name&gt;:</code> irgendwo im Kommentar.
Zum Beispiel könnten Sie so ähnlich wie hier schreiben:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">I :eyes: that :bug: and I :cold_sweat:.

:trophy: for :microscope: it.

:+1: and :sparkles: on this :ship:, it's :fire::poop:!

:clap::tada::panda_face:</code></pre>
</div>
</div>
<div class="paragraph">
<p>Gerendert würde es in etwa so aussehen: <a href="ch00/_md_emoji">Massive Emoji-Kommentare</a>.</p>
</div>
<div id="_md_emoji" class="imageblock">
<div class="content">
<img src="{{ "book/en/v2/images/markdown-07-emoji.png" | relative_url }}" alt="Emoji">
</div>
<div class="title">Abbildung 107. Massive Emoji-Kommentare</div>
</div>
<div class="paragraph">
<p>Nicht, dass das äußerst sinnvoll wäre, aber es ergänzt ein Medium mit Spaß und Emotionen; was sonst nur schwer zu vermitteln wäre.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Anmerkung</div>
</td>
<td class="content">
<div class="paragraph">
<p>Es gibt derzeit eine ganze Reihe von Webservices, die Emoji-Zeichen verwenden.
Ein großartiger Spickzettel, zum Nachschlagen, um ein Emoji zu finden, das ausdrückt, was Sie sagen wollen, finden Sie unter:</p>
</div>
<div class="paragraph">
<p><a href="https://www.webfx.com/tools/emoji-cheat-sheet/" class="bare" target="_blank" rel="noopener">https://www.webfx.com/tools/emoji-cheat-sheet/</a></p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h4 id="_bilder">Bilder</h4>
<div class="paragraph">
<p>Technisch gesehen ist das keine GitHub-Variante von Markdown, aber es ist unglaublich praktisch.
Neben dem Hinzufügen von Markdown-Bildlinks zu Kommentaren, für die es schwierig sein kann, URLs zum Einbetten zu finden, können Sie mit GitHub Bilder per Drag&amp;Drop in Textbereiche ziehen und so einbinden.</p>
</div>
<div id="_md_drag" class="imageblock">
<div class="content">
<img src="{{ "book/en/v2/images/markdown-08-drag-drop.png" | relative_url }}" alt="Drag and drop images">
</div>
<div class="title">Abbildung 108. Bilder per Drag&amp;Drop hochladen und automatisch einbetten</div>
</div>
<div class="paragraph">
<p>Wenn Sie sich <a href="ch00/_md_drag">Bilder per Drag&amp;Drop hochladen und automatisch einbetten</a> ansehen, werden Sie einen kleinen Hinweis, „Parsed as Markdown“, über dem Textfeld sehen.
Wenn Sie darauf klicken, erhalten Sie einen vollständigen Cheat-Sheet (Spickzettel) mit allem, was Sie mit Markdown auf GitHub machen können.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_fetch_and_push_on_different_repositories">Ihr öffentliches GitHub-Repository aktuell halten</h3>
<div class="paragraph">
<p>Sobald Sie ein GitHub-Repository geforkt haben, existiert Ihr Repository (Ihr „fork“) unabhängig vom Original.
Insbesondere dann, wenn das ursprüngliche Repository neue Commits bekommen hat, informiert Sie GitHub in der Regel durch eine Meldung wie:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">This branch is 5 commits behind progit:master.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Aber Ihr GitHub-Repository wird nie automatisch von GitHub aktualisiert; das ist etwas, was Sie selbst tun müssen.
Glücklicherweise ist das sehr einfach umzusetzen.</p>
</div>
<div class="paragraph">
<p>Die eine Möglichkeit erfordert keine Konfiguration.
Wenn Sie z.B. von <code><a href="https://github.com/progit/progit2.git" class="bare">https://github.com/progit/progit2.git</a></code> geforkt haben, können Sie Ihren <code>master</code> Branch so auf dem neuesten Stand halten:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout master <b class="conum">(1)</b>
$ git pull https://github.com/progit/progit2.git <b class="conum">(2)</b>
$ git push origin master <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Wenn Sie sich in einem anderen Branch befinden, kehren Sie zu <code>master</code> zurück</p>
</li>
<li>
<p>Holen (engl. fetch) Sie sich Änderungen von <code><a href="https://github.com/progit/progit2.git" class="bare">https://github.com/progit/progit2.git</a></code> und mergen Sie sie in den <code>master</code></p>
</li>
<li>
<p>Pushen Sie Ihren <code>master</code> Branch nach <code>origin</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Das funktioniert, aber es ist lästig, die Fetch-URL jedes Mal neu eingeben zu müssen.
Sie können diese Arbeit mit ein wenig Konfiguration automatisieren:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git remote add progit https://github.com/progit/progit2.git <b class="conum">(1)</b>
$ git fetch progit <b class="conum">(2)</b>
$ git branch --set-upstream-to=progit/master master <b class="conum">(3)</b>
$ git config --local remote.pushDefault origin <b class="conum">(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Fügen Sie das Quell-Repository hinzu und geben Sie ihm einen Namen
Hier habe ich mich entschieden, es <code>progit</code> zu nennen</p>
</li>
<li>
<p>Holen (engl. fetch) Sie sich eine Referenz zu den Branches von progit, genauer gesagt vom <code>master</code>.</p>
</li>
<li>
<p>Konfigurieren Sie Ihren <code>master</code> Branch so, dass er von dem <code>progit</code> Remote abgeholt (engl. fetch) wird</p>
</li>
<li>
<p>Definieren Sie das standardmäßige Push-Repository auf <code>origin</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Sobald das getan ist, wird der Workflow viel einfacher:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout master <b class="conum">(1)</b>
$ git pull <b class="conum">(2)</b>
$ git push <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Wenn Sie sich in einem anderen Branch befinden, kehren Sie zu <code>master</code> zurück</p>
</li>
<li>
<p>Fetchen Sie die Änderungen von <code>progit</code> und mergen Sie sie in <code>master</code></p>
</li>
<li>
<p>Pushen Sie Ihren <code>master</code> Branch nach <code>origin</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Dieser Herangehensweise kann nützlich sein, aber sie ist nicht ohne Nachteile.
Git wird diese Aufgabe gerne im Hintergrund für Sie erledigen, aber es wird Sie nicht benachrichtigen, wenn Sie einen Commit zum <code>master</code> machen, von <code>progit</code> pullen und dann zu <code>origin</code> pushen – alle diese Operationen sind mit diesem Setup zulässig.
Sie müssen also darauf achten, nie direkt an den <code>master</code> zu committen, da dieser Branch faktisch zum Upstream-Repository gehört.</p>
</div>
</div>
<div id="nav"><a href="{{ page.book.section.previous | relative_url }}">prev</a> | <a href="{{ page.book.section.next | relative_url }}">next</a></div>