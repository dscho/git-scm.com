---
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: gr
  chapter:
    title: 'Appendix B: Ενσωμάτωση του Git στις εφαρμογές μας'
    number: 2
  section:
    title: Libgit2
    number: 2
    cs_number: A2.2
    previous: book/gr/v2/Appendix-B:-Ενσωμάτωση-του-Git-στις-εφαρμογές-μας-Γραμμή-εντολών-Git
    next: book/gr/v2/Appendix-B:-Ενσωμάτωση-του-Git-στις-εφαρμογές-μας-JGit
title: Git - Libgit2

---
<h2 id="_libgit2">Libgit2</h2>
<div class="paragraph">
<p>©
Μια άλλη επιλογή στη διάθεσή μας είναι να χρησιμοποιήσουμε το Libgit2.
Το Libgit2 είναι μια υλοποίηση του Git χωρίς εξαρτήσεις (dependencies), με έμφαση σε ένα ωραίου API για χρήση σε άλλα προγράμματα.
Μπορούμε να το βρούμε στην <a href="http://libgit2.github.com" class="bare">http://libgit2.github.com</a>.</p>
</div>
<div class="paragraph">
<p>Αρχικά, ας ρίξουμε μια ματιά στο API για C.
Ακολουθεί ένα παράδειγμα τυφώνας!</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">// Άνοιγμα αποθετηρίου
git_repository *repo;
int error = git_repository_open(&amp;repo, "/path/to/repository");

// Αφαίρεση της αναφοράς του HEAD στην υποβολή
git_object *head_commit;
error = git_revparse_single(&amp;head_commit, repo, "HEAD^{commit}");
git_commit *commit = (git_commit*)head_commit;

// Εκτύπωση μερικών από τις ιδιότητες της υποβολής
printf("%s", git_commit_message(commit));
const git_signature *author = git_commit_author(commit);
printf("%s &lt;%s&gt;\n", author-&gt;name, author-&gt;email);
const git_oid *tree_id = git_commit_tree_id(commit);

// Συμμάζεμα
git_commit_free(commit);
git_repository_free(repo);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Οι πρώτες δύο γραμμές ανοίγουν ένα αποθετήριο Git.
Ο τύπος <code>git_repository</code> αντιπροσωπεύει έναν χειριστή ελέγχου (handle) σε ένα αποθετήριο με προσωρινή μνήμη στη μνήμη.
Αυτή είναι η απλούστερη μέθοδος εφόσον γνωρίζουμε την ακριβή διαδρομή στον κατάλογο εργασίας του αποθετηρίου ή στον φάκελο <code>.git</code>.
Υπάρχούν επίσης η <code>git_repository_open_ext</code> που περιλαμβάνει επιλογές αναζήτησης, η <code>git_clone</code> και οι σχετικές εντολές για τη δημιουργία τοπικού κλώνου ενός απομακρυσμένου αποθετηρίου και η <code>git_repository_init</code> για τη δημιουργία ενός εντελώς νέου αποθετηρίου.</p>
</div>
<div class="paragraph">
<p>Το δεύτερο κομμάτι του κώδικα χρησιμοποιεί σύνταξη rev-parse (βλ. ενότητα <a href="ch00/r_branch_references">Αναφορές κλάδων</a> σχετικά) για να πάρει την υποβολή στην οποία δείχνει τελικά ο HEAD.
Ο τύπος που επιστρέφεται είναι ένας δείκτης <code>git_object</code>, που αντιπροσωπεύει κάτι που υπάρχει στη βάση δεδομένων αντικειμένων Git για ένα αποθετήριο.
Το <code>git_object</code> είναι στην πραγματικότητα ένας τύπος “parent” για πολλά διαφορετικά είδη αντικειμένων· η διάταξη μνήμης για καθέναν από τους τύπους “παιδιών” είναι ίδια με εκείνη του <code>git_object</code>, ώστε να μπορούμε να κάνουμε casting με ασφάλεια στο σωστό.
Σε αυτήν την περίπτωση, η <code>git_object_type(commit)</code> θα επέστρεφε <code>GIT_OBJ_COMMIT</code>, επομένως είναι ασφαλές να κάνουμε casting σε έναν δείκτη <code>git_commit</code>.</p>
</div>
<div class="paragraph">
<p>Το επόμενο κομμάτι δείχνει τον τρόπο πρόσβασης στις ιδιότητες της υποβολής.
Η τελευταία γραμμή εδώ χρησιμοποιεί έναν τύπο <code>git_oid</code>· αυτή είναι η αναπαράσταση του Libgit2 για έναν αριθμό SHA-1.</p>
</div>
<div class="paragraph">
<p>Από αυτό το δείγμα, έχουν αρχίσει να αναδύονται δύο μοντέλα:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Αν δηλώσουμε έναν δείκτη και περάσουμε μια αναφορά σε αυτό σε μια κλήση Libgit2, αυτή η κλήση θα επιστρέψει πιθανώς έναν ακέραιο κωδικό σφάλματος.
  Η τιμή <code>0</code> υποδηλώνει επιτυχία· ο,τιδήποτε άλλο υποδηλώνει σφάλμα.</p>
</li>
<li>
<p>Αν το Libgit2 συγκεντρώσει έναν δείκτη για εμάς, είμαστε υπεύθυνοι για την απελευθέρωσή του.</p>
</li>
<li>
<p>Αν το Libgit2 επιστρέψει έναν δείκτη <code>const</code> από μια κλήση, δεν χρειάζεται να τον απελευθερώσουμε, αλλά θα ακυρωθεί όταν το αντικείμενο στο οποίο ανήκει ελευθερωθεί.</p>
</li>
<li>
<p>Ο προγραμματισμός σε C είναι λίγο οδυνηρός.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>
Αυτός ο τελευταίος σημαίνει ότι δεν είναι πολύ πιθανό ότι θα γράφουμε C όταν χρησιμοποιούμε το Libgit2.
Ευτυχώς, υπάρχει ένας αριθμός γλωσσών script που είναι διαθέσιμες και καθιστούν αρκετά εύκολο να δουλέψουμε με αποθετήρια Git από τη συγκεκριμένη γλώσσα και το περιβάλλον μας.
Ας ρίξουμε μια ματιά στο παραπάνω παράδειγμα που γράφτηκε χρησιμοποιώντας τις συνδέσεις (bindings) Ruby για το Libgit2, οι οποίες ονομάζονται Rugged και μπορούν να βρεθούν στην <a href="https://github.com/libgit2/rugged" class="bare">https://github.com/libgit2/rugged</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">repo = Rugged::Repository.new('path/to/repository')
commit = repo.head.target
puts commit.message
puts "#{commit.author[:name]} &lt;#{commit.author[:email]}&gt;"
tree = commit.tree</code></pre>
</div>
</div>
<div class="paragraph">
<p>Όπως βλέπουμε ο κώδικας είναι πιο συμμαζεμένος.
Καταρχάς, η Rugged χρησιμοποιεί εξαιρέσεις (exceptions)· μπορεί να επικαλεστεί σφάλματα όπως <code>ConfigError</code> ή <code>ObjectError</code> για να σηματοδοτήσει συνθήκες σφαλμάτων.
Κατά δεύτερο λόγο, δεν υπάρχει ρητή απελευθέρωση πόρων, διότι η Ruby έχει αυτόματο συλλέκτη σκουπιδιών.
Ας δούμε ένα λίγο πιο σύνθετο παράδειγμα: υλοποίηση μίας υποβολής εκ του μηδενός.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">blob_id = repo.write("Blob contents", :blob)        # <b class="conum">(1)</b>

index = repo.index
index.read_tree(repo.head.target.tree)
index.add(:path =&gt; 'newfile.txt', :oid =&gt; blob_id)  # <b class="conum">(2)</b>

sig = {
    :email =&gt; "bob@example.com",
    :name =&gt; "Bob User",
    :time =&gt; Time.now,
}

commit_id = Rugged::Commit.create(repo,
    :tree =&gt; index.write_tree(repo),                # <b class="conum">(3)</b>
    :author =&gt; sig,
    :committer =&gt; sig,                              # <b class="conum">(4)</b>
    :message =&gt; "Add newfile.txt",                  # <b class="conum">(5)</b>
    :parents =&gt; repo.empty? ? [] : [ repo.head.target ].compact, # <b class="conum">(6)</b>
    :update_ref =&gt; 'HEAD',                                       # <b class="conum">(7)</b>
)
commit = repo.lookup(commit_id)                     # <b class="conum">(8)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Δημιουργούμε ένα νέο blob, που περιέχει τα περιεχόμενα ενός νέου αρχείου.</p>
</li>
<li>
<p>Γεμίζουμε το ευρετήριο με το δέντρο της υποβολής της κεφαλής και προσθέτουμε το νέο αρχείο στη διαδρομή <code>newfile.txt</code>.</p>
</li>
<li>
<p>Αυτό δημιουργεί ένα νέο δέντρο στην ODB και τη χρησιμοποιεί για τη νέα υποβολή.</p>
</li>
<li>
<p>Χρησιμοποιούμε την ίδια υπογραφή για τα πεδία τόσο του συγγραφέα όσο και υποβάλοντος.</p>
</li>
<li>
<p>Το μήνυμα υποβολής.</p>
</li>
<li>
<p>Κατά τη δημιουργία μιας υποβολής, πρέπει να καθορίσουμε τους γονείς της νέας υποβολής.
    Αυτό χρησιμοποιεί την άκρη του HEAD για τον μοναδικό γονέα.</p>
</li>
<li>
<p>Η Rugged (και το Libgit2) μπορούν προαιρετικά να ενημερώσουν μια αναφορά όταν πραγματοποιούν μια υποβολή.</p>
</li>
<li>
<p>Η τιμή επιστροφής είναι ο αριθμός SHA-1 ενός νέου αντικειμένου υποβολής, τον οποίο μπορούμε στη συνέχεια να χρησιμοποιήσουμε για να αποκτήσουμε ένα αντικείμενο <code>Commit</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Ο κώδικας Ruby είναι ωραίος και καθαρός και δεδομένου ότι το Libgit2 κάνει τη βαριά δουλειά, αυτός ο κώδικας θα τρέξει και αρκετά γρήγορα.
Αν δεν είμαστε ρουμπίστες, μπορούμε να δούμε κάποιες άλλες συνδέσεις στην ενότητα <a href="ch00/r_libgit2_bindings">Other Bindings</a>.</p>
</div>
<div class="sect3">
<h3 id="_προηγμένη_λειτουργικότητα">Προηγμένη λειτουργικότητα</h3>
<div class="paragraph">
<p>Το Libgit2 έχει κάποιες δυνατότητες που δεν εμπίπτουν στο πεδίο εφαρμογής του πυρήνα του Git.
Ένα παράδειγμα είναι η σύνδεσιμότητα (pluggability): Το Libgit2 μάς επιτρέπει να παρέχουμε προσαρμοσμένα οπίσθια συστήματα (“backends”) για διάφορους τύπους λειτουργιών, ώστε μπορούμε να αποθηκεύουμε πράγματα με διαφορετικό τρόπο από ό,τι κάνει το stock Git.
Το Libgit2 επιτρέπει εξατομικευμένα οπίσθια συστήματα για τη διαμόρφωση, την αποθήκευση αναφορών και τη βάση δεδομένων αντικειμένων, μεταξύ άλλων.</p>
</div>
<div class="paragraph">
<p>Ας ρίξουμε μια ματιά στο πώς λειτουργεί αυτό.
Ο παρακάτω κώδικας δανείζεται από ένα σύνολο παραδειγμάτων συστημάτων υποστήριξης που παρέχονται από την ομάδα Libgit2 (και βρίσκεται στη διεύθυνση <a href="https://github.com/libgit2/libgit2-backends" class="bare">https://github.com/libgit2/libgit2-backends</a>).
Ακολουθεί ένας τρόπος που ένα εξατομικευμένο σύστημα υποστήριξης βάσης δεδομένων αντικειμένων εγκαθιστάται:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">git_odb *odb;
int error = git_odb_new(&amp;odb);                    // <b class="conum">(1)</b>

git_odb_backend *my_backend;
error = git_odb_backend_mine(&amp;my_backend, /*…*/); // <b class="conum">(2)</b>

error = git_odb_add_backend(odb, my_backend, 1);  // <b class="conum">(3)</b>

git_repository *repo;
error = git_repository_open(&amp;repo, "some-path");
error = git_repository_set_odb(odb);              // <b class="conum">(4)</b></code></pre>
</div>
</div>
<div class="paragraph">
<p><em>(Ας σημειωθεί ότι τα σφάλματα καταγράφονται, αλλά δεν έχουν αντιμετωπίζονται.)</em></p>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Αρχικοποιούμε μια κενή βάση δεδομένων αντικειμένων (ODB) “frontend”, που θα λειτουργήσει ως δοχείο (container) για το οπίσθιο σύστημα που είναι αυτά που κάνουν την πραγματική δουλειά.</p>
</li>
<li>
<p>Αρχικοποιούμε ένα οπίσθιο σύστημα εξατομικευμένης ODB.</p>
</li>
<li>
<p>Προσθέτουμε το οπίσθιο σύστημα στο πρόσθιο σύστημα.</p>
</li>
<li>
<p>Ανοίγουμε ένα αποθετήριο και το ρυθμίζουμε ώστε να χρησιμοποιεί την ODB μας για να αναζητά αντικείμενα.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Αλλά τι είναι αυτό το <code>git_odb_backend_mine</code>;
Λοιπόν, αυτός είναι η κατασκευή (constructor) για τη δική μας υλοποίηση της ODB και μπορούμε να κάνουμε ό,τι θέλουμε εκεί, αρκεί να συμπληρώσουμε τη δομή <code>git_odb_backend</code> σωστά.
Ας δούμε πώς θα <em>μπορούσε</em> να είναι:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">typedef struct {
    git_odb_backend parent;

    // Κάποια άλλα πράγματα
    void *custom_context;
} my_backend_struct;

int git_odb_backend_mine(git_odb_backend **backend_out, /*…*/)
{
    my_backend_struct *backend;

    backend = calloc(1, sizeof (my_backend_struct));

    backend-&gt;custom_context = …;

    backend-&gt;parent.read = &amp;my_backend__read;
    backend-&gt;parent.read_prefix = &amp;my_backend__read_prefix;
    backend-&gt;parent.read_header = &amp;my_backend__read_header;
    // …

    *backend_out = (git_odb_backend *) backend;

    return GIT_SUCCESS;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ο πιο ανεπαίσθητος περιορισμός εδώ είναι ότι το πρώτο μέλος της <code>my_backend_struct</code> πρέπει να είναι μια δομή <code>git_odb_backend</code>· αυτό εξασφαλίζει ότι η διάταξη μνήμης είναι αυτό που ο κώδικας Libgit2 αναμένει να είναι.
Το υπόλοιπο είναι αυθαίρετο· αυτή η δομή μπορεί να είναι όσο μεγάλη ή όσο μικρή θέλουμε να είναι.</p>
</div>
<div class="paragraph">
<p>Η συνάρτηση αρχικοποίησης εκχωρεί κάποια μνήμη για τη δομή, ρυθμίζει το εξατομικευμένο πλαίσιο και στη συνέχεια συμπληρώνει τα μέλη της δομής <code>parent</code> που υποστηρίζει.
Στο αρχείο <code>include/git2/sys/odb_backend.h</code> στον πηγαίο κώδικα του Libgit2 μπορούμε να βρούμε ένα πλήρες σύνολο υπογραφών κλήσεων· η συγκεκριμένη περίπτωση χρήσης μας θα μας βοηθήσει να προσδιορίσουμε ποια από αυτές θα θέλουμε να υποστηρίξουμε.</p>
</div>
</div>
<div class="sect3">
<h3 id="r_libgit2_bindings">Other Bindings</h3>

</div>
<div class="sect3">
<h3 id="_άλλες_συνδέσεις">Άλλες συνδέσεις</h3>
<div class="paragraph">
<p>Το Libgit2 έχει συνδέσεις για πολλές γλώσσες.
Εδώ παρουσιάζουμε ένα μικρό παράδειγμα χρησιμοποιώντας μερικά από τα πιο ολοκληρωμένα πακέτα υποβολής την εποχή που γράφεται αυτό το βιβλίο· υπάρχουν βιβλιοθήκες για πολλές άλλες γλώσσες, συμπεριλαμβανομένων των C++, Go, Node.js, Erlang και JVM, όλες σε διάφορα στάδια ωριμότητας.
Η επίσημη συλλογή συνδέσεων μπορεί να βρεθεί με την περιήγηση των αποθετηρίων στη διεύθυνση <a href="https://github.com/libgit2" class="bare">https://github.com/libgit2</a>.
Ο κώδικας που θα γράψουμε θα επιστρέφει το μήνυμα υποβολής από την υποβολή που στην οποία δείχνει τελικά τελικάο HEAD (κάτι σαν <code>git log -1</code>).</p>
</div>
<div class="sect4">
<h4 id="_libgit2sharp">LibGit2Sharp</h4>
<div class="paragraph">
<p>
Αν γράφουμε μια εφαρμογή .NET ή Mono, το LibGit2Sharp (<a href="https://github.com/libgit2/libgit2sharp" class="bare">https://github.com/libgit2/libgit2sharp</a>) είναι αυτό που ψάχνουμε.
Οι συνδέσεις είναι γραμμένες σε C# και δοθεί ιδιαίτερη φροντίδα οι κλήσεις της Libgit2 να δίνοην ένα αίσθημα API CLR.
Ακολουθεί το παράδειγμά μας:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-csharp" data-lang="csharp">new Repository(@"C:\path\to\repo").Head.Tip.Message;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Για εφαρμογές Windows σε επιτραπέζιους υπολογιστές, υπάρχει ακόμα ένα πακέτο NuGet που θα μας βοηθήσει να ξεκινήσουμε γρήγορα.</p>
</div>
</div>
<div class="sect4">
<h4 id="_objective_git">objective-git</h4>
<div class="paragraph">
<p>
Εάν η εφαρμογή μας εκτελείται σε πλατφόρμα της Apple, πιθανώς να χρησιμοποιούμε τη γλώσσα Objective C ως γλώσσα υλοποίησης.
Objective-Git (<a href="https://github.com/libgit2/objective-git" class="bare">https://github.com/libgit2/objective-git</a>) είναι το όνομα των συνδέσεων Libgit2 για αυτό το περιβάλλον.
Το πρόγραμμα παράδειγμα μοιάζει με αυτό:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-objc" data-lang="objc">GTRepository *repo =
    [[GTRepository alloc] initWithURL:[NSURL fileURLWithPath: @"/path/to/repo"] error:NULL];
NSString *msg = [[[repo headReferenceWithError:NULL] resolvedTarget] message];</code></pre>
</div>
</div>
<div class="paragraph">
<p>Το Objective-git είναι πλήρως διαλειτουργικό με το Swift, άρα δεν υπάρχει πρόβλημα αν έχουμε αφήσει πίσω την Objective-C.</p>
</div>
</div>
<div class="sect4">
<h4 id="_pygit2">pygit2</h4>
<div class="paragraph">
<p>
Οι συνδέσεις για το Libgit2 στην Python ονομάζονται Pygit2 και μπορούν να βρεθούν στην <a href="http://www.pygit2.org/" class="bare">http://www.pygit2.org/</a>.
Το παράδειγμα του προγράμματος μας:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">pygit2.Repository("/path/to/repo") # άνοιξε αποθετήριο
    .head                          # πάρε τον τρέχοντα κλάδο
    .peel(pygit2.Commit)           # πήγαινε στην υποβολή
    .message                       # διάβασε το μήνυμα</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_περαιτέρω_ανάγνωση">Περαιτέρω ανάγνωση</h3>
<div class="paragraph">
<p>Φυσικά, μία πλήρης αντιμετώπιση των δυνατοτήτων του Libgit2 είναι εκτός του σκοπού αυτού του βιβλίου.
Αν θέλουμε περισσότερες πληροφορίες σχετικά με το ίδιο το Libgit2, υπάρχει τεκμηρίωση API στη διεύθυνση <a href="https://libgit2.github.com/libgit2" class="bare">https://libgit2.github.com/libgit2</a> και ένα σύνολο οδηγών στη διεύθυνση <a href="https://libgit2.github.com/docs" class="bare">https://libgit2.github.com/docs</a>.
Για τις άλλες συνδέσεις, θα πρέπει να ελέγξουμε το δεματιασμένο README και τις δοκιμές· υπάρχουν συχνά μικρά tutorial και δείκτες για την περαιτέρω ανάγνωση εκεί.</p>
</div>
</div>
<div id="nav"><a href="{{ page.book.section.previous | relative_url }}">prev</a> | <a href="{{ page.book.section.next | relative_url }}">next</a></div>