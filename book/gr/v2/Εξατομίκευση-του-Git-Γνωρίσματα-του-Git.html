---
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: gr
  chapter:
    title: Εξατομίκευση του Git
    number: 8
  section:
    title: Γνωρίσματα του Git
    number: 2
    cs_number: '8.2'
    previous: book/gr/v2/Εξατομίκευση-του-Git-Διαμόρφωση-Git
    next: book/gr/v2/Εξατομίκευση-του-Git-Τα-άγκιστρα-του-Git
title: Git - Γνωρίσματα του Git

---
<h2 id="_γνωρίσματα_του_git">Γνωρίσματα του Git</h2>
<div class="paragraph">
<p>
Κάποιες από αυτές τις ρυθμίσεις μπορούν επίσης να οριστούν για μια διαδρομή, οπότε το Git εφαρμόζει αυτές τις ρυθμίσεις μόνο για έναν υποκατάλογο ή ένα υποσύνολο αρχείων.
Αυτές οι ρυθμίσεις για συγκεκριμένες διαδρομές ονομάζονται <em>ιδιότητες</em> του Git και ορίζονται ούμε σε ένα αρχείο <code>.gitattributes</code> σε έναν από τους καταλόγους μας (συνήθως τον ριζικό κατάλογο του έργου μας) ούμε στο αρχείο <code>.git/info/attributes</code>, εάν δεν θέλουμε το αρχείο γνωρίσματων να υποβάλλεται με το έργο μας.</p>
</div>
<div class="paragraph">
<p>Με τα γνωρίσματα, μπορούμε να κάνουμε πράγματα όπως να ορίσουμε ξεχωριστές στρατηγικές συγχώνευσης για μεμονωμένα αρχεία ή καταλόγους στο έργο μας, να πούμε στο Git πώς να κάνουμε diff σε δυαδικά αρχεία ή να φιλτράρουμε περιεχόμενο φίλτρου Git πριν το εισάγουμε σε ή εξάγουμε από το Git.
Σε αυτήν την ενότητα, θα μάθουμε μερικά από τα γνωρίσματα που μπορούμε να ορίσουμε στις διαδρομές μας στο Git και θα δούμε μερικά παραδείγματα για τον τρόπο χρήσης αυτού του χαρακτηριστικού στην πράξη.</p>
</div>
<div class="sect3">
<h3 id="_δυαδικά_αρχεία">Δυαδικά αρχεία</h3>
<div class="paragraph">
<p>
Ένα όμορφο τέχνασμα για το οποίο μπορούμε να χρησιμοποιήσουμε τα γνωρίσματα του Git είναι να λέμε στο Git ποια αρχεία είναι δυαδικά (σε περπτώσεις στις οποίες δεν μπορεί να το καταλάβει) και να του δώσουμε συγκεκριμένες οδηγίες για το πώς να χειριστεί αυτά τα αρχεία.
Για παράδειγμα, ορισμένα αρχεία κειμένου ενδέχεται να δημιουργούνται από τον υπολογιστή και να μην μπορούμε να τα περάσουμε από το diff ενώ αντίθετα ορισμένα δυαδικά αρχεία ενδέχεται να μπορούν να περάσουν από το diff.
Θα δούμε πώς μπορούμε να πούμε στο Git ποια είναι ποια.</p>
</div>
<div class="sect4">
<h4 id="_αναγνώριση_δυαδικών_αρχείων">Αναγνώριση δυαδικών αρχείων</h4>
<div class="paragraph">
<p>Ορισμένα αρχεία μοιάζουν με αρχεία κειμένου, αλλά ουσιαστικά πρέπει να αντιμετωπίζονται ως δυαδικά δεδομένα.
Για παράδειγμα, τα έργα Xcode σε Mac περιέχουν ένα αρχείο που με κατάληξη <code>.pbxproj</code>, το οποίο είναι βασικά ένα σύνολο δεδομένων JSON (μορφοποίηση κειμένου Javascript) γραμμένη στον δίσκο από το IDE, το οποίο καταγράφει τις ρυθμίσεις δημιουργίας κ.λπ.
Αν και είναι τεχνικά ένα αρχείο κειμένου (αποτελείται αποκλειστικά από χαρακτήρες κωδικοποιημένους με UTF-8), δεν θέλουμε να το αντιμετωπίζουμε ως τέτοιο, επειδή στην πραγματικότητα είναι πραγματικά μια μικρή βάση δεδομένων —δεν μπορούμε να συγχωνεύσουμε το περιεχόμενο εάν δύο άτομα το τροποποιήσουν και τα diff γενικά δεν είναι χρήσιμα.
Το αρχείο προορίζεται να χρησιμοποιηθεί από ένα μηχάνημα.
Στην ουσία, θέλουμε να αντιμετωπίζεται ως δυαδικό αρχείο.</p>
</div>
<div class="paragraph">
<p>Για να πούμε στο Git να μεταχειρίζεται όλα τα αρχεία <code>pbxproj</code> ως δυαδικά δεδομένα, προσθέτουμε την ακόλουθη γραμμή στο αρχείο <code>.gitattributes</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>*.pbxproj binary</code></pre>
</div>
</div>
<div class="paragraph">
<p>Τώρα, το Git δεν θα προσπαθήσει να μετατρέψει ή να διορθώσει προβλήματα CRLF· ούτε θα προσπαθήσει να υπολογίσει ή να εκτυπώσει μία διαφορά diff για αλλαγές σε αυτό το αρχείο όταν εκτελούμε τις <code>git show</code> ή <code>git diff</code> στο έργο μας.</p>
</div>
</div>
<div class="sect4">
<h4 id="_diff_σε_δυαδικά_αρχεία">Diff σε δυαδικά αρχεία</h4>
<div class="paragraph">
<p>Μπορούμε επίσης να χρησιμοποιήσουμε τη λειτουργικότητα των γνωρισμάτων του Git για να κάνουμε αποτελεσματικά diff δυαδικά αρχεία.
Αυτό μπορούμε να το κάνουμε αυτό λέγοντας στο Git πώς να μετατρέψει τα δυαδικά μας δεδομένα σε κείμενο που μπορεί να συγκριθεί με το κανονικό diff.</p>
</div>
<div class="paragraph">
<p>Πρώτα, θα χρησιμοποιήσουμε αυτήν την τεχνική για να λύσουμε ένα από τα πιο ενοχλητικά προβλήματα που είναι γνωστά στην ανθρωπότητα: τον έλεγχο εκδόσεων σε αρχεία του Microsoft Word.
Όλοι γνωρίζουμε ότι το Word είναι ο πιο αποκρουστικός επεξεργαστής κειμένου που υπάρχει, αλλά παραδόξως, όλοι το χρησιμοποιούμε ακόμα.
Εάν θέλουμε να έχουμε έγγραφα του Word που υπόκεινται σε έλεγχο εκδόσεων, μπορούμε να τα ρίξουμε σε ένα αποθετήριο Git και να τα υποβάλλουμε κάθε τόσο· αλλά τι προσφέρει κάτι τέτοιο;
Εάν τρέξουμε την <code>git diff</code> όπως συνήθως, βλέπουμε κάτι τέτοιο:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff
diff --git a/chapter1.docx b/chapter1.docx
index 88839c4..4afcb7c 100644
Binary files a/chapter1.docx and b/chapter1.docx differ</code></pre>
</div>
</div>
<div class="paragraph">
<p>Δεν μπορούμε να συγκρίνουμε απευθείας δύο εκδόσεις αρχείων Word, εκτός κι αν μεταβούμε (checkout) σε αυτές και τα διαβάσουμε οι ίδιοι, σωστά;
Αποδεικνύεται ότι μπορούμε να το κάνουμε αρκετά καλά χρησιμοποιώντας τα γνωρίσματα του Git.
Τοποθετούμε την ακόλουθη γραμμή στο αρχείο <code>.gitattributes</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>*.docx diff=word</code></pre>
</div>
</div>
<div class="paragraph">
<p>Αυτό λέει στο Git ότι κάθε αρχείο που ταιριάζει με αυτό το μοτίβο (<code>.docx</code>) πρέπει να χρησιμοποιεί το φίλτρο <code>word</code> όταν προσπαθούμε να δούμε το diff του.
Τι είναι φίλτρο <code>word</code>;
Πρέπει να το ρυθμίσουμε.
Εδώ θα ρυθίσουμε το Git να χρησιμοποιήσει το πρόγραμμα <code>docx2txt</code> για να μετατρέπει τα έγγραφα του Word σε αναγνώσιμα αρχεία, τα οποία στη συνέχεια μπορούμε να τα κάνουμε diff.</p>
</div>
<div class="paragraph">
<p>Καταρχήν, θα χρειαστεί να εγκαταστήσουμε το <code>docx2txt</code>· μπορούμε να το κατεβάσουμε από <a href="http://docx2txt.sourceforge.net" class="bare">http://docx2txt.sourceforge.net</a>.
Ακολουθούμε τις οδηγίες στο αρχείο <code>INSTALL</code> για να το βάλουμε κάπου, όπου το κέλυφός μας μπορεί να το βρει.
Στη συνέχεια, θα γράψουμε ένα script wrapper για να μετατρέψουμε την έξοδο στη μορφή που αναμένει το Git.
Δημιουργούμε ένα αρχείο, κάπου στη διαδρομή μας, που ονομάζεται <code>docx2txt</code> και προσθέτουμε αυτά τα περιεχόμενα:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">#!/bin/bash
docx2txt.pl $1 -</code></pre>
</div>
</div>
<div class="paragraph">
<p>Δεν ξεχνάμε να <code>chmod a+x</code> αυτό το αρχείο.
Τέλος, μπορούμε να διαμορφώσουμε το Git για να χρησιμοποιήσουμε αυτό το script:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config diff.word.textconv docx2txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>Τώρα το Git ξέρει ότι αν επιχειρήσει να κάνει μια διαφορά μεταξύ δύο στιγμιότυπων και οποιοδήποτε από τα αρχεία τελειώνει στο <code>.docx</code>, θα πρέπει να τρέξει αυτά τα αρχεία μέσω του φίλτρου` <code>word '', το οποίο ορίζεται ως το πρόγραμμα `docx2txt</code>.
Αυτό ουσιαστικά δημιουργεί ωραίες εκδόσεις κειμένου των αρχείων του Word πριν προσπαθήσει να τα κάνει diff.</p>
</div>
<div class="paragraph">
<p>Ακολουθεί ένα παράδειγμα: Το κεφάλαιο 1 αυτού του βιβλίου μετατράπηκε σε μορφή Word και υποβλήθηκε σε ένα αποθετήριο Git.
Στη συνέχεια προστέθηκε μια νέα παράγραφος.
Ας δούμε τι δείχνει η <code>git diff</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff
diff --git a/chapter1.docx b/chapter1.docx
index 0b013ca..ba25db5 100644
--- a/chapter1.docx
+++ b/chapter1.docx
@@ -2,6 +2,7 @@
 Το κεφάλαιο αυτό ασχολείται με το πώς να ξεκινήσουμε με το Git.
Θα ξεκινήσουμε αναφέροντας μερικά πράγματα για την ιστορία των εργαλείων ελέγχου εκδόσεων, έπειτα θα προχωρήσουμε στο πώς μπορεί κάποιος να εγκαταστήσει το Git στον υπολογιστή του και τελικά πώς να το ρυθμίσει, ώστε να μπορεί να ξεκινήσει να το δουλεύει.
 1.1. Σχετικά με τον έλεγχο εκδόσεων
 Τι είναι ο έλεγχος εκδόσεων και γιατί πρέπει να μας απασχολεί; Ο έλεγχος εκδόσεων είναι ένα σύστημα το οποίο καταγράφει αλλαγές σε ένα αρχείο ή σε ένα σύνολο αρχείων έτσι ώστε να μπορούμε να ανακαλέσουμε συγκεκριμένες εκδόσεις. Στα παραδείγματα του βιβλίου, τα αρχεία που θα χρησιμοποιήσουμε για έλεγχο εκδόσεων θα είναι αρχεία πηγαίου κώδικα λογισμικού αν και στην πραγματικότητα, θα μπορούσαμε να χρησιμοποιήσουμε αρχεία οποιουδήποτε τύπου.
+Δοκιμή: 1, 2, 3.
 Αν είμαστε γραφίστες ή σχεδιαστές ιστοσελίδων και θέλουμε να κρατήσουμε κάθε έκδοση μιας εικόνας ή μιας διάταξης (κάτι το οποίο είναι πολύ πιθανό) τότε ένα Σύστημα Ελέγχου Εκδόσεων (Version Control System - VCS) είναι μια πολύ σοφή επιλογή. Ένα τέτοιο σύστημα μάς επιτρέπει να επαναφέρουμε συγκεκριμένα αρχεία σε κάποια προγενέστερη κατάσταση, να επαναφέρουμε ακόμα και ολόκληρο έργο (project) σε προγενέστερη κατάσταση, να συγκρίνουμε αλλαγές με την πάροδο του χρόνου, να δούμε ποιος τροποποίησε τελευταίος κάτι που ενδεχομένως δημιουργεί κάποιο πρόβλημα, ποιος έθεσε ένα ζήτημα και άλλα πολλά. Η χρήση ενός συστήματος ελέγχου εκδόσεων σημαίνει επίσης ότι αν τα κάνουμε θάλασσα ή χάσουμε αρχεία, είναι εύκολο να τα ανακτήσουμε. Επιπλέον, όλες αυτές οι δυνατότητες προσφέρονται με πολύ μικρή επιβάρυνση.
 1.1.1. Τοπικά συστήματα ελέγχου εκδόσεων
 Η μέθοδος που επιλέγουν πολλοί για έλεγχο εκδόσεων αρχείων είναι να αντιγράφουν τα αρχεία σε ένα άλλο κατάλογο (πιθανότατα ένα χρονολογημένο κατάλογο αν είναι έξυπνοι).
Αυτή η προσέγγιση είναι πολύ κοινή επειδή είναι τόσο απλή, συγχρόνως όμως είναι και πολύ επιρρεπής σε λάθη. Είναι εύκολο να ξεχάσει κανείς σε ποιον κατάλογο βρίσκεται και να γράψει στο λάθος αρχείο ή να αντιγράψει σε αρχεία που δεν ήθελε.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Το Git με επιτυχία και συνοπτικά μας λέει ότι προσθέσαμε τη συμβολοσειρά <code>Δοκιμή: 1, 2, 3.</code>, κάτι που είναι σωστό.
Δεν είναι τέλειο —οι αλλαγές μορφοποίησης δεν θα εμφανιστούν εδώ— αλλά πάντως λειτουργεί.</p>
</div>
<div class="paragraph">
<p>Ένα άλλο ενδιαφέρον πρόβλημα που μπορούμε να επιλύσουμε με αυτόν τον τρόπο περιλαμβάνει το diff αρχείων εικόνας.
Ένας τρόπος για να γίνει αυτό είναι να περάσουμε αρχεία εικόνας μέσα από ένα φίλτρο που εξάγει τις πληροφορίες EXIF​ —μεταδεδομένα που καταγράφονται με τις περισσότερες μορφές εικόνας.
Εάν κατεβάσουμε και εγκαταστήσουμε το πρόγραμμα <code>exiftool</code>, μπορούμε να το χρησιμοποιήσουμε για να μετατρέψουμε τις εικόνες μας σε κείμενο σχετικά με τα μεταδεδομένα, οπότε τουλάχιστον το diff θα μας δείξει μια αναπαράσταση κειμένου οποιωνδήποτε αλλαγών συνέβησαν:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ echo '*.png diff=exif' &gt;&gt; .gitattributes
$ git config diff.exif.textconv exiftool</code></pre>
</div>
</div>
<div class="paragraph">
<p>Εάν αντικαταστήσουμε μια εικόνα στο έργο μας και εκτελέσουμε το <code>git diff</code>, θα δούμε κάτι σαν αυτό:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>diff --git a/image.png b/image.png
index 88839c4..4afcb7c 100644
--- a/image.png
+++ b/image.png
@@ -1,12 +1,12 @@
 ExifTool Version Number         : 7.74
-File Size                       : 70 kB
-File Modification Date/Time     : 2009:04:21 07:02:45-07:00
+File Size                       : 94 kB
+File Modification Date/Time     : 2009:04:21 07:02:43-07:00
 File Type                       : PNG
 MIME Type                       : image/png
-Image Width                     : 1058
-Image Height                    : 889
+Image Width                     : 1056
+Image Height                    : 827
 Bit Depth                       : 8
 Color Type                      : RGB with Alpha</code></pre>
</div>
</div>
<div class="paragraph">
<p>Μπορούμε εύκολα να δούμε ότι το μέγεθος του αρχείου και οι διαστάσεις εικόνας έχουν αλλάξει.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="r_keyword_expansion">Επέκταση λέξεων-κλειδιών</h3>
<div class="paragraph">
<p>
Η επέκταση λέξεων-κλειδιών τύπου SVN ή CVS είναι κάτι που το ζητούν συχνά προγραμματιστές που έχουν χρησιμοποιήσει αυτά τα συστήματα.
Το κύριο πρόβλημα με αυτό στο Git είναι ότι δεν μπορούμε να τροποποιήσουμε ένα αρχείο με πληροφορίες σχετικά με την υποβολή, αφού έχουμε υποβάλει, επειδή το Git πρώτα ελέγχει αριθμητικά το αρχείο.
Ωστόσο, μπορούμε να προσθέσουμε κείμενο σε ένα αρχείο όταν αυτό έχει ενημερωθεί και να το αφαιρέσουμε ξανά πριν προστεθεί σε μια υποβολή.
Τα γνωρίσματα του Git μάς προσφέρουν δύο τρόπους για να το κάνουμε αυτό.</p>
</div>
<div class="paragraph">
<p>Καταρχάς, μπορούμε να εισάγουμε το άθροισμα ελέγχου SHA-1 ενός blob σε ένα πεδίο <code>$Id$</code> στο αρχείο.
Αν ορίσουμε αυτό το γνώρισμα σε ένα αρχείο ή ένα σύνολο αρχείων, τότε την επόμενη φορά που θα μεταβούμε σε αυτόν τον κλάδο, το Git θα αντικαταστήσει αυτό το πεδίο με το SHA-1 του blob.
Είναι σημαντικό να τονίσουμε ότι δεν είναι το SHA-1 της υποβολής αλλά το ίδιο το blob:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ echo '*.txt ident' &gt;&gt; .gitattributes
$ echo '$Id$' &gt; test.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>Την επόμενη φορά που θα ενημερώσουμε (checkout) αυτό το αρχείο, το Git χώσει το SHA-1 του blob:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ rm test.txt
$ git checkout -- test.txt
$ cat test.txt
$Id: 42812b7653c7b88933f8a9d6cad0ca16714b9bb3 $</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ωστόσο, το αποτέλεσμα αυτό είναι περιορισμένης χρήσης.
Κάποιος που έχει χρησιμοποιήσει αντικατάσταση λέξεων-κλειδιών σε CVS ή Subversion, μπορεί να συμπεριλάβει χρονική σήμανση —ο αριθμός SHA-1 δεν είναι και πολύ χρήσιμος, επειδή είναι αρκετά τυχαίος και δεν μπορούμε να διαπιστώσουμε αν ένας SHA-1 είναι παλαιότερος ή νεότερος απλά κοιτάζοντάς τους.</p>
</div>
<div class="paragraph">
<p>Αποδεικνύεται ότι μπορούμε να γράψουμε τα δικά μας φίλτρα για να κάνουμε αντικαταστάσεις στα αρχεία κατά την υποβολή ή ενημέρωση.
Αυτά ονομάζονται <code>clean</code> (“καθαρίσματος”) και <code>smudge</code> (“μουτζούρωματος”).
Στο αρχείο <code>.gitattributes</code>, μπορούμε να ορίσουμε ένα φίλτρο για συγκεκριμένες διαδρομές και στη συνέχεια να ορίσουμε script που θα επεξεργάζονται αρχεία λίγο πριν από την ενημέρωσή (checkout) τους (“μουτζούρωμα”, βλ. <a href="ch00/rfilters_a">Τα φίλτρα “μουτζουρώματος” τρέχουν στην ενημέρωση (checkout).</a>) και ακριβώς πριν μπουν στο στάδιο καταχώρισης (βλ. <a href="ch00/rfilters_b">Τα φίλτρα “καθαρίσματος” τρέχουν όταν τα αρχεία μπαίνουν στο στάδιο καταχώρισης.</a>).
Αυτά τα φίλτρα μπορούν να ρυθμιστούν ώστε να κάνουν διάφορα είδη διασκέδασης.</p>
</div>
<div id="rfilters_a" class="imageblock">
<div class="content">
<img src="{{ "book/en/v2/images/smudge.png" | relative_url }}" alt="Τα φίλτρα ``μουτζουρώματος'' τρέχουν στην ενημέρωση (checkout).">
</div>
<div class="title">Figure 144. Τα φίλτρα “μουτζουρώματος” τρέχουν στην ενημέρωση (checkout).</div>
</div>
<div id="rfilters_b" class="imageblock">
<div class="content">
<img src="{{ "book/en/v2/images/clean.png" | relative_url }}" alt="Τα φίλτρα ``καθαρίσματος'' τρέχουν όταν τα αρχεία μπαίνουν στο στάδιο καταχώρισης.">
</div>
<div class="title">Figure 145. Τα φίλτρα “καθαρίσματος” τρέχουν όταν τα αρχεία μπαίνουν στο στάδιο καταχώρισης.</div>
</div>
<div class="paragraph">
<p>Το αρχικό μήνυμα υποβολής για αυτό το χαρακτηριστικό παρέχει ένα απλό παράδειγμα εκτέλεσης όλου του πηγαίου κώδικα C μας μέσω του προγράμματος <code>indent</code> πριν από την υποβολή.
Μπορούμε να το ρυθμίσουμε ορίζοντας στο φίλτρο γνωρισμάτων στο αρχείο <code>.gitattributes</code> να φιλτράρει τα αρχεία <code>*.c</code> με το φίλτρο ‘indent’:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>*.c filter=indent</code></pre>
</div>
</div>
<div class="paragraph">
<p>Στη συνέχεια, λέμε στο Git τι κάνει το φίλτρο <code>indent</code> κατά το μουτζούρωμα και το καθάρισμα:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global filter.indent.clean indent
$ git config --global filter.indent.smudge cat</code></pre>
</div>
</div>
<div class="paragraph">
<p>Σε αυτήν την περίπτωση, όταν υποβάλλουμε αρχεία που ταιριάζουν με το <code>*.c</code>, το Git θα τα περάσει μέσα από το <code>indent</code> πριν τα βάλει στο στάδιο καταχώρισης και στη συνέχεια θα τα περάσει μέσα από το πρόγραμμα <code>cat</code> προτού τα ενημερώσει (checkout) ξανά στον δίσκο.
Το πρόγραμμα <code>cat</code> ουσιαστικά δεν κάνει τίποτα: βγάζει ως έξοδο τα ίδια δεδομένα που δέχεται ως είσοδο.
Αυτός ο συνδυασμός ουσιαστικά φιλτράρει όλα τα αρχεία πηγαίου κώδικα C μέσω του <code>indent</code> πριν από την υποβολή.</p>
</div>
<div class="paragraph">
<p>Ένα άλλο ενδιαφέρον παράδειγμα είναι αυτό που κάνει την επέκταση λέξης-κλειδιού <code>$Date$</code>, όπως στο RCS.
Για να γίνει αυτό σωστά, χρειαζόμαστε ένα μικρό script που παίρνει ένα όνομα αρχείου, βρίσκει την τελευταία ημερομηνία υποβολής για αυτό το έργο και εισάγει την ημερομηνία στο αρχείο.
Εδώ είναι ένα μικρό script Ruby που το κάνει αυτό:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">#! /usr/bin/env ruby
data = STDIN.read
last_date = `git log --pretty=format:"%ad" -1`
puts data.gsub('$Date$', '$Date: ' + last_date.to_s + '$')</code></pre>
</div>
</div>
<div class="paragraph">
<p>Αυτό που κάνει το script είναι να παίρνει την τελευταία ημερομηνία υποβολής από την εντολή <code>git log</code>, να τη βάζει δίπλα σε όποια συμβολοσειρά <code>$Date$</code> βλέπει στο stdin και να εκτυπώνει το αποτέλεσμα —θα πρέπει να είναι απλό να κάνουμε σε οποιαδήποτε γλώσσα έχουμε μεγαλύτερη αυτοπεποίθηση.
Μπορούμε να ονομάσουμε αυτό το αρχείο <code>expand_date</code> και να το βάλουμε στη διαδρομή μας.
Τώρα πρέπει να ρυθμίσουμε ένα φίλτρο στο Git (ας το ονομάσουμε <code>dater</code>) και να του πούμε να χρησιμοποιηεί το φίλτρο <code>expand_date</code> για να μουτζουρώσει τα αρχεία κατά την ενημέρωσή τους (checkout).
Θα χρησιμοποιήσουμε μια εντολή Perl για να καθαρίσουμε την υποβολή:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config filter.dater.smudge expand_date
$ git config filter.dater.clean 'perl -pe "s/\\\$Date[^\\\$]*\\\$/\\\$Date\\\$/"'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Αυτός ο κώδικας Perl διαγράφει ο,τιδήποτε βλέπει σε μια συμβολοσειρά <code>$Date$</code>, για να επιστρέψουμε στο σημείο από το οποίο ξεκινήσαμε.
Τώρα που το φίλτρο μας είναι έτοιμο, μπορούμε να το δοκιμάσουμε φτιάχνοντας ένα αρχείο με τη λέξη κλειδί <code>$Date$</code> και στη συνέχεια να ορίσουμε ένα γνώρισμα του Git για το συγκεκριμένο αρχείο που ενεργοποιεί το νέο φίλτρο:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ echo '# $Date$' &gt; date_test.txt
$ echo 'date*.txt filter=dater' &gt;&gt; .gitattributes</code></pre>
</div>
</div>
<div class="paragraph">
<p>Εάν υποβάλλουμε αυτές τις αλλαγές και ενημερώσουμε (checkout) ξανά το αρχείο, θα δούμε τη λέξη-κλειδί να έχει αντικατασταθεί σωστά:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git add date_test.txt .gitattributes
$ git commit -m "Testing date expansion in Git"
$ rm date_test.txt
$ git checkout date_test.txt
$ cat date_test.txt
# $Date: Tue Apr 21 07:26:52 2009 -0700$</code></pre>
</div>
</div>
<div class="paragraph">
<p>Είναι φανερό το πόσο ισχυρή είναι αυτή η τεχνική για εξατομικευμένες εφαρμογές.
Θα πρέπει όμως να είμαστε προσεκτικοί επειδή το αρχείο <code>.gitattributes</code> υποβάλλεται και μεταφέρεται με το έργο, αλλά ο οδηγός (σε αυτήν την περίπτωση, το φίλτρο <code>dater</code>) δεν υποβάλλεται ή μεταφέρεται, οπότε δεν θα λειτουργεί παντού.
Όταν σχεδιάζουμε αυτά τα φίλτρα, θα πρέπει να είναι σε θέση να αποτύχουν με χάρη και το έργο να εξακολουθεί να λειτουργεί σωστά.</p>
</div>
</div>
<div class="sect3">
<h3 id="_εξαγωγή_του_αποθετηρίου">Εξαγωγή του αποθετηρίου</h3>
<div class="paragraph">
<p>
Τα δεδομένα γνωρίσματων του Git μάς επιτρέπουν επίσης να κάνουμε μερικά ενδιαφέροντα πράγματα κατά την εξαγωγή μίας αρχειοθήκης (archive) του έργου μας.</p>
</div>
<div class="sect4">
<h4 id="_export_ignore"><code>export-ignore</code></h4>
<div class="paragraph">
<p>Μπορούμε να πούμε στο Git να μην εξάγει συγκεκριμένα αρχεία ή καταλόγους κατά τη δημιουργία μίας αρχειοθήκης.
Αν υπάρχουν υποκατάλογοι ή αρχεία που δεν θέλουμε να συμπεριλάβουμε στην αρχειοθήκη αλλά θέλουμε να ελέγχονται στο έργο μας, μπορούμε να τα προσδιορίσουμε μέσω του γνωρίσματος <code>export-ignore</code>.</p>
</div>
<div class="paragraph">
<p>Για παράδειγμα, ας πούμε ότι έχουμε κάποια δοκιμαστικά αρχεία σε έναν υποκατάλογο <code>test/</code> και δεν έχει νόημα να τα συμπεριλάβουμε στην εξαγωγή ενός αρχείου tarball του έργου μας.
Μπορούμε να προσθέσουμε την ακόλουθη γραμμή στο αρχείο γνωρίσματων Git:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>test/ export-ignore</code></pre>
</div>
</div>
<div class="paragraph">
<p>Τώρα, όταν τρέχουμε αρχείο git για να δημιουργήσουμε ένα tarball του έργου μας, αυτός ο κατάλογος δεν θα συμπεριληφθεί στο αρχείο.</p>
</div>
</div>
<div class="sect4">
<h4 id="_export_subst"><code>export-subst</code></h4>
<div class="paragraph">
<p>Κατά την εξαγωγή αρχείων για ανάπτυξη (deployment), μπορούμε να εφαρμόσουμε τη μορφοποίηση της <code>git log</code> και την επέκταση λέξεων-κλειδιών σε επιλεγμένα τμήματα αρχείων που σημειώνονται με το γνώρισμα <code>export-subst</code>.</p>
</div>
<div class="paragraph">
<p>Για παράδειγμα, εάν θέλουμε να συμπεριλάβουμε ένα αρχείο με το όνομα <code>LAST_COMMIT</code> στο έργο μας και να έχουμε μεταδεδομένα για την τελευταία υποβολή που εισάγεται αυτόματα σε αυτό όταν τρέχει η <code>git archive</code>, μπορούμε π.χ. να ρυθμίσουμε το αρχείο ως εξής:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ echo 'Last commit date: $Format:%cd by %aN$' &gt; LAST_COMMIT
$ echo "LAST_COMMIT export-subst" &gt;&gt; .gitattributes
$ git add LAST_COMMIT .gitattributes
$ git commit -am 'adding LAST_COMMIT file for archives'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Όταν τρέχουμε την <code>git archive</code>, τα περιεχόμενα του αρχειοθετημένου αρχείου θα μοιάζουν με αυτό:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git archive HEAD | tar xCf ../deployment-testing -
$ cat ../deployment-testing/LAST_COMMIT
Last commit date: Tue Apr 21 08:38:48 2009 -0700 by Scott Chacon</code></pre>
</div>
</div>
<div class="paragraph">
<p>Οι αντικαταστάσεις είναι δυνατό να περιλαμβάνουν, για παράδειγμα, το μήνυμα υποβολής και οποιεσδήποτε σημειώσεις της <code>git</code> και της <code>git log</code> μπορεί να κάνει απλή αναδίπλωση λέξεων:</p>
</div>
<div class="listingblock console">
<div class="content">
<pre class="highlight"><code>$ echo '$Format:Last commit: %h by %aN at %cd%n%+w(76,6,9)%B$' &gt; LAST_COMMIT
$ git commit -am 'export-subst uses git log's custom formatter

git archive uses git log's `pretty=format:` processor
directly, and strips the surrounding `$Format:` and `$`
markup from the output.
'
$ git archive @ | tar xfO - LAST_COMMIT
Last commit: 312ccc8 by Jim Hill at Fri May 8 09:14:04 2015 -0700
       export-subst uses git log's custom formatter

         git archive uses git log's `pretty=format:` processor directly, and
         strips the surrounding `$Format:` and `$` markup from the output.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Το αρχείο που προκύπτει είναι κατάλληλο για εργασία ανάπτυξης, αλλά όπως και οποιαδήποτε εξαγόμενη αρχειοθήκη, δεν είναι κατάλληλο για περαιτέρω εργασίες ανάπτυξης.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_στρατηγικές_συγχώνευσης">Στρατηγικές συγχώνευσης</h3>
<div class="paragraph">
<p>
Μπορούμε επίσης να χρησιμοποιήσουμε τα γνωρίσματα του Git για να πούμε στο Git να χρησιμοποιεί διαφορετικές στρατηγικές συγχώνευσης για συγκεκριμένα αρχεία στο έργο μας.
Μια πολύ χρήσιμη επιλογή είναι να πούμε στο Git να μην προσπαθήσει να συγχωνεύσει συγκεκριμένα αρχεία όταν έχουν συγκρούσει, αλλά να χρησιμοποιήσει τις δικές μας αλλαγές σε βάρος αυτών κάποιου άλλου.</p>
</div>
<div class="paragraph">
<p>Αυτό είναι χρήσιμο εάν ένας κλάδος στο έργο μας έχει αποκλίνει ή είναι εξειδικευμένο, αλλά θέλουμε να μπορούμε να συγχωνεύουμε αλλαγές από αυτόν και θέλουμε να αγνοήσουμε ορισμένα αρχεία.
Ας υποθέσουμε ότι έχουμε ένα αρχείο ρυθμίσεων μίας βάσης δεδομένων που ονομάζεται <code>database.xml</code> που διαφέρει σε δύο κλάδους και θέλουμε να συγχωνεύσουμε τον άλλο κλάδο μας χωρίς να ανακατώσουμε το αρχείο της βάσης δεδομένων.
Μπορούμε να ορίσουμε ένα γνώρισμα όπως αυτό:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>database.xml merge=ours</code></pre>
</div>
</div>
<div class="paragraph">
<p>Στη συνέχεια, ορίζουμε μια ψεύτικη στρατηγική συγχώνευσης <code>ours</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global merge.ours.driver true</code></pre>
</div>
</div>
<div class="paragraph">
<p>Εάν συγχωνευτούμε στον άλλο κλάδο, αντί να έχουμε συγκρούσεις συγχώνευσης στο αρχείο <code>database.xml</code>, θα δούμε κάτι σαν αυτό:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge topic
Auto-merging database.xml
Merge made by recursive.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Σε αυτήν την περίπτωση, το <code>database.xml</code> παραμένει σε οποιαδήποτε έκδοση έχουμε αρχικά.</p>
</div>
</div>
<div id="nav"><a href="{{ page.book.section.previous | relative_url }}">prev</a> | <a href="{{ page.book.section.next | relative_url }}">next</a></div>