---
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: gr
  chapter:
    title: Εργαλεία του Git
    number: 7
  section:
    title: Συγχωνεύσεις για προχωρημένους
    number: 8
    cs_number: '7.8'
    previous: book/gr/v2/Εργαλεία-του-Git-Απομυθοποίηση-της-reset
    next: book/gr/v2/Εργαλεία-του-Git-Rerere
title: Git - Συγχωνεύσεις για προχωρημένους

---
<h2 id="r_advanced_merging">Συγχωνεύσεις για προχωρημένους</h2>
<div class="paragraph">
<p>Οι συγχωνεύσεις στο Git είναι συνήθως αρκετά εύκολη υπόθεση.
Το ότι το Git καθιστά εύκολη τη συγχώνευση ενός κλάδου πολλές φορές, σημαίνει ότι μπορούμε να έχουμε έναν πολύ μακρόβιο κλάδο, τον οποίο να ενημερώνουμε κάθε τόσο, επιλύοντας μικρές συγκρούσεις συχνά, αντί να εκπλαγούμε από μια τεράστια σύγκρουση στο τέλος.</p>
</div>
<div class="paragraph">
<p>Εντούτοις, μερικές φορές προκύπτουν δύσκολες συγκρούσεις.
Σε αντίθεση με κάποια άλλα συστήματα ελέγχου εκδόσεων, το Git δεν προσπαθεί να είναι υπερβολικά έξυπνο όσον αφορά στην επίλυση συγκρούσεων.
Η φιλοσοφία του Git είναι να είναι έξυπνο στο να προσδιορίζει πότε μια επίλυση συγχώνευσης μπορεί να γίνει χωρίς συγκρούσεις αλλά εφόσον υπάρχει σύγκρουση, δεν προσπαθεί να είναι έξυπνο για την αυτόματη επίλυσή της.
Επομένως, αν περιμένουμε πολύ για να συγχωνεύσουμε δύο κλάδους που αποκλίνουν με ταχύτητα, μπορεί να αντιμετωπίσουμε προβλήματα.</p>
</div>
<div class="paragraph">
<p>Σε αυτήν την ενότητα, θα αναφερθούμε σε τι προβλήματα μπορεί να συναντήσουμε και τι εργαλεία μας δίνει το Git για να βοηθήσουμε να χειριστούμε αυτές δύσκολες καταστάσεις.
Θα καλύψουμε επίσης μερικούς από τους διαφορετικούς, μη τυποποιημένους τύπους συγχώνευσης που μπορούμε να κάνουμε καθώς και να δούμε πώς μπορούμε να βγούμε από συγχωνεύσεις που έχουμε ήδη κάνει.</p>
</div>
<div class="sect3">
<h3 id="_συγκρούσεις_συγχωνεύσεων">Συγκρούσεις συγχωνεύσεων</h3>
<div class="paragraph">
<p>Έχουμε καλύψει κάποια βασικά στοιχεία για την επίλυση των συγκρούσεων
συγχώνευσης στην ενότητα <a href="ch00/r_basic_merge_conflicts">Βασικές συγκρούσεις συγχωνεύσεων</a>· για πιο πολύπλοκες
συγκρούσεις το Git παρέχει μερικά εργαλεία για να μας βοηθήσει να καταλάβουμε τι συμβαίνει και πώς να αντιμετωπίσουμε καλύτερα τη σύγκρουση.</p>
</div>
<div class="paragraph">
<p>Πρώτα απ' όλα, αν είναι δυνατόν, προσπαθούμε να βεβαιωθούμε ότι ο κατάλογος εργασίας μας είναι καθαρός πριν κάνουμε μια συγχώνευση που μπορεί να έχει συγκρούσεις.
Εάν έχουμε εργασία σε εξέλιξη, είτε την υποβάλουμε σε έναν προσωρινό κλάδο είτε την παρακαταθέτουμε (stash).
Αν το κάνουμε αυτό, τότε μπορούμε να ακυρώσουμε <strong>ο,τιδήποτε</strong> δοκιμάσουμε εδώ.
Εάν έχουμε μη αποθηκευμένες αλλαγές στον κατάλογο εργασίας μας όταν συγχωνεύουμε, ορισμένες από αυτές τις συμβουλές μπορεί να μας κάνουν να  να χάσουμε αυτήν την εργασία.</p>
</div>
<div class="paragraph">
<p>Ας δούμε ένα πολύ απλό παράδειγμα.
Έχουμε ένα πολύ απλό αρχείο Ruby που εκτυπώνει <em>hello world</em>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">#! /usr/bin/env ruby

def hello
  puts 'hello world'
end

hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Στο αποθετήριό μας, δημιουργούμε έναν νέο κλάδο που ονομάζεται <code>whitespace</code> και προχωράμε στην αλλαγή όλων των τερματισμών γραμμής Unix σε τερματισούς γραμμής DOS, δηλαδή ουσιαστικά αλλάζουμε κάθε γραμμή του αρχείου, αλλά μόνο με κενά.
Στη συνέχεια, αλλάζουμε τη γραμμή <code>hello world</code> στο <code>hello mundo</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout -b whitespace
Switched to a new branch 'whitespace'

$ unix2dos hello.rb
unix2dos: converting file hello.rb to DOS format ...
$ git commit -am 'converted hello.rb to DOS'
[whitespace 3270f76] converted hello.rb to DOS
 1 file changed, 7 insertions(+), 7 deletions(-)

$ vim hello.rb
$ git diff -b
diff --git a/hello.rb b/hello.rb
index ac51efd..e85207e 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,7 +1,7 @@
 #! /usr/bin/env ruby

 def hello
-  puts 'hello world'
+  puts 'hello mundo'^M
 end

 hello()

$ git commit -am 'hello mundo change'
[whitespace 6d338d2] hello mundo change
 1 file changed, 1 insertion(+), 1 deletion(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Τώρα επιστρέφουμε στον κλάδο <code>master</code> και προσθέτουμε κάποια τεκμηρίωση στη συνάρτηση.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout master
Switched to branch 'master'

$ vim hello.rb
$ git diff
diff --git a/hello.rb b/hello.rb
index ac51efd..36c06c8 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,5 +1,6 @@
 #! /usr/bin/env ruby

+# εκτυπώνει έναν χαιρετισμό
 def hello
   puts 'hello world'
 end

$ git commit -am 'document the function'
[master bec6336] document the function
 1 file changed, 1 insertion(+)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Προσπαθούμε να συγχωνέψουμε τον κλάδο μας <code>whitespace</code>· θα έχουμε συγκρούσεις εξαιτίας των αλλαγών στα λευκά διαστήματα.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge whitespace
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Automatic merge failed; fix conflicts and then commit the result.</code></pre>
</div>
</div>
<div class="sect4">
<h4 id="r_abort_merge">Απόρριψη συγχώνευσης</h4>
<div class="paragraph">
<p>Έχουμε κάποιες επιλογές.
Πρώτον, ας δούμε πώς θα βγούμε από αυτήν την κατάσταση.
Εάν δεν αναμέναμε τις συγκρούσεις και δεν θέλουμε να ασχοληθούμε με αυτήν την κατάσταση, μπορούμε απλά να βγούμε από τη συγχώνευση με την εντολή <code>git merge --abort</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status -sb
## master
UU hello.rb

$ git merge --abort

$ git status -sb
## master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Η επιλογή <code>git merge --abort</code> προσπαθεί να μας επιστρέψει στην κατάστασή μας πριν εκτελέσουμε τη συγχώνευση.
Οι μόνες περιπτώσεις στις οποίες μπορεί να μην είναι σε θέση να το κάνει τέλεια, είναι εάν είχαμε μη παρακατατεθειμένες, μη υποβεβλημένες αλλαγές στον κατάλογο εργασίας όταν την τρέξαμε, αλλιώς θα έπρεπε να δουλέψει μια χαρά.</p>
</div>
<div class="paragraph">
<p>Αν για κάποιο λόγο θέλουμε απλώς να αρχίσουμε από την αρχή, μπορούμε επίσης να εκτελέσουμε την <code>git reset --hard HEAD</code> και το αποθετήριό μας  θα επιστρέψει στην τελευταία υποβεβλημένη κατάσταση.
Είναι σημαντικό να Θυμόμαστε ότι οποιαδήποτε μη υποβεβλημένη εργασία θα χαθεί, οπότε πρέπει να είμαστε σίγουροι ότι δεν θέλουμε αυτές τις αλλαγές.</p>
</div>
</div>
<div class="sect4">
<h4 id="_αγνόηση_των_λευκών_χαρακτήρων">Αγνόηση των λευκών χαρακτήρων</h4>
<div class="paragraph">
<p>Στη συγκεκριμένη περίπτωση οι συγκρούσεις σχετίζονται με τους λευκούς χαρακτήρες.
Το γνωρίζουμε αυτό διότι η περίπτωση είναι απλή αλλά είναι επίσης πολύ εύκολο να το καταλάβει κανείς και στην πραγματικότηατ όταν εξετάζουμε τη σύγκρουση επειδή κάθε γραμμή έχει αφαιρεθεί από το ένα αρχείο και έχει προστεθεί ξανά στο άλλο.
Εκ προεπιλογής, το Git βλέπει όλες αυτές τις γραμμές ως τροποποιημένες, οπότε δεν μπορεί να συγχωνεύσει τα αρχεία.</p>
</div>
<div class="paragraph">
<p>Η προεπιλεγμένη στρατηγική συγχώνευσης πάντως μπορεί να πάρει ορίσματα και μερικά από αυτά είναι για να αγνοούν σωστά τις αλλαγές στους λευκούς χαρακτήρες.
Αν δούμε ότι έχουμε πολλά προβλήματα με τους λευκούς χαρακτήρες σε μια συγχώνευση, μπορούμε απλά να την ακυρώσουμε και να την ξανακάνουμε, αυτήν τη φορά με το την επιλογή <code>-Xignore-all-space</code> ή την <code>-Xignore-space-change</code>.
Η πρώτη επιλογή αγνοεί <strong>εντελώς</strong> τους λευκούς χαρακτήρες κατά τη σύγκριση γραμμών, ενώ η δεύτερη αντιμετωπίζει τις αλληλουχίες ενός ή περισσότερων λευκών χαρακτήρων ως ισοδύναμες.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge -Xignore-space-change whitespace
Auto-merging hello.rb
Merge made by the 'recursive' strategy.
 hello.rb | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Δεδομένου ότι σε αυτήν την περίπτωση, οι πραγματικές αλλαγές του αρχείου δεν δημιουργούσαν συγκρούσεις, όταν αγνοήσουμε τις αλλαγές στους λευκούς χαρακτήρες, όλα πάνε μια χαρά.</p>
</div>
<div class="paragraph">
<p>Αυτό είναι σωτήριο εάν έχουμε κάποιον στην ομάδα μας που του αρέσει να επαναμορφοποιεί περιστασιακά τα πάντα από διαστήματα σε στηλοθέτες ή το αντίστροφο.</p>
</div>
</div>
<div class="sect4">
<h4 id="r_manual_remerge">Χειροκίνητη επανασυγχώνευση αρχείου</h4>
<div class="paragraph">
<p>Παρόλο που το Git επεξεργάζεται την προεπεξεργασία των λευκών χώρων αρκετά καλά, υπάρχουν και άλλα είδη αλλαγών που ίσως το Git δεν μπορεί να χειριστεί αυτόματα αλλά είναι αλλαγές που μπορούν να διορθωθούν με το κατάλληλο script.
Για παράδειγμα, ας υποθέσουμε ότι το Git δεν μπόρεσε να χειριστεί την αλλαγή του λευκού χαρακτήρα και έπρεπε να τη χειριστούμε χειροκίνητα.</p>
</div>
<div class="paragraph">
<p>Αυτό που πραγματικά πρέπει να κάνουμε είναι να περάσουμε το αρχείο που προσπαθούμε να συγχωνεύσουμε μέσα από το πρόγραμμα <code>dos2unix</code> προτού δοκιμάσουμε την πραγματική συγχώνευση αρχείων.
Πώς το κάνουμε αυτό;</p>
</div>
<div class="paragraph">
<p>Πρώτα, μπαίνουμε στην κατάσταση σύγκρουσης συγχώνευσης.
Στη συνέχεια, θέλουμε να λάβουμε αντίγραφα της δικής μας έκδοσης του αρχείου, της δικής τους (από τον κλάδο που συγχωνεύουμε) έκδοσης και της κοινής έκδοσης (από όπου και οι δύο πλευρές διακλαδίζονται).
Στη συνέχεια, θέλουμε να διορθώσουμε είτε την πλευρά τους είτε την πλευρά μας και να ξαναδοκιμάσουμε τη συγχώνευση και πάλι μόνο για αυτό το μοναδικό αρχείο.</p>
</div>
<div class="paragraph">
<p>Η λήψη των τριών εκδόσεων αρχείων είναι πραγματικά εύκολη.
Το Git αποθηκεύει όλες αυτές τις εκδόσεις στο ευρετήριο κάτω από τα <code>stages</code> τα οποία έχουν το καθένα από αυτά έναν συσχετισμένο αριθμό.
Το στάδιο 1 είναι ο κοινός πρόγονος, το στάδιο 2 είναι η δική μας έκδοση  και το στάδιο 3 είναι από το <code>MERGE_HEAD</code>, δηλαδή, την έκδοση που συγχωνεύουμε (<code>theirs</code>).</p>
</div>
<div class="paragraph">
<p>Μπορούμε να εξάγουμε ένα αντίγραφο από καθεμία από αυτές τις εκδόσεις του αρχείου που βρίσκεται σε σύγκρουση με την εντολή <code>git show</code> και μια ειδική σύνταξη.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git show :1:hello.rb &gt; hello.common.rb
$ git show :2:hello.rb &gt; hello.ours.rb
$ git show :3:hello.rb &gt; hello.theirs.rb</code></pre>
</div>
</div>
<div class="paragraph">
<p>Αν θέλουμε να το γίνουμε λίγο πιο σκληροπυρηνικοί, μπορούμε επίσης να χρησιμοποιήσουμε την εντολή <code>ls-files -u</code> για να λάβουμε τα πραγματικά SHA-1 των blob του Git blobs για καθένα από αυτά τα αρχεία.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git ls-files -u
100755 ac51efdc3df4f4fd328d1a02ad05331d8e2c9111 1	hello.rb
100755 36c06c8752c78d2aff89571132f3bf7841a7b5c3 2	hello.rb
100755 e85207e04dfdd5eb0a1e9febbc67fd837c44a1cd 3	hello.rb</code></pre>
</div>
</div>
<div class="paragraph">
<p>Το <code>:1:hello.rb</code> είναι απλά μια συντομογραφία για να αναζητήσει κανείς τον αριθμό SHA-1 εκείνου του blob.</p>
</div>
<div class="paragraph">
<p>Τώρα που έχουμε το περιεχόμενο και των τριών σταδίων στον κατάλογο εργασίας μας, μπορούμε να διορθώσουμε χειροκίνητα τη δική τους για να διορθώσουμε το πρόβλημα των λευκών διαστημάτων χώρου και να συγχωνεύσουμε ξανά το αρχείο με την ελάχιστα γνωστή εντολή <code>git merge-file</code> που κάνει ακριβώς αυτό.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ dos2unix hello.theirs.rb
dos2unix: converting file hello.theirs.rb to Unix format ...

$ git merge-file -p \
    hello.ours.rb hello.common.rb hello.theirs.rb &gt; hello.rb

$ git diff -b
diff --cc hello.rb
index 36c06c8,e85207e..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,8 -1,7 +1,8 @@@
  #! /usr/bin/env ruby

 +# εκτυπώνει έναν χαιρετισμό
  def hello
-   puts 'hello world'
+   puts 'hello mundo'
  end

  hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Σε αυτό το σημείο έχουμε συγχωνεύσει το αρχείο ωραιότατα.
Στην πραγματικότητα, αυτός ο τρόπος είναι καλύτερος από την επιλογή <code>ignore-space-change</code>, διότι επιδιορθώνει πραγματικά τις αλλαγές των λευκών διαστημάτω πριν από τη συγχώνευση αντί απλά να τις αγνοεί.
Στη συγχώνευση <code>ignore-space-change</code>, στην πραγματικότητα καταλήξαμε με μερικές γραμμές με τερματισμό γραμμής DOS και με μερικές γραμμές με τερματισμό γραμμής Unix, άρα μπερδέψαμε τα πράγματα.</p>
</div>
<div class="paragraph">
<p>Εάν θέλουμε να πάρουμε μια ιδέα πριν οριστικοποιήσουμε αυτήν την υποβολή για το τι πραγματικά άλλαξε μεταξύ της μιας ή της άλλης πλευράς, μπορούμε να ζητήσουμε από το <code>git diff</code> να συγκρίνουμε τι υπάρχει στον κατάλογο εργασίας που πρόκειται να υποβάλουμε ως αποτέλεσμα της συγχώνευσης σε οποιοδήποτε από αυτά τα στάδια.
Ας τα δούμε όλα.</p>
</div>
<div class="paragraph">
<p>Για να συγκρίνουμε το αποτέλεσμά μας με αυτό που είχαμε στον κλάδο μας πριν από τη συγχώνευση, με άλλα λόγια, για να δούμε τι εισήγαγε η συγχώνευση, μπορούμε να εκτελέσουμε την <code>git diff --ours</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff --ours
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index 36c06c8..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -2,7 +2,7 @@

 # εκτυπώνει έναν χαιρετισμό
 def hello
-  puts 'hello world'
+  puts 'hello mundo'
 end

 hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Είναι φανερό ότι αυτό που συνέβη στον κλάδο μας, αυτό που εισάγουμε στην πραγματικότητα σε αυτό το αρχείο με αυτήν τη συγχώνευση, αλλάζει μία και μόνο γραμμή.</p>
</div>
<div class="paragraph">
<p>Αν θέλουμε να δούμε πώς το αποτέλεσμα της συγχώνευσης διέφερε από αυτό που υπήρχε στη δική τους πλευρά, μπορούμε να εκτελέσουμε την <code>git diff --theirs</code>.
Σε αυτό και στο επόμενο παράδειγμα, πρέπει να χρησιμοποιήσουμε την επιλογή <code>-b</code> για να εξαλείψουμε τον λευκό χαρακτήρα επειδή το συγκρίνουμε με αυτό που υπάρχει στο Git, όχι το καθαρισμένο αρχείο μας <code>hello.theirs.rb</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff --theirs -b
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index e85207e..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,5 +1,6 @@
 #! /usr/bin/env ruby

+# εκτυπώνει έναν χαιρετισμό
 def hello
   puts 'hello mundo'
 end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Τέλος, βλέπουμε πώς το αρχείο έχει αλλάξει και από τις δύο πλευρές με το <code>git diff --base</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff --base -b
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index ac51efd..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,7 +1,8 @@
 #! /usr/bin/env ruby

+# εκτυπώνει έναν χαιρετισμό
 def hello
-  puts 'hello world'
+  puts 'hello mundo'
 end

 hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Σε αυτό το σημείο μπορούμε να χρησιμοποιήσουμε την εντολή <code>git clean</code> για να διαγράψουμε τα επιπλέον αρχεία που δημιουργήσαμε ώστε να κάνουμε τη χειροκίνητη συγχώνευση αλλά δεν χρειαζόμαστε πλέον.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clean -f
Removing hello.common.rb
Removing hello.ours.rb
Removing hello.theirs.rb</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h4 id="r_checking_out_conflicts">Checking Out Conflicts</h4>
<div class="paragraph">
<p>Ίσως δεν είμαστε ευχαριστημένοι με την επίλυση σε αυτό το σημείο για κάποιο λόγο, ή ίσως η χειροκίνητη επεξεργασία μιας ή και των δύο πλευρών ακόμα δεν λειτούργησε καλά και χρειαζόμαστε περισσότερο περιβάλλον.</p>
</div>
<div class="paragraph">
<p>Ας δούμε ένα λίγο διαφορετικό παράδειγμα.
Για αυτό το παράδειγμα, έχουμε δύο μακροβιότερους κλάδους, ο καθένας από τους οποίους έχει μερικές υποβολές, αλλά όταν συγχωνεύονται δημιουργείται σύγκρουση περιεχομένου.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --graph --oneline --decorate --all
* f1270f7 (HEAD, master) update README
* 9af9d3b add a README
* 694971d update phrase to hola world
| * e3eb223 (mundo) add more tests
| * 7cff591 add testing script
| * c3ffff1 changed text to hello mundo
|/
* b7dcc89 initial hello world code</code></pre>
</div>
</div>
<div class="paragraph">
<p>Τώρα έχουμε τρεις μοναδικές υποβολές που ζουν μόνο στον κλάδο <code>master</code> και τρεις άλλες που ζουν στον κλάδο <code>mundo</code>.
Αν προσπαθήσουμε να συγχωνεύσουμε τον κλάδο <code>mundo</code>, παίρνουμε σύγκρουση.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge mundo
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Automatic merge failed; fix conflicts and then commit the result.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Θα θέλαμε να δούμε τι είναι αυτή η σύγκρουση.
Αν ανοίξουμε το αρχείο, θα δούμε κάτι τέτοιο:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">#! /usr/bin/env ruby

def hello
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
  puts 'hola world'
=======
  puts 'hello mundo'
&gt;&gt;&gt;&gt;&gt;&gt;&gt; mundo
end

hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Και οι δύο πλευρές της συγχώνευσης πρόσθεσαν περιεχόμενο σε αυτό το αρχείο, αλλά μερικές από τις υποβολές τροποποίησαν το αρχείο στον ίδιο σημείο και αυτό προκάλεσε τη σύγκρουση.</p>
</div>
<div class="paragraph">
<p>Ας εξερευνήσουμε μερικά εργαλεία που έχουμε πλέον στη διάθεσή μας για να καθορίσουμε πώς προέκυψε αυτή η σύγκρουση.
Ίσως δεν είναι προφανές πώς ακριβώς πρέπει να διορθώσουμε αυτήν τη σύγκρουση.
Χρειαζόμαστε περισσότερες πληροφορίες για το πλαίσιο της σύγκρουσης.</p>
</div>
<div class="paragraph">
<p>Ένα χρήσιμο εργαλείο είναι η εντολή <code>git checkout</code> με την επιλογή <code>--conflict</code>.
Αυτή η εντολή θα ξανά-μεταβεί στο αρχείο και θα αντικαταστήσει τις επισημάνσεις σύγκρουσης.
Αυτό είναι χρήσιμο αν θέλουμε να αλλάξουμε τη μορφή των επισημάνσεων και να ξαναπροσπαθήσουμε να επιλύσουμε τις συγκρούσεις.</p>
</div>
<div class="paragraph">
<p>Μπορούμε να περάσουμε στην επιλογή <code>--conflict</code> είτε την τιμή <code>diff3</code> είτε την <code>merge</code> (που είναι η προεπιλογή).
Εάν της περάσουμε την <code>diff3</code>, το Git θα χρησιμοποιήσει μια ελαφρώς διαφορετική έκδοση των επισημάνσεων σύγκρουσης, όχι μόνο να μας δώσει τις εκδόσεις <code>ours</code> και <code>theirs</code> αλλά και την έκδοση <code>base</code> για να πάρουμε περισσότερες πληροφορίες για το πλαίσιο της σύγκρουσης.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout --conflict=diff3 hello.rb</code></pre>
</div>
</div>
<div class="paragraph">
<p>Μόλις το τρέξουμε, το αρχείο θα μοιάζει με αυτό:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">#! /usr/bin/env ruby

def hello
&lt;&lt;&lt;&lt;&lt;&lt;&lt; ours
  puts 'hola world'
||||||| base
  puts 'hello world'
=======
  puts 'hello mundo'
&gt;&gt;&gt;&gt;&gt;&gt;&gt; theirs
end

hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Εάν μας αρέσει αυτή η μορφή, μπορούμε να την ορίσουμε ως προεπιλογή για μελλοντικές συγκρούσεις συγχώνευσης, θέτοντας την τιμή της <code>merge.conflictstyle</code> σε <code>diff3</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global merge.conflictstyle diff3</code></pre>
</div>
</div>
<div class="paragraph">
<p>Η εντολή <code>git checkout</code> μπορεί επίσης να πάρει τις επιλογές <code>--ours</code> και ‘--their’, οι οποίες μπορεί να είναι ένας πολύ γρήγορος τρόπος για να επιλέξουμε απλά τη μια πλευρά ή την άλλη χωρίς να συγχωνεύσουμε τίποτα.</p>
</div>
<div class="paragraph">
<p>Αυτό μπορεί να είναι ιδιαίτερα χρήσιμο για συγκρούσεις δυαδικών αρχείων, όπου μπορούμε απλά να επιλέξουμε τη μία πλευρά ή στις οποίες θέλουμε να συγχωνεύσουμε μόνο ορισμένα αρχεία από κάποιον άλλον κλάδο —μπορούμε να κάνουμε τη συγχώνευση και στη συνέχεια να ενημερώσουμε (checkout) ορισμένα αρχεία από τη μια ή την άλλη πλευρά πριν από την υποβολή.</p>
</div>
</div>
<div class="sect4">
<h4 id="r_merge_log">Συγχώνευση μητρώου</h4>
<div class="paragraph">
<p>Ένα άλλο χρήσιμο εργαλείο κατά την επίλυση συγχωνεύσεων συγχώνευσης είναι το <code>git log</code>.
Αυτό μπορεί να μας βοηθήσει να αποκτήσουμε πληροφορίες σχετικά με το τι μπορεί να συνέβαλε στις συγκρούσεις.
Η επισκόπηση μικρού μέρους του ιστορικού για να θυμηθούμε γιατί δύο γραμμές ανάπτυξης επηρέασαν την ίδια περιοχή του κώδικα μπορεί να είναι πραγματικά χρήσιμη μερικές φορές.</p>
</div>
<div class="paragraph">
<p>Για να πάρουμε μια πλήρη λίστα με όλες τις μοναδικές υποβολές που συμπεριλήφθησαν σε οποιονδήποτε κλάδο που συμμετέχει σε αυτήν τη συγχώνευση, μπορούμε να χρησιμοποιήσουμε τη σύνταξη “τριπλής τελείας” που είδαμε στην ενότητα <a href="ch00/r_triple_dot">Τριπλή τελεία</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --oneline --left-right HEAD...MERGE_HEAD
&lt; f1270f7 update README
&lt; 9af9d3b add a README
&lt; 694971d update phrase to hola world
&gt; e3eb223 add more tests
&gt; 7cff591 add testing script
&gt; c3ffff1 changed text to hello mundo</code></pre>
</div>
</div>
<div class="paragraph">
<p>Αυτή είναι μια ωραιότατη λίστα των έξι συνολικά υποβολών που εμπλέκονται, καθώς και σε ποια γραμμή ανάπτυξης έγινε η κάθε υποβολή.</p>
</div>
<div class="paragraph">
<p>Μπορούμε να απλουστεύσουμε περαιτέρω αυτήν τη λίστα για να πάρουμε ακόμα πιο συγκεκριμένες πληροφορίες για το πλαίσιο της σύγκρουσης.
Αν προσθέσουμε την επιλογή <code>--merge</code> στην <code>git log</code>, θα εμφανιστούν μόνο οι υποβολές σε κάθε πλευρά της συγχώνευσης που ακούμπησαν ένα αρχείο που βρίσκεται σε σύγκρουση.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --oneline --left-right --merge
&lt; 694971d update phrase to hola world
&gt; c3ffff1 changed text to hello mundo</code></pre>
</div>
</div>
<div class="paragraph">
<p>Αντίθετα αν την τρέξουμε με την επιλογή <code>-p</code>, θα πάρουμε μόνον αντί να πάρουμε μόνο τα diff του αρχείου που κατέληξε σε σύγκρουση.
Αυτό μπορεί να είναι <strong>πραγματικά</strong> χρήσιμο για να μας δώσει γρήγορα το πλαίσιο που χρειαζόμαστε για να καταλάβουμε γιατί κάτι συγκρούεται και πώς να επιλύσουμε πιο έξυπνα τη σύγκρουση.</p>
</div>
</div>
<div class="sect4">
<h4 id="_μορφή_συνδυασμένου_diff">Μορφή συνδυασμένου diff</h4>
<div class="paragraph">
<p>Εφόσον το Git βάζει στο στάδιο καταχώρισης όλα τα επιτυχημένα αποτελέσματα συγχώνευσης, όταν εκτελούμε την <code>git diff</code>, ενώ βρισκόμαστε σε κατάσταση σύγκρουσης συγχώνευσης, παίρνουμε μόνο ό,τι είναι ακόμα σε σύγκρουση.
Αυτό μπορεί να μας βοηθήσει να δούμε τι πρέπει ακόμα να επιλύσουμε.</p>
</div>
<div class="paragraph">
<p>Όταν τρέχουμε την <code>git diff</code> αμέσως μετά από μια σύγκρουση συγχώνευσης, θα μας δώσει πληροφορίες σε μια μοναδική μορφή εξόδου της diff.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff
diff --cc hello.rb
index 0399cd5,59727f0..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,11 @@@
  #! /usr/bin/env ruby

  def hello
++&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
 +  puts 'hola world'
++=======
+   puts 'hello mundo'
++&gt;&gt;&gt;&gt;&gt;&gt;&gt; mundo
  end

  hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Η μορφή αυτή ονομάζεται “Συνδυασμένη diff” και μας δίνει δύο στήλες δεδομένων δίπλα σε κάθε γραμμή. Η πρώτη γραμμή μας δείχνει αν αυτή η γραμμή διαφέρει (προστέθηκε ή αφαιρέθηκε) ανάμεσα στον κλάδο <code>ours</code> και το αρχείο στον κατάλογο εργασίας μας και η δεύτερη στήλη κάνει το ίδιο αλλά ανάμεσα στον κλάδο <code>theirs</code> και τον κατάλογο εργασίας μας.</p>
</div>
<div class="paragraph">
<p>Έτσι σε αυτό το παράδειγμα μπορούμε να δούμε ότι οι γραμμές <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> και <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> βρίσκονται στο αντίγραφο εργασίας αλλά δεν βρίσκονται σε καμία πλευρά της συγχώνευσης.
Αυτό έχει νόημα επειδή το εργαλείο συγχώνευσης τις βάλει εκεί δεδομένου του συγκεκριμένου πλαισίου της σύγκρουσης, αλλά αναμένει από μας τα τις αφαιρέσουμε.</p>
</div>
<div class="paragraph">
<p>Αν επιλύσουμε τη σύγκρουση και τρέξουμε ξανά την <code>git diff</code>, θα δούμε το ίδιο πράγμα αλλά είναι λίγο πιο χρήσιμο.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ vim hello.rb
$ git diff
diff --cc hello.rb
index 0399cd5,59727f0..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
  #! /usr/bin/env ruby

  def hello
-   puts 'hola world'
 -  puts 'hello mundo'
++  puts 'hola mundo'
  end

  hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Αυτό μας δείχνει ότι το <code>hola world</code> βρισκόταν στην πλευρά <em>μας</em> αλλά όχι στο αντίγραφο εργασίας, ότι το <code>hello mundo</code> ήταν στο πλευρό <em>τους</em> αλλά όχι στο αντίγραφο εργασίας και τέλος ότι το <code>hola mundo</code> δεν ήταν σε καμία πλευρά, αλλά τώρα βρίσκεται στο αντίγραφο εργασίας.
Αυτό μπορεί να είναι χρήσιμο για μία επισκόπηση πριν την υποβολή της επίλυσης.</p>
</div>
<div class="paragraph">
<p>Μπορούμε επίσης να πάρουμε αυτό από την <code>git log</code> για οποιαδήποτε συγχώνευση μετά τη συγχώνευση για να δούμε πώς κάτι επιλύθηκε.
Το Git θα εκτυπώσει σε αυτήν τη μορφή αν εκτελέσουμε την <code>git show</code> σε μια υποβολή συγχώνευσης ή εάν προσθέσουμε την επιλογή <code>--cc 'σε μία `git log -p</code> (η οποία εκ προεπιλογής εμφανίζει μόνο επιθέματα για υποβολές που δεν είναι συγχωνεύσεις).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --cc -p -1
commit 14f41939956d80b9e17bb8721354c33f8d5b5a79
Merge: f1270f7 e3eb223
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri Sep 19 18:14:49 2014 +0200

    Merge branch 'mundo'

    Conflicts:
        hello.rb

diff --cc hello.rb
index 0399cd5,59727f0..e1d0799
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
  #! /usr/bin/env ruby

  def hello
-   puts 'hola world'
 -  puts 'hello mundo'
++  puts 'hola mundo'
  end

  hello()</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h3 id="r_undoing_merges">Αναίρεση συγχώνευσης</h3>
<div class="paragraph">
<p>Τώρα που ξέρουμε πώς να δημιουργήσουμε υποβολές συγχώνευσης, θα κάνουμε πιθανώς κάποια κατά λάθος.
Ένα από τα σπουδαία πράγματα της εργασίας στο Git είναι ότι δεν πειράζει αν κάνουμε λάθη, επειδή είναι δυνατό (και σε πολλές περιπτώσεις εύκολο) να τα διορθώσουμε.</p>
</div>
<div class="paragraph">
<p>Οι υποβολές συγχώνευσης δεν διαφέρουν.
Ας υποθέσουμε ότι ξεκινήσαμε να εργαζόμαστε σε έναν θεματικό κλάδο, τον συγχωνεύσαμε τον κατά λάθος στον <code>master</code> και τώρα το ιστορικό των υποβολών μας μοιάζει με αυτό:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{ "book/en/v2/images/undomerge-start.png" | relative_url }}" alt="Ακούσια υποβολή συγχώνευσης.">
</div>
<div class="title">Figure 138. ακούσια υποβολή συγχώνευσης</div>
</div>
<div class="paragraph">
<p>Υπάρχουν δύο τρόποι προσέγγισης αυτού του προβλήματος, ανάλογα με το ποιο επιθυμούμε να είναι το αποτέλεσμα.</p>
</div>
<div class="sect4">
<h4 id="_fix_the_references">Fix the references</h4>
<div class="paragraph">
<p>Εάν η ανεπιθύμητη υποβολή συγχώνευσης υπάρχει μόνο στο τοπικό αποθετήριο, η ευκολότερη και καλύτερη λύση είναι να μετακινήσουμε τους κλάδους ώστε να δείχνουν εκεί όπου θέλουμε.
Στις περισσότερες περιπτώσεις, αν μετά από μία <code>git merge</code> εκτελέσουμε την <code>git reset --hard HEAD~</code>, αυτό θα επαναφέρει τους δείκτες κλάδων, οπότε θα μοιάζουν με αυτό:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{ "book/en/v2/images/undomerge-reset.png" | relative_url }}" alt="Το ιστορικό μετά την `git reset --hard HEAD~`.">
</div>
<div class="title">Figure 139. Το ιστορικό μετά την <code>git reset --hard HEAD~</code>.</div>
</div>
<div class="paragraph">
<p>Καλύψαμε την <code>reset</code> στην ενότητα <a href="ch00/r_git_reset">Απομυθοποίηση της <code>reset</code></a>, επομένως δεν πρέπει να είναι πολύ δύσκολο να καταλάβουμε τι συμβαίνει εδώ.
Ορίστε μία γρήγορη υπενθύμιση: η <code>reset --hard</code> συνήθως περνάει από τρία βήματα:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Μετακινούμε τον κλάδο στον οποίο δείχνει τον HEAD. Σε αυτήν την περίπτωση, θέλουμε να μετακινήσουμε τον <code>master</code> εκεί όπου βρισκόταν πριν την υποβολή συγχώνευσης (<code>C6</code>).</p>
</li>
<li>
<p>Κάνουμε το ευρετήριο να μοιάζει με τον HEAD.</p>
</li>
<li>
<p>Κάνουμε τον κατάλογο εργασίας να μοιάζει με το ευρετήριο.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Το μειονέκτημα αυτής της προσέγγισης είναι ότι πρόκειται για επανεγγραφή του ιστορικού, το οποίο μπορεί να είναι προβληματικό με ένα κοινό αποθετήριο.
Στην ενότητα <a href="ch00/r_rebase_peril">Οι κίνδυνοι της αλλαγής βάσης</a> υπάρχουν περισσότερα σχετικά με το τι μπορεί να συμβεί· με λίγα λόγια αυτό αν κάποιος άλλος έχει τις υποβολές που αλλάζουμε, θα πρέπει μάλλον να αποφύγουμε την <code>reset</code>.
Αυτή η προσέγγιση επίσης δεν θα λειτουργήσει εάν έχουν γίνει άλλες υποβολές μετά από τη συγχώνευση· η μετακίνηση των refs ουσιαστικά θα χάσει αυτές τις αλλαγές.</p>
</div>
</div>
<div class="sect4">
<h4 id="r_reverse_commit">Eπαναφορά της υποβολής</h4>
<div class="paragraph">
<p>Εάν η μετακίνηση των δεικτών των κλάδων από δω κι από κει δεν μας βοηθά, το Git μάς δίνει τη δυνατότητα να κάνουμε μια νέα υποβολή, η οποία ακυρώνει όλες τις αλλαγές από μία υπάρχουσα.
Το Git ονομάζει αυτήν τη λειτουργία <code>revert</code> (“επαναφορά”) και σε αυτό το συγκεκριμένο σενάριο, θα τη χρησιμοποιήσουμε ως εξής:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git revert -m 1 HEAD
[master b1d8379] Revert "Merge branch 'topic'"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Η επισήμανση <code>-m 1</code> υποδεικνύει ποιος γονέας είναι η “κύρια γραμμή” και θα πρέπει να διατηρηθεί.
Όταν ξεκινάμε μια συγχώνευση στον <code>HEAD</code> (<code>git merge topic'), η νέα υποβολή έχει δύο γονείς: ο πρώτος είναι ο `HEAD</code> (<code>C6</code>) και ο δεύτερος είναι η κορυφή του κλάδου που συγχωνεύεται <code>C4</code>).
Σε αυτήν την περίπτωση, θέλουμε να αναιρέσουμε όλες τις αλλαγές που εισήχθησαν με τη συγχώνευση του γονέα #2 (<code>C4</code>), διατηρώντας όλο το περιεχόμενο από τον γονέα #1 (<code>C6</code>).</p>
</div>
<div class="paragraph">
<p>Το ιστορικό μετά την επαναφορά της υποβολής μοιάζει ως εξής:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{ "book/en/v2/images/undomerge-revert.png" | relative_url }}" alt="Ιστορικό μετά την  `git revert -m 1`.">
</div>
<div class="title">Figure 140. ιστορικό μετά την <code>git revert -m 1</code>
</div>
</div>
<div class="paragraph">
<p>Η νέα υποβολή <code>^M</code> έχει ακριβώς το ίδιο περιεχόμενο με την <code>C6</code>, οπότε ξεκινώντας από εδώ είναι σαν να μην συνέβη ποτέ η συγχώνευση, εκτός από το γεγονός ότι οι υποβολές που τώρα δεν έχουν μεσολαβήσει εξακολουθούν να βρίσκονται στο ιστορικό του <code>HEAD</code>.
Το Git θα μπερδευτεί αν προσπαθήσουμε να συγχωνεύσουμε ξανά τον <code>topic</code> στον <code>master</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge topic
Already up-to-date.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Δεν υπάρχει τίποτα στο <code>topic</code> που δεν είναι ήδη προσπελάσιμο από τον <code>master</code>.
Ακόμα χειρότερα, αν προσθέσουμε εργασία στον <code>topic</code> και συγχωνεύσουμε ξανά, το Git θα φέρει μόνο τις αλλαγές που έγιναν <em>από την αναστροφή και μετά</em>:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{ "book/en/v2/images/undomerge-revert2.png" | relative_url }}" alt="Ιστορικό με κακή συγχώνευση.">
</div>
<div class="title">Figure 141. ιστορικό με κακή συγχώνευση</div>
</div>
<div class="paragraph">
<p>Ο καλύτερος τρόπος να λύσουμε αυτό το πρόβλημα είναι να ξε-επαναφέρουμε την αρχική συγχώνευση, αφού τώρα θέλουμε να ξαναφέρουμε τις αλλαγές που είχαν επαναφερθεί, <strong>και μετά</strong> να κάνουμε μια νέα υποβολή συγχώνευσης:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git revert ^M
[master 09f0126] Revert "Revert "Merge branch 'topic'""
$ git merge topic</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="{{ "book/en/v2/images/undomerge-revert3.png" | relative_url }}" alt="στορικό μετά την επανασυγχώνευση μίας συγχώνευσης που είχε επαναφερθεί.">
</div>
<div class="title">Figure 142. ιστορικό μετά την επανασυγχώνευση μίας συγχώνευσης που είχε επαναφερθεί</div>
</div>
<div class="paragraph">
<p>Σε αυτό το παράδειγμα, οι <code>M</code> και <code>^M</code> αλληλοεξουδετερώνονται.
Η <code>^^M</code> ουσιαστικά συγχωνεύει τις αλλαγές από <code>C3</code> και <code>C4</code>, και η <code>C8</code> συγχωνεύει τις αλλαγές από την <code>C7</code>, έτσι τώρα ο <code>topic</code> συγχωνεύεται πλήρως.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_άλλα_είδη_συγχωνεύσεων">Άλλα είδη συγχωνεύσεων</h3>
<div class="paragraph">
<p>Μέχρι στιγμής καλύψαμε τη συνηθισμένη συγχώνευση δύο κλάδων, τα οποία φυσιολογικά αντιμετωπίζεται με τη λεγόμενη “αναδρομική” στρατηγική συγχώνευσης.
Υπάρχουν κι άλλοι τρόποι συγχώνευσης των κλάδων.
Ας δούμε μερικούς από αυτούς συνοπτικά.</p>
</div>
<div class="sect4">
<h4 id="_προτίμηση_δική_μας_ή_δική_τους">Προτίμηση “δική μας” ή “δική τους”</h4>
<div class="paragraph">
<p>Πρώτα απ 'όλα, υπάρχει ένα άλλο χρήσιμο πράγμα που μπορούμε να κάνουμε με τον συνήθη “αναδρομικό” τρόπο συγχώνευσης.
Έχουμε ήδη δει τις επιλογές <code>ignore-all-space</code> και 'ignore-space-change` που έχουν περάσει με την επιλογή <code>-X</code>, αλλά μπορούμε επίσης να πούμε στο Git να ευνοεί τη μία ή την άλλη πλευρά όταν βλέπει μια σύγκρουση.</p>
</div>
<div class="paragraph">
<p>Εκ προεπιλογής, όταν το Git βλέπει μια σύγκρουση μεταξύ δύο κλάδων, που συγχωνεύονται, θα προσθέσει επισημάνσεις σύγκρουσης συγχώνευσης στον κώδικά μας, θα επισημάνει το αρχείο ως συγκρουόμενο και θα αφήσει εμάς να επιλύσουμε τη σύγκρουση.
Εάν προτιμάμε το Git να επιλέξει απλά μια συγκεκριμένη πλευρά και να αγνοήσει την άλλη πλευρά αντί να αφήνει εμάς να συγχωνεύσουμε με χειροκίνητα τη σύγκρουση, μπορούμε να περάσουμε στην εντολή <code>merge</code> είτε ένα <code>-Xours</code> είτε ένα <code>-Xtheirs</code>.</p>
</div>
<div class="paragraph">
<p>Εάν το Git δει μία από αυτές τις επιλογές, δεν θα προσθέσει δείκτες σύγκρουσης.
Τυχόν διαφορές που μπορούν να συγχωνευθούν, θα συγχωνευθούν.
Οποιεσδήποτε διαφορές που συγκρούονται, απλά θα επιλέξει αποκλειστικά την πλευρά που καθορίζουμε και αυτό ισχύει και για δυαδικά αρχεία.</p>
</div>
<div class="paragraph">
<p>Επιστρέφουμε στο παράδειγμα <code>hello world</code> που χρησιμοποιήσαμε πριν και βλέπουμε ότι η συγχώνευση στον κλάδο μας προκαλεί συγκρούσεις.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge mundo
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Resolved 'hello.rb' using previous resolution.
Automatic merge failed; fix conflicts and then commit the result.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ωστόσο, αν την τρέξουμε με <code>-Xours</code> ή <code>-XTheirs</code> δεν προκαλεί συγκρούσεις.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge -Xours mundo
Auto-merging hello.rb
Merge made by the 'recursive' strategy.
 hello.rb | 2 +-
 test.sh  | 2 ++
 2 files changed, 3 insertions(+), 1 deletion(-)
 create mode 100644 test.sh</code></pre>
</div>
</div>
<div class="paragraph">
<p>Σε αυτήν την περίπτωση, αντί να πάρουμε επισημάνσεις σύγκρουσης στο αρχείο με <code>hello mundo</code> στη μία πλευρά και <code>hola world</code> από την άλλη, θα επιλέξει απλά <code>hola world</code>.
Ωστόσο, όλες οι άλλες αλλαγές, που δεν δημιουργούν συγκρούσεις, σε αυτόν τον κλάδο συγχωνεύονται με επιτυχία.</p>
</div>
<div class="paragraph">
<p>Αυτή η επιλογή μπορεί επίσης να μεταβιβαστεί στην εντολή <code>git merge-file</code> που είδαμε νωρίτερα τρέχοντας κάτι σαν το <code>git merge-file --ours</code> για συγχωνεύσεις μεμονωμένων αρχείων.</p>
</div>
<div class="paragraph">
<p>Εάν θέλουμε να κάνουμε κάτι τέτοιο αλλά δεν έχουμε προσπαθήσει να συγχωνεύσουμε τις αλλαγές από την άλλη πλευρά, υπάρχει μια πιο δρακόντεια επιλογή, η οποία είναι η <em>στρατηγική</em> συγχώνευσης <code>ours</code>.
Αυτή είναι διαφορετική από την <em>επιλογή</em> αναδρομικής συγχώνευσης  <code>ours</code>.</p>
</div>
<div class="paragraph">
<p>Αυτό θα κάνει βασικά μια ψεύτικη συγχώνευση.
Θα καταγράψει μια νέα υποβολή συγχώνευσης με τους δύο κλάδους ως γονείς, αλλά δεν θα εξετάσει καν τον κλάδο τον οποίο συγχωνευουμε.
Θα καταγράψει απλώς ως αποτέλεσμα της συγχώνευσης τον ακριβή κώδικα στον τρέχοντα κλάδο μας.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge -s ours mundo
Merge made by the 'ours' strategy.
$ git diff HEAD HEAD~
$</code></pre>
</div>
</div>
<div class="paragraph">
<p>Μπορούμε να δούμε ότι δεν υπάρχει διαφορά μεταξύ του κλάδου στον οποίο βρισκόμασταν και του αποτελέσματος της συγχώνευσης.</p>
</div>
<div class="paragraph">
<p>Αυτό μπορεί συχνά να είναι χρήσιμο στο να ξεγελάσει το Git ώστε να νομίζει ότι ένας κλάδος είναι ήδη συγχωνευμένος όταν κάνει μία συγχώνευση αργότερα.
Για παράδειγμα, ας πούμε ότι διακλαδώσαμε από έναν κλάδο <code>release</code>, κάναμε κάποια εργασία σε αυτόν την οποία θα θελήσουμε να συγχωνεύσουμε ξανά τον κλάδο <code>master</code> σε κάποια στιγμή.
Εν τω μεταξύ, η διόρθωση ενός bug, <code>bugfix</code> στον <code>master</code> πρέπει να μεταφερθεί  στον κλάδο <code>release</code>.
Μπορούμε να συγχωνεύσουμε τον κλάδο <code>bugfix</code> στον κλάδο <code>release</code> και επίσης να τρέξουμε <code>merge -s ours</code> για να συγχωνεύσουμε τον ίδιο κλάδο στον <code>master</code> (παρά το ότι η διόρθωση του bug υπάρχει ήδη εκεί) έτσι ώστε όταν συγχωνεύσουμε ξανά τον κλάδο <code>release</code> να μην υπάρχουν συγκρούσεις από τη διόρθωση σφαλμάτων.</p>
</div>
</div>
<div class="sect4">
<h4 id="r_subtree_merge">Συγχώνευση υποδένδρων</h4>
<div class="paragraph">
<p>Η ιδέα της συγχώνευσης κλάδων είναι ότι έχουμε δύο έργα και ένα από τα έργα απεικονίζεται σε έναν υποκατάλογο του άλλου και τούμπαλιν.
Όταν καθορίζουμε μια συγχώνευση υποδένδρων, το Git είναι συχνά αρκετά έξυπνο για να καταλάβει ότι το ένα είναι ένα υποδένδρο του άλλου και τα συγχωνεύει κατάλληλα.</p>
</div>
<div class="paragraph">
<p>Θα δούμε ένα παράδειγμα προσθήκης ενός ξεχωριστού έργου σε ένα υπάρχον και στη συνέχεια τη συγχώνευση του κώδικα του δεύτερου σε έναν υποκατάλογο του πρώτου.</p>
</div>
<div class="paragraph">
<p>Αρχικά, θα προσθέσουμε την εφαρμογή Rack στο έργο μας· Θα προσθέσουμε το έργο Rack ως απομακρυσμένη αναφορά στο δικό μας έργο και στη συνέχεια θα δημιουργήσουμε έναν κλάδο για αυτό και θα μεταβούμε σε αυτόν:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git remote add rack_remote https://github.com/rack/rack
$ git fetch rack_remote
warning: no common commits
remote: Counting objects: 3184, done.
remote: Compressing objects: 100% (1465/1465), done.
remote: Total 3184 (delta 1952), reused 2770 (delta 1675)
Receiving objects: 100% (3184/3184), 677.42 KiB | 4 KiB/s, done.
Resolving deltas: 100% (1952/1952), done.
From https://github.com/rack/rack
 * [new branch]      build      -&gt; rack_remote/build
 * [new branch]      master     -&gt; rack_remote/master
 * [new branch]      rack-0.4   -&gt; rack_remote/rack-0.4
 * [new branch]      rack-0.9   -&gt; rack_remote/rack-0.9
$ git checkout -b rack_branch rack_remote/master
Branch rack_branch set up to track remote branch refs/remotes/rack_remote/master.
Switched to a new branch "rack_branch"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Τώρα έχουμε τη ρίζα του έργου Rack στον κλάδο <code>rack_branch</code> και το δικό μας έργο στον κλάδο <code>master</code>. Εάν τα κάνουμε μεταβούμε από το ένα στο άλλο, θα δούμε ότι το κάθε έργο περιέχουν διαφορετικά αρχεία:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ ls
AUTHORS         KNOWN-ISSUES   Rakefile      contrib         lib
COPYING         README         bin           example         test
$ git checkout master
Switched to branch "master"
$ ls
README</code></pre>
</div>
</div>
<div class="paragraph">
<p>Αυτή είναι μια κάπως παράξενη σύλληψη.
Δεν είναι απαραίτητο όλοι οι κλάδοι του αποθετηρίου μας να είναι υποχρεωτικά κλάδοι του ίδιου έργου.
Δεν είναι συνηθισμένο, διότι είναι σπάνια χρήσιμο, αλλά είναι αρκετά εύκολο να έχουμε κλάδους που περιέχουν εντελώς διαφορετικές ιστορικά.</p>
</div>
<div class="paragraph">
<p>Σε αυτήν την περίπτωση, θέλουμε να έλξουμε το έργο Rack στο έργο του κλάδου <code>master</code> ως υποκατάλογο.
Αυτό μπορούμε να το κάνουμε στο Git με την εντολή <code>git read-tree</code>. Θα μάθουμε περισσότερα σχετικά με την <code>read-tree</code> και τους φίλους της στην ενότητα <a href="ch00/ch10-git-internals">[ch10-git-internals]</a>, αλλά προς το παρόν αρκεί να γνωρίζουμε ότι διαβάζει το ριζικό δέντρο ενός κλάδου στον τρέχον στάδιο καταχώρισης και τον κατάλογο εργασίας.
Επιστρέφουμε τώρα στον κύριο κλάδο μας και έλκουμε τον κλάδο <code>rack_branch</code> στον υποκατάλογο <code>rack</code> του κύριου κλάδου <code>master</code> του κύριου έργου μας:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git read-tree --prefix=rack/ -u rack_branch</code></pre>
</div>
</div>
<div class="paragraph">
<p>Όταν υποβάλουμε, φαίνεται ότι έχουμε όλα τα αρχεία του Rack κάτω από αυτόν τον υποκατάλογο —σαν να τα αντιγράψαμε από ένα tarball.
Αυτό που είναι πραγματικά ενδιαφέρον είναι ότι μπορούμε να συγχωνεύσουμε αρκετά εύκολα τις αλλαγές από τον έναν κλάδο στον άλλο.
Επομένως, εάν το έργο Rack ενημερωθεί, μπορούμε να τραβήξουμε τις αλλαγές upstream μεταβαίνοντας σε εκείνο τον κλάδο και έλκοντας:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout rack_branch
$ git pull</code></pre>
</div>
</div>
<div class="paragraph">
<p>Στη συνέχεια, μπορούμε να συγχωνεύσουμε αυτές τις αλλαγές πίσω στον κλάδο <code>master</code>. Για να έλξουμε τις αλλαγές και να προεπικαλύψουμε το μήνυμα commit, χρησιμοποιούμε την επιλογή <code>--squash</code>, καθώς και την επιλογή <code>-Xsubtree</code> της στρατηγικής αναδρομικής συγχώνευσης.
(Η αναδρομική στρατηγική είναι η προεπιλογή εδώ, αλλά τη συμπεριλαμβάνουμε για λόγους σαφήνειας.)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout master
$ git merge --squash -s recursive -Xsubtree=rack rack_branch
Squash commit -- not updating HEAD
Automatic merge went well; stopped before committing as requested</code></pre>
</div>
</div>
<div class="paragraph">
<p>Όλες οι αλλαγές από το έργο Rack έχουν συγχωνευτεί και είναι έτοιμες να υποβληθούν τοπικά.
Μπορούμε επίσης να κάνουμε το αντίθετο —να κάνουμε αλλαγές στον υποκατάλογο rack του κύριου κλάδου μας και στη συνέχεια να τις συγχωνεύσουμε στον κλάδο <code>rack_branch</code> αργότερα για να τις υποβάλουμε στους διαχειριστές ή να τις ωθήσουμε προς τα πάνω.</p>
</div>
<div class="paragraph">
<p>Αυτό μας δίνει έναν τρόπο να έχουμε μια ροή εργασίας κάπως παρόμοια με τη ροή εργασίας των λειτουργικών υπομονάδων χωρίς να χρησιμοποιούμε υπομονάδες (που θα καλύψουμε στην ενότητα [_git_submodules]).
Μπορούμε να διατηρούμε κλάδους με άλλα σχετικά έργα στο αποθετήριό μας και να τα συγχωνεύουμε στο έργο μας περιστασιακά.
Είναι ωραίο κατά κάποιους τρόπους· για παράδειγμα όλος ο κώδικας υποβάλλεται σε ένα μόνο μέρος.
Ωστόσο, έχει άλλα μειονεκτήματα: είναι λίγο πιο περίπλοκο και είναι πιο εύκολο να κάνουμε κάποιο λάθος στην επανένταξη των αλλαγών ή να ωθήσουμε κατά λάθος έναν κλάδο σε ένα άσχετο αποθετήριο.</p>
</div>
<div class="paragraph">
<p>Κάτι ακόμα ελαφρώς περίεργο είναι ότι για να πάρουμε μια diff ανάμεσα σε αυτό που έχουμε στον υποκατάλογό μας <code>rack</code> και τον κώδικα στον κλάδο <code>rack_branch</code> —για να δούμε αν πρέπει να τα συγχωνεύσουμε— δεν μπορούμε να χρησιμοποιήσουμε την κανονική εντολή <code>diff</code>. Αντ' αυτού, πρέπει να τρέξουμε την <code>git diff-tree</code> με τον κλάδο με τον οποίο θέλουμε να συγκρίνουμε:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff-tree -p rack_branch</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ή για να συγκρίνουμε τι υπάρχει στον υποκατάλογό μας <code>rack</code> σε σχέση με αυτά που υπήρχαν στον κλάδο <code>master</code> του διακομιστή την τελευταία φορά που ανακτήσαμε, μπορούμε να εκτελέσουμε</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff-tree -p rack_remote/master</code></pre>
</div>
</div>
</div>
</div>
<div id="nav"><a href="{{ page.book.section.previous | relative_url }}">prev</a> | <a href="{{ page.book.section.next | relative_url }}">next</a></div>