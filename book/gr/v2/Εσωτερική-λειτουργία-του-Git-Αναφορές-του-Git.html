---
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: gr
  chapter:
    title: Εσωτερική λειτουργία του Git
    number: 10
  section:
    title: Αναφορές του Git
    number: 3
    cs_number: '10.3'
    previous: book/gr/v2/Εσωτερική-λειτουργία-του-Git-Αντικείμενα-του-Git
    next: book/gr/v2/Εσωτερική-λειτουργία-του-Git-Πακετάρισμα-αρχείων
title: Git - Αναφορές του Git

---
<h2 id="r_git_refs">Αναφορές του Git</h2>
<div class="paragraph">
<p>Μπορούμε να εκτελέσουμε κάτι σαν το <code>git log 1a410e</code> για να δούμε όλο το ιστορικό μας, αλλά πρέπει ακόμα να θυμόμαστε ότι η <code>1a410e</code> είναι η τελευταία υποβολή, για να διασχίσουμε εκείνο το ιστορικό και να βρούμε όλα αυτά τα αντικείμενα.
Χρειαζόμαστε ένα αρχείο στο οποίο μπορούμε να αποθηκεύσουμε την τιμή SHA-1 με ένα απλό όνομα, ώστε να μπορούμε να χρησιμοποιήσουμε αυτόν τον δείκτη και όχι την τιμή SHA-1.</p>
</div>
<div class="paragraph">
<p>Στο Git, αυτά ονομάζονται “αναφορές” (references) ή “refs”· μπορούμε να βρούμε τα αρχεία που περιέχουν τις τιμές SHA-1 στον κατάλογο <code>.git/refs</code>.
Στο τρέχον έργο, αυτός ο κατάλογος δεν περιέχει αρχεία, αλλά περιέχει μια απλή δομή:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ find .git/refs
.git/refs
.git/refs/heads
.git/refs/tags
$ find .git/refs -type f</code></pre>
</div>
</div>
<div class="paragraph">
<p>Για να δημιουργήσουμε μια νέα αναφορά που θα μας βοηθήσει να θυμόμαστε πού είναι η τελευταία μας υποβολή, τεχνικά μπορούμε να κάνουμε κάτι τόσο απλό όπως το εξής:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ echo "1a410efbd13591db07496601ebc7a059dd55cfe9" &gt; .git/refs/heads/master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Τώρα μπορούμε να χρησιμοποιήσουμε την αναφορά κεφαλής που μόλις δημιουργήσαμε αντί της τιμής SHA-1 στις εντολές Git:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --pretty=oneline  master
1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</code></pre>
</div>
</div>
<div class="paragraph">
<p>Καλό θα είναι να μην επεξεργαζόμαστε απευθείας τα αρχεία αναφορών.
Το Git παρέχει μία ασφαλέστερη εντολή εάν θέλουμε να ενημερώσουμε μια αναφορά, την <code>update-ref</code>,:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git update-ref refs/heads/master 1a410efbd13591db07496601ebc7a059dd55cfe9</code></pre>
</div>
</div>
<div class="paragraph">
<p>Αυτό βασικά είναι τι είναι ένας κλάδος στο Git: ένας απλός δείκτης ή μια αναφορά στην κεφαλή μιας γραμμής εργασίας.
Για να δημιουργήσουμε έναν κλάδο πίσω στη δεύτερη υποβολή, μπορούμε να το κάνουμε το εξής:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git update-ref refs/heads/test cac0ca</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ο κλάδος μας θα περιέχει μόνο εργασίες από αυτήν την υποβολή και μετά:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --pretty=oneline test
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</code></pre>
</div>
</div>
<div class="paragraph">
<p>Τώρα, η βάση δεδομένων του Git μοιάζει με αυτό:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{ "book/en/v2/images/data-model-4.png" | relative_url }}" alt="Αντικείμενα του καταλόγου του Git συμπεριλαμβάνομένων αναφορών κεφαλής κλάδου.">
</div>
<div class="title">Figure 152. Αντικείμενα του καταλόγου του Git συμπεριλαμβάνομένων αναφορών κεφαλής κλάδου.</div>
</div>
<div class="paragraph">
<p>Όταν εκτελούμε εντολές όπως η <code>git branch &lt;όνομα_κλάδου&gt;</code>, το Git βασικά τρέχει αυτήν την εντολή <code>update-ref</code> για να προσθέσει τον αριθμό SHA-1 της τελευταίας υποβολής του κλάδου στον οποίο βρισκόμαστε σε οποιαδήποτε νέα αναφορά θέλουμε να δημιουργήσουμε.</p>
</div>
<div class="sect3">
<h3 id="r_the_head">Ο HEAD</h3>
<div class="paragraph">
<p>Το ερώτημα τώρα είναι, όταν τρέχουμε την `git branch &lt;όνομα_κλάδου&gt;, πώς γνωρίζει το Git τον αριθμό SHA-1 της τελευταίας υποβολής;
Η απάντηση είναι το αρχείο HEAD.</p>
</div>
<div class="paragraph">
<p>Το αρχείο HEAD είναι συμβολική αναφορά στον κλάδο στο οποίο βρισκόμαστε.
Με συμβολική αναφορά, εννοούμε ότι σε αντίθεση με μια κανονική αναφορά, δεν περιέχει γενικά μια τιμή SHA-1, αλλά έναν δείκτη σε μια άλλη αναφορά.
Εάν κοιτάξουμε το αρχείο, θα δούμε κάτι τέτοιο:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat .git/HEAD
ref: refs/heads/master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Αν εκτελέσουμε την <code>git checkout test</code>, το Git ενημερώνει το αρχείο ώστε να φαίνεται ως εξής:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat .git/HEAD
ref: refs/heads/test</code></pre>
</div>
</div>
<div class="paragraph">
<p>Όταν εκτελούμε την <code>git commit</code>, δημιουργεί το αντικείμενο υποβολής, ορίζοντας τον γονέα του αντικειμένου υποβολής να είναι όποια τιμή SHA-1 δείχνει η αναφορά στον HEAD.</p>
</div>
<div class="paragraph">
<p>Μπορούμε επίσης να επεξεργαστούμε χειροκίνητα αυτό το αρχείο, αλλά και πάλι υπάρχει μια ασφαλέστερη εντολή: <code>symbolic-ref</code>.
Μπορούμε να διαβάσουμε την τιμή του HEAD μας μέσω αυτής της εντολής:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git symbolic-ref HEAD
refs/heads/master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Μπορούμε επίσης να ορίσουμε την τιμή του HEAD:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git symbolic-ref HEAD refs/heads/test
$ cat .git/HEAD
ref: refs/heads/test</code></pre>
</div>
</div>
<div class="paragraph">
<p>Δεν μπορούμε να ορίσουμε μια συμβολική αναφορά εκτός του καταλόγου refs:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git symbolic-ref HEAD test
fatal: Refusing to point HEAD outside of refs/</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_ετικέτες">Ετικέτες</h3>
<div class="paragraph">
<p>Μόλις ολοκληρώσαμε τη συζήτηση για τους τρεις κύριους τύπους αντικειμένων του Git, αλλά υπάρχει ένας τέταρτος.
Το αντικείμενο “ετικέτα” μοιάζει πολύ με ένα αντικείμενο υποβολής —περιέχει μία ταμπέλα, μια ημερομηνία, ένα μήνυμα και έναν δείκτη.
Η κύρια διαφορά είναι ότι ένα αντικείμενο ετικέτας γενικά οδηγεί σε υποβολή και όχι σε δέντρο.
Είναι σαν αναφορά κλάδου, αλλά δεν μετακινείται ποτέ —δείχνει πάντοτε την ίδια υποβολή, αλλά δίνει ένα πιο φιλικό όνομα.</p>
</div>
<div class="paragraph">
<p>Όπως αναλύθηκε στην ενότητα <a href="ch00/ch02-git-basics">[ch02-git-basics]</a>, υπάρχουν δύο τύποι ετικετών: επισημειωμένοι (annotated) και ελαφριές (lightweight).
Μπορούμε να κάνουμε μια ελαφριά ετικέτα τρέχοντας κάτι σαν αυτό:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git update-ref refs/tags/v1.0 cac0cab538b970a37ea1e769cbbde608743bc96d</code></pre>
</div>
</div>
<div class="paragraph">
<p>Μία ελαφριά ετικέτα είναι ακριβώς και μόνον αυτό —μια αναφορά που δεν κινείται ποτέ.
Ωστόσο, μια επισημειωμένη ετικέτα είναι πιο περίπλοκη.
Αν δημιουργήσουμε μια επισημειωμένη ετικέτα, το Git δημιουργεί ένα αντικείμενο ετικέτας και στη συνέχεια γράφει μια αναφορά που δείχνει σε αυτήν και όχι απευθείας στην υποβολή.
Μπορούμε να το δούμε αυτό δημιουργώντας μια επισημειωμένη ετικέτα (η επιλογή <code>-a</code> καθορίζει ότι είναι μια ετικέτα σχολιασμένη):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git tag -a v1.1 1a410efbd13591db07496601ebc7a059dd55cfe9 -m 'test tag'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Εδώ είναι το αντικείμενο SHA-1 που δημιούργησε:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat .git/refs/tags/v1.1
9585191f37f7b0fb9444f35a9bf50de191beadc2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Τώρα, ας εκτελέσουμε την εντολή <code>cat-file</code> στην τιμή SHA-1:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git cat-file -p 9585191f37f7b0fb9444f35a9bf50de191beadc2
object 1a410efbd13591db07496601ebc7a059dd55cfe9
type commit
tag v1.1
tagger Scott Chacon &lt;schacon@gmail.com&gt; Sat May 23 16:48:58 2009 -0700

test tag</code></pre>
</div>
</div>
<div class="paragraph">
<p>Παρατηρούμε ότι το  αντικείμενο δείχνει στην τιμή SHA-1 της υποβολής που έχουμε επισημάνει.
Επίσης παρατηρούμε ότι δεν είναι απαραίτητο να δείχνει σε μια υποβολή· μπορούμε να βάλουμε ετικέτα σε οποιοδήποτε αντικείμενο Git.
Στον πηγαίο κώδικα Git, για παράδειγμα, ο συντηρητής έχει προσθέσει το δημόσιο κλειδί GPG ως αντικείμενο blob και έπειτα του προσάρτησε μία ετικέτα.
Μπορούμε να δούμε το δημόσιο κλειδί τρέχοντας αυτό σε έναν κλώνο του αποθετηρίου Git:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git cat-file blob junio-gpg-pub</code></pre>
</div>
</div>
<div class="paragraph">
<p>Το αποθετήριο του πυρήνα του Linux διαθέτει επίσης ένα αντικείμενο ετικέτας που δεν δείχνει σε υποβολή —η πρώτη ετικέτα που δημιουργήθηκε δείχνει στο αρχικό δέντρο της εισαγωγής του πηγαίου κώδικα.</p>
</div>
</div>
<div class="sect3">
<h3 id="_απομακρυσμένες_αναφορές">Απομακρυσμένες αναφορές</h3>
<div class="paragraph">
<p>Ο τρίτος τύπος αναφοράς που θα δούμε είναι μια απομακρυσμένη αναφορά.
Εάν προσθέσουμε ένα απομακρυσμένο αποθετήριο και ωθήσουμε σε αυτό, το Git αποθηκεύει την τιμή που ωθήσαμε τελευταία σε αυτό το απομακρυσμένο αποθετήριο για κάθε κλάδο στον κατάλογο <code>refs/remotes</code>.
Για παράδειγμα, μπορούμε να προσθέσουμε ένα απομακρυσμένο αποθετήριο που ονομάζεται <code>origin</code> και να ωθήσουμε τον κλάδο μας <code>master</code> σε αυτό:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git remote add origin git@github.com:schacon/simplegit-progit.git
$ git push origin master
Counting objects: 11, done.
Compressing objects: 100% (5/5), done.
Writing objects: 100% (7/7), 716 bytes, done.
Total 7 (delta 2), reused 4 (delta 1)
To git@github.com:schacon/simplegit-progit.git
  a11bef0..ca82a6d  master -&gt; master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Στη συνέχεια, μπορούμε να δούμε πώς ήταν ο κλάδος <code>master</code> στο απομακρυσμένο αποθετήριο <code>origin</code> την τελευταία φορά που επικοινωνήσαμε με τον διακομιστή, ελέγχοντας το αρχείο <code>refs/remotes/origin/master</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat .git/refs/remotes/origin/master
ca82a6dff817ec66f44342007202690a93763949</code></pre>
</div>
</div>
<div class="paragraph">
<p>Οι απομακρυσμένες αναφορές διαφέρουν από τους κλάδους (αναφορές <code>refs/heads</code>) κυρίως επειδή θεωρούνται μόνο για ανάγνωση.
Μπορούμε να κάνουμε <code>git checkout</code> σε μία απομακρυσμένη αναφορά, αλλά το Git ποτέ δεν θα κάνει τον HEAD σε μία, συνεπώς ποτέ δεν θα την ενημερώσουμε με μια εντολή <code>commit</code>.
Το Git τις διαχειρίζεται ως σελιδοδείκτες στην τελευταία γνωστή κατάσταση στην οποία βρίσκονταν εκείνοι οι κλάδοι σε αυτούς τους διακομιστές.</p>
</div>
</div>
<div id="nav"><a href="{{ page.book.section.previous | relative_url }}">prev</a> | <a href="{{ page.book.section.next | relative_url }}">next</a></div>