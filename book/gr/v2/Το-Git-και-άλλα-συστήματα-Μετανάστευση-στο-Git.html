---
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: gr
  chapter:
    title: Το Git και άλλα συστήματα
    number: 9
  section:
    title: Μετανάστευση στο Git
    number: 2
    cs_number: '9.2'
    previous: book/gr/v2/Το-Git-και-άλλα-συστήματα-Το-Git-ως-πελάτης
    next: book/gr/v2/Το-Git-και-άλλα-συστήματα-Ανακεφαλαίωση
title: Git - Μετανάστευση στο Git

---
<h2 id="r_migrating">Μετανάστευση στο Git</h2>
<div class="paragraph">
<p>
Αν έχουμε υπάρχουσα βάση κώδικα σε άλλο VCS αλλά έχουμε αποφασίσει να αρχίσουμε να χρησιμοποιούμε το Git, πρέπει να μεταφέρουμε το έργο μας με τον ένα ή τον άλλο τρόπο.
Αυτή η ενότητα αφορά ορισμένους εισαγωγείς για τα συνήθη συστήματα και στη συνέχεια δείχνει πώς να αναπτύξουμε το δικό μας, προσαρμοσμένο στις ανάγκες μας εισαγωγέα.
Θα μάθουμε πώς μπορούμε να εισάγουμε δεδομένα από πολλά από τα μεγαλύτερα συστήματα SCM που χρησιμοποιούνται επαγγελματικά, επειδή αποτελούν την πλειονότητα των χρηστών που μετακινούνται και επειδή είναι διαθέσιμα εργαλεία υψηλής ποιότητας για αυτά τα συστήματα.</p>
</div>
<div class="sect3">
<h3 id="_subversion">Subversion</h3>
<div class="paragraph">
<p>

Όπως αναφέρεται στην προηγούμενη ενότητα σχετικά με τη χρήση του <code>git svn</code>, μπορούμε εύκολα να χρησιμοποιήσουμε αυτές τις οδηγίες για να κλωνοποιήσουμε ένα αποθετήριο SVN με την <code>git svn clone</code>· στη συνέχεια, σταματούμε να χρησιμοποιούμε τον διακομιστή Subversion, ωθούμε στον νέο διακομιστή Git και αρχίζουμε να χρησιμοποιούμε αυτόν.
Εάν θέλουμε το ιστορικό, αυτό είναι κάτι που μπορούμε να το πετύχουμε τόσο γρήγορα όσο γρήγορα μπορούμε να τραβήξουμε τα δεδομένα από τον διακομιστή Subversion (αυτό μπορεί να πάρει διαρκέσει αρκετά).</p>
</div>
<div class="paragraph">
<p>Ωστόσο, η εισαγωγή δεν είναι τέλεια· και επειδή θα διαρκέσει τόσο πολύ ούτως ή άλλως, ας την κάνουμε σωστά.
Το πρώτο πρόβλημα είναι οι πληροφορίες του συγγραφέα.
Στο Subversion, κάθε άτομο που υποβάλλει έχει έναν χρήστη στο σύστημα που καταγράφεται καταγραφεί στις πληροφορίες της υποβολής.
Τα παραδείγματα στην προηγούμενη ενότητα δείχνουν <code>schacon</code> σε ορισμένα σημεία, όπως στις εξόδους των <code>blame</code> και <code>git svn log</code>.
Εάν θέλουμε να αντιστοιχίσουμε αυτό για να βελτιώσουμε τις πληροφορίες των συγγραφέων στο Git, χρειάζεστε μια απεικόνιση από τους χρήστες του Subversion στους συγγραφείς του Git.
Δημιουργούμε ένα αρχείο με όνομα <code>users.txt</code> που έχει αυτήν την απεικόνιση στην παρακάτω μορφή:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>schacon = Scott Chacon &lt;schacon@geemail.com&gt;
selse = Someo Nelse &lt;selse@geemail.com&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Για να αποκτήσουμε μια λίστα με τα ονόματα συγγραφέων που χρησιμοποιεί το SVN, μπορούμε να εκτελέσουμε το εξής:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ svn log --xml | grep author | sort -u | \
  perl -pe 's/.*&gt;(.*?)&lt;.*/$1 = /'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Αυτό δίνει την έξοδο του αρχείου καταγραφής σε μορφή XML, διατηρεί μόνο τις γραμμές με πληροφορίες συγγραφέα, απορρίπτει διπλότυπα, απομακρύνει τις ετικέτες XML.
(Προφανώς αυτό λειτουργεί μόνο σε ένα μηχάνημα που έχει εγκατεστημένα  τα προγράμματα <code>grep</code>, <code>sort</code> και <code>perl</code>.)
Στη συνέχεια, ανακατευθύνουμε την έξοδο στο αρχείο users.txt, ώστε να μπορούμε να προσθέσουμε τα αντίστοιχα δεδομένα χρήστη Git δίπλα σε κάθε καταχώρηση.</p>
</div>
<div class="paragraph">
<p>Μπορούμε να δώσουμε αυτό το αρχείο στην <code>git svn</code> για να το βοηθήσουμε να αντιστοιχίσει τα δεδομένα των συγγραφέων με μεγαλύτερη ακρίβεια.
Μπορούμε επίσης να πούμε στο <code>git svn</code> να μην συμπεριλάβει τα μεταδεδομένα που εισάγει το Subversion υπό κανονικές συνθήκες, περνώντας την επιλογή <code>--no-metadata</code> στην εντολή <code>clone</code> ή την <code>init</code>.
Αυτό κάνει την εντολή <code>import</code> μας να μοιάζει με αυτή:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git svn clone http://my-project.googlecode.com/svn/ \
      --authors-file=users.txt --no-metadata -s my_project</code></pre>
</div>
</div>
<div class="paragraph">
<p>Τώρα θα πρέπει να έχουμε μια καλύτερη εισαγωγή από το Subversion στον κατάλογο <code>my_project</code>.
Αντί οι υποβολές που μοιάζουν με αυτό:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>commit 37efa680e8473b615de980fa935944215428a35a
Author: schacon &lt;schacon@4c93b258-373f-11de-be05-5f7a86268029&gt;
Date:   Sun May 3 00:12:22 2009 +0000

    fixed install - go to trunk

    git-svn-id: https://my-project.googlecode.com/svn/trunk@94 4c93b258-373f-11de-
    be05-5f7a86268029</code></pre>
</div>
</div>
<div class="paragraph">
<p>μοιάζουν με αυτό:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>commit 03a8785f44c8ea5cdb0e8834b7c8e6c469be2ff2
Author: Scott Chacon &lt;schacon@geemail.com&gt;
Date:   Sun May 3 00:12:22 2009 +0000

    fixed install - go to trunk</code></pre>
</div>
</div>
<div class="paragraph">
<p>Όχι μόνο το πεδίο “Author” φαίνεται πολύ καλύτερα, αλλά επιπλέον το <code>git-svn-id</code> δεν βρίσκεται πια εκεί.</p>
</div>
<div class="paragraph">
<p>Θα πρέπει επίσης να κάνουμε ένα συμμαζεματάκι μετά την εισαγωγή.
Καταρχάς, θα πρέπει να καθαρίσουμε τις περίεργες αναφορές που έβαλε η <code>git svn</code>.
Αρχικά θα μετακινήσουμε τις ετικέτες έτσι ώστε να είναι πραγματικές ετικέτες και όχι περίεργοι απομακρυσμένοι κλάδοι και στη συνέχεια θα μετακινήσουμε τους υπόλοιπους κλάδους έτσι ώστε να είναι τοπικοί.</p>
</div>
<div class="paragraph">
<p>Για να μετακινήσουμε τις ετικέτες ώστε να είναι κατάλληλες ετικέτες Git, εκτελούμε:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cp -Rf .git/refs/remotes/origin/tags/* .git/refs/tags/
$ rm -Rf .git/refs/remotes/origin/tags</code></pre>
</div>
</div>
<div class="paragraph">
<p>Το παραπάνω παίρνει τις αναφορές που ήταν απομακρυσμένοι κλάδοι που ξεκίνησαν με <code>remotes/origin/tags/</code> και τα κάνει πραγματικές (ελαφριές) ετικέτες.</p>
</div>
<div class="paragraph">
<p>Στη συνέχεια μετακινούμε τις υπόλοιπες αναφορές του φακέλου <code>refs/remotes</code> ώστε να είναι τοπικοί κλάδοι:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cp -Rf .git/refs/remotes/* .git/refs/heads/
$ rm -Rf .git/refs/remotes</code></pre>
</div>
</div>
<div class="paragraph">
<p>Τώρα όλοι οι παλιοί κλάδοι είναι πραγματικοί κλάδοι Git και όλες οι παλιές ετικέτες είναι πραγματικές ετικέτες Git.
Το τελευταίο πράγμα που πρέπει να κάνουμε είναι να προσθέσουμε τον νέο μας διακομιστή Git ως απομακρυσμένο και να τον ωθήσουμε.
Ακολουθεί ένα παράδειγμα προσθήκης του διακομιστή μας ως απομακρυσμένου αποθετηρίου:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git remote add origin git@my-git-server:myrepository.git</code></pre>
</div>
</div>
<div class="paragraph">
<p>Επειδή θέλουμε να ανέβουν όλοι οι κλάδοι και οι ετικέτες μας, μπορούμε τώρα να εκτελέσουμε το εξής:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git push origin --all</code></pre>
</div>
</div>
<div class="paragraph">
<p>Όλοι οι κλάδοι μας και οι ετικέτες μας θα πρέπει να βρίσκονται στο νέο μας διακομιστή Git σε μια ωραία και καθαρή εισαγωγή.</p>
</div>
</div>
<div class="sect3">
<h3 id="_mercurial">Mercurial</h3>
<div class="paragraph">
<p>
Δεδομένου ότι τα Mercurial και Git έχουν αρκετά παρόμοια μοντέλα για να αναπαριστούν τις εκδόσεις και καθώς το Git είναι λίγο πιο ευέλικτο, η μετατροπή ενός αποθετηρίου από το Mercurial στο Git είναι αρκετά απλή, χάρη σε ένα εργαλείο που ονομάζεται <code>hg-fast-export</code>, το οποιο θα χρειαστούμε:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clone http://repo.or.cz/r/fast-export.git /tmp/fast-export</code></pre>
</div>
</div>
<div class="paragraph">
<p>Το πρώτο βήμα της μετατροπής είναι να αποκτήσουμε έναν πλήρη κλώνο του αποθετηρίου Mercurial που θέλουμε να μετατρέψουμε:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ hg clone &lt;URL_απομακρυσμένου_αποθετηρίου&gt; /tmp/hg-repo</code></pre>
</div>
</div>
<div class="paragraph">
<p>Το επόμενο βήμα είναι να δημιουργήσουμε ένα αρχείο αντιστοίχισης των συγγραφέων.
Το Mercurial είναι λίγο πιο συγχωρητικό από το Git όσον αφορά σε αυτά που θα θέσει στο πεδίο author για το σύνολο των αλλαγών, γι' αυτό είναι μια καλή ευκαιρία για ένα μικρό συμμάζεμα.
Το συμμάζεμα είναι μία εντολή της μιας γραμμής στο κέλυφος <code>bash</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cd /tmp/hg-repo
$ hg log | grep user: | sort | uniq | sed 's/user: *//' &gt; ../authors</code></pre>
</div>
</div>
<div class="paragraph">
<p>Αυτό θα διαρκέσει μερικά δευτερόλεπτα, ανάλογα με το πόσο εκτενές είναι το ιστορικό του έργου μας και μετά το αρχείο <code>/tmp/authors</code> θα μοιάζει με αυτό:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>bob
bob@localhost
bob &lt;bob@company.com&gt;
bob jones &lt;bob &lt;AT&gt; company &lt;DOT&gt; com&gt;
Bob Jones &lt;bob@company.com&gt;
Joe Smith &lt;joe@company.com&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Σε αυτό το παράδειγμα, το ίδιο άτομο (Bob) δημιούργησε σύνολα αλλαγών κάτω από τέσσερα διαφορετικά ονόματα, ένα από τα οποία φαίνεται πραγματικά σωστό και ένα από τα οποία θα ήταν εντελώς άκυρο για μια υποβολή Git.
Η <code>hg-fast-export</code> μάς επιτρέπει να το διορθώσουμε προσθέτοντας <code>={νέο όνομα και νέα διεύθυνση e-mail}</code> στο τέλος κάθε γραμμής που θέλουμε να αλλάξουμε και αφαιρώντας τις γραμμές για όλα τα ονόματα χρήστη που θέλουμε να αφήσουμε ανέγγιχτα.
Αν όλα τα ονόματα χρηστών φαίνονται ωραία, δεν θα χρειαστεί καθόλου αυτό το αρχείο.
Σε αυτό το παράδειγμα, θέλουμε το αρχείο μας να μοιάζει με αυτό:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>bob=Bob Jones &lt;bob@company.com&gt;
bob@localhost=Bob Jones &lt;bob@company.com&gt;
bob jones &lt;bob &lt;AT&gt; company &lt;DOT&gt; com&gt;=Bob Jones &lt;bob@company.com&gt;
bob &lt;bob@company.com&gt;=Bob Jones &lt;bob@company.com&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Το επόμενο βήμα είναι να δημιουργήσουμε το νέο μας αποθετήριο Git και να εκτελέσουμε το script εξαγωγής:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git init /tmp/converted
$ cd /tmp/converted
$ /tmp/fast-export/hg-fast-export.sh -r /tmp/hg-repo -A /tmp/authors</code></pre>
</div>
</div>
<div class="paragraph">
<p>Η σημαία <code>-r</code> λέει στο <code>hg-fast-export</code> πού θα βρει το αποθετήριο Mercurial που θέλουμε να μετατρέψουμε και η σημαία <code>-A</code> του λέει πού θα βρει το αρχείο αντιστοίχισης των συγγραφέων.
Το script αναλύει τα σύνολα αλλαγών του Mercurial changesets και τα μετατρέπει σε ένα script για τη λειτουργία “γρήγορης εισαγωγής” του Git (η οποία θα συζητηθεί λεπτομερώς λίγο αργότερα).
Αυτό διαρκεί λιγάκι (αν και είναι πολύ πιο γρήγορα από ό,τι θα ήταν πάνω από το δίκτυο) και η έξοδος είναι αρκετά λεπτομερής:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ /tmp/fast-export/hg-fast-export.sh -r /tmp/hg-repo -A /tmp/authors
Loaded 4 authors
master: Exporting full revision 1/22208 with 13/0/0 added/changed/removed files
master: Exporting simple delta revision 2/22208 with 1/1/0 added/changed/removed files
master: Exporting simple delta revision 3/22208 with 0/1/0 added/changed/removed files
[…]
master: Exporting simple delta revision 22206/22208 with 0/4/0 added/changed/removed files
master: Exporting simple delta revision 22207/22208 with 0/2/0 added/changed/removed files
master: Exporting thorough delta revision 22208/22208 with 3/213/0 added/changed/removed files
Exporting tag [0.4c] at [hg r9] [git :10]
Exporting tag [0.4d] at [hg r16] [git :17]
[…]
Exporting tag [3.1-rc] at [hg r21926] [git :21927]
Exporting tag [3.1] at [hg r21973] [git :21974]
Issued 22315 commands
git-fast-import statistics:
---------------------------------------------------------------------
Alloc'd objects:     120000
Total objects:       115032 (    208171 duplicates                  )
      blobs  :        40504 (    205320 duplicates      26117 deltas of      39602 attempts)
      trees  :        52320 (      2851 duplicates      47467 deltas of      47599 attempts)
      commits:        22208 (         0 duplicates          0 deltas of          0 attempts)
      tags   :            0 (         0 duplicates          0 deltas of          0 attempts)
Total branches:         109 (         2 loads     )
      marks:        1048576 (     22208 unique    )
      atoms:           1952
Memory total:          7860 KiB
       pools:          2235 KiB
     objects:          5625 KiB
---------------------------------------------------------------------
pack_report: getpagesize()            =       4096
pack_report: core.packedGitWindowSize = 1073741824
pack_report: core.packedGitLimit      = 8589934592
pack_report: pack_used_ctr            =      90430
pack_report: pack_mmap_calls          =      46771
pack_report: pack_open_windows        =          1 /          1
pack_report: pack_mapped              =  340852700 /  340852700
---------------------------------------------------------------------

$ git shortlog -sn
   369  Bob Jones
   365  Joe Smith</code></pre>
</div>
</div>
<div class="paragraph">
<p>Σε γενικές γραμμές αυτό ήταν όλο.
Όλες οι ετικέτες του Mercurial έχουν μετατραπεί σε ετικέτες Git και τα οι κλάδοι και σελιδοδείκτες του Mercurial έχουν μετατραπεί σε κλάδους του Git.
Τώρα είμαστε έτοιμοι να ωθήσουμε το αποθετήριο στον διακομιστή που θα είναι το νέο του σπίτι:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git remote add origin git@my-git-server:myrepository.git
$ git push origin --all</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h3 id="r_perforce_import">Perforce</h3>
<div class="paragraph">
<p>
Το επόμενο σύστημα από το οποίο θα εξετάσουμε την εισαγωγή είναι το Perforce.
Όπως συζητήσαμε παραπάνω, υπάρχουν δύο τρόποι να αφήσουμε τα Git και Perforce να μιλήσουν μεταξύ τους: οι <code>git-p4</code> και Perforce Git Fusion.</p>
</div>
<div class="sect4">
<h4 id="_perforce_git_fusion">Perforce Git Fusion</h4>
<div class="paragraph">
<p>Το Git Fusion καθιστά αυτήν τη διαδικασία αρκετά ανώδυνη.
Απλά διαμορφώνουμε τις ρυθμίσεις του έργου, τις αντιστοιχίσεις χρηστών και τους κλάδους μας χρησιμοποιώντας ένα αρχείο διαμόρφωσης (όπως αναλύθηκε στην ενότητα <a href="ch00/r_p4_git_fusion">Git Fusion</a>) και κλωνοποιούμε το αποθετήριο.
Το Git Fusion μας αφήνει με κάτι που μοιάζει με εγγενές αποθετήριο Git, το οποίο είναι έτοιμο να ωθήσει σε έναν εγγενή κεντρικό υπολογιστή Git, εφόσον το επιθυμούμε.
Θα μπορούσαμε ακόμη και να χρησιμοποιήσουμε το Perforce ως τον κεντρικό υπολογιστή του Git, αν θέλουμε.</p>
</div>
</div>
<div class="sect4">
<h4 id="r_git_p4"><code>git-p4</code></h4>
<div class="paragraph">
<p>Η <code>git-p4</code> μπορεί επίσης να λειτουργήσει ως εργαλείο εισαγωγής.
Για παράδειγμα, θα εισάγουμε το έργο Jam από το Perforce Public Depot.
Για να ρυθμίσουμε τον πελάτη μας, πρέπει να εξάγουμε τη μεταβλητή περιβάλλοντος <code>P4PORT</code> για να δείξουμε στην αποθήκη Perforce:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ export P4PORT=public.perforce.com:1666</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Για τη συνέχεια της επίδειξης, θα χρειαστεί να συνδεθούμε σε μία αποθήκη Perforce.
Θα χρησιμοποιήσουμε τη δημόσια αποθήκη στο public.perforce.com για τα παραδείγματα μας, αλλά μπορούμε να χρησιμοποιήσουμε οποιαδήποτε αποθήκη στην οποία έχουμε πρόσβαση.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>
Εκτελούμε την εντολή <code>git p4 clone</code> για να εισάγουμε το έργο Jam από τον διακομιστή Perforce, παρέχοντας την αποθήκη, τη διαδρομή έργου και τη διαδρομή στην οποία θέλουμε να εισάγουμε το έργο:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git-p4 clone //guest/perforce_software/jam@all p4import
Importing from //guest/perforce_software/jam@all into p4import
Initialized empty Git repository in /private/tmp/p4import/.git/
Import destination: refs/remotes/p4/master
Importing revision 9957 (100%)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Αυτό το συγκεκριμένο έργο έχει μόνο έναν κλάδο, αλλά αν έχουμε κλάδους  που έχουν διαμορφωθεί με προβολές κλάδων (ή απλώς ένα σύνολο καταλόγων), μπορούμε να χρησιμοποιήσουμε τη σημαία <code>--detect-branches</code> στην <code>git p4 clone</code> για να εισάγουμε όλους τους κλάδους του έργου.
Βλ. ενότητα <a href="ch00/r_git_p4_branches">Διακλάδωση</a> για λίγο περισσότερες λεπτομέρειες σχετικά με αυτό.</p>
</div>
<div class="paragraph">
<p>Σε αυτό το σημείο είμαστε σχεδόν έτοιμοι.
Εάν μεταβούμε στον κατάλογο <code>p4import</code> και εκτελέσουμε την <code>git log</code>, μπορούμε να δούμε την εργασία που εισάγαμε:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log -2
commit e5da1c909e5db3036475419f6379f2c73710c4e6
Author: giles &lt;giles@giles@perforce.com&gt;
Date:   Wed Feb 8 03:13:27 2012 -0800

    Correction to line 355; change &lt;/UL&gt; to &lt;/OL&gt;.

    [git-p4: depot-paths = "//public/jam/src/": change = 8068]

commit aa21359a0a135dda85c50a7f7cf249e4f7b8fd98
Author: kwirth &lt;kwirth@perforce.com&gt;
Date:   Tue Jul 7 01:35:51 2009 -0800

    Fix spelling error on Jam doc page (cummulative -&gt; cumulative).

    [git-p4: depot-paths = "//public/jam/src/": change = 7304]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Μπορούμε να δούμε ότι το <code>git-p4</code> έχει αφήσει ένα αναγνωριστικό σε κάθε μήνυμα υποβολής.
Μπορούμε να διατηρήσουμε αυτό το αναγνωριστικό εκεί, σε περίπτωση που χρειάζεται να αναφερθούμε αργότερα στον αριθμό αλλαγής Perforce.
Ωστόσο, αν θέλουμε να καταργήσουμε το αναγνωριστικό, τώρα είναι η κατάλληλη στιγμή να το κάνουμε —προτού αρχίσουμε να εργαζόμαστε στο νέο αποθετήριο.

Μπορούμε να χρησιμοποιήσουμε την <code>git filter-branch</code> για να αφαιρέσουμε τις σειρές αναγνωριστικών μαζικά:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git filter-branch --msg-filter 'sed -e "/^\[git-p4:/d"'
Rewrite e5da1c909e5db3036475419f6379f2c73710c4e6 (125/125)
Ref 'refs/heads/master' was rewritten</code></pre>
</div>
</div>
<div class="paragraph">
<p>Αν εκτελέσουμε την <code>git log</code>, μπορούμε να δούμε ότι όλα τα αθροίσματα ελέγχου SHA-1 για τις υποβολές έχουν αλλάξει αλλά οι συμβολοσειρές <code>git-p4</code> δεν βρίσκονται πλέον στα μηνύματα commit:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log -2
commit b17341801ed838d97f7800a54a6f9b95750839b7
Author: giles &lt;giles@giles@perforce.com&gt;
Date:   Wed Feb 8 03:13:27 2012 -0800

    Correction to line 355; change &lt;/UL&gt; to &lt;/OL&gt;.

commit 3e68c2e26cd89cb983eb52c024ecdfba1d6b3fff
Author: kwirth &lt;kwirth@perforce.com&gt;
Date:   Tue Jul 7 01:35:51 2009 -0800

    Fix spelling error on Jam doc page (cummulative -&gt; cumulative).</code></pre>
</div>
</div>
<div class="paragraph">
<p>Η εισαγωγή μας είναι έτοιμη να ωθηθεί στον νέο μας διακομιστή Git.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="r_git_tfs">TFS</h3>
<div class="paragraph">
<p>
Αν η ομάδα μας μετατρέπει τον έλεγχο πηγαίου κώδικα από το TFVC στο Git, θα θελήσουμε να έχουμε την πιο πιστή μετατροπή που μπορούμε να αποκτήσουμε.
Αυτό σημαίνει ότι, αν και είδαμε τόσο την <code>git-tfs</code> όσο και την <code>git-tf</code> στην ενότητα της διαλειτουργικότητας, θα δούμε μόνο την <code>git-tfs</code> σε αυτό το μέρος, επειδή η <code>git-tfs</code> υποστηρίζει κλάδους κάτι που είναι απαγορευτικά δύσκολο με την <code>git-tf</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Πρόκειται για μια μονόδρομη μετατροπή.
Το αποθετήριο Git που προκύπτει δεν θα μπορεί να συνδεθεί με το αρχικό έργο TFVC.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Το πρώτο πράγμα που πρέπει να κάνουμε είναι να αντιστοιχίσουμε τα ονόματα χρηστών.
Το TFVC είναι αρκετά φιλελεύθερο με αυτό που πηγαίνει στο πεδίο author για σύνολα αλλαγών, αλλά το Git θέλει ένα ανθρωπανάγνωστο όνομα και διεύθυνση e-mail.
Μπορούμε να λάβουμε αυτές τις πληροφορίες από τον πελάτη γραμμής εντολών <code>tf</code>, όπως π.χ.:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-powershell" data-lang="powershell">PS&gt; tf history $/myproject -recursive &gt; AUTHORS_TMP</code></pre>
</div>
</div>
<div class="paragraph">
<p>Αυτό τραβάει όλα τα σύνολα αλλαγών στο ιστορικό του έργου και τα βάζει στο αρχείο AUTHORS_TMP που θα επεξεργαστούμε για την εξαγωγή των δεδομένων της στήλης <em>User</em> (2η στήλη).
Ανοίγουμε το αρχείο και βρίσκουμε ποιοι χαρακτήρες ξεκινούν και τελειώνουν τη στήλη αυτή και αντικαθιστούμε στην ακόλουθη γραμμή εντολών τις παραμέτρους <code>11-20</code> της εντολής <code>cut</code> με αυτούς που βρέθηκαν:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-powershell" data-lang="powershell">PS&gt; cat AUTHORS_TMP | cut -b 11-20 | tail -n+3 | uniq | sort &gt; AUTHORS</code></pre>
</div>
</div>
<div class="paragraph">
<p>Η εντολή <code>cut</code> διατηρεί μόνο τους χαρακτήρες μεταξύ των θέσεων 11 και 20 από κάθε γραμμή.
Η εντολή <code>tail</code> παραλείπει τις δύο πρώτες γραμμές, οι οποίες είναι κεφαλίδες πεδίων και υπογραμμίσεις ASCII-art.
Το αποτέλεσμα όλων αυτών παροχετεύεται στη <code>uniq</code> για να εξαλείψει τις διπλές καταχωρήσεις και αποθηκεύεται σε ένα αρχείο που ονομάζεται <code>AUTHORS</code>.
Το επόμενο βήμα είναι χειροκίνητο· για να μπορέσει η <code>git-tfs</code> να χρησιμοποιήσει αποτελεσματικά αυτό το αρχείο, κάθε γραμμή πρέπει να είναι σε αυτήν τη μορφή:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">DOMAIN\username = User Name &lt;email@address.com&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Το τμήμα στα αριστερά είναι το πεδίο “User” από το TFVC και το τμήμα στη δεξιά πλευρά του <code>=</code> είναι το όνομα χρήστη που θα χρησιμοποιηθεί για τις υποβολές Git.</p>
</div>
<div class="paragraph">
<p>Μόλις έχουμε αυτό το αρχείο, το επόμενο πράγμα που πρέπει να κάνουμε είναι να φτιάξουμε έναν πλήρη κλώνο του έργου TFVC που μας ενδιαφέρει:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-powershell" data-lang="powershell">PS&gt; git tfs clone --with-branches --authors=AUTHORS https://username.visualstudio.com/DefaultCollection $/project/Trunk project_git</code></pre>
</div>
</div>
<div class="paragraph">
<p>Στη συνέχεια, θέλουμε να καθαρίσουμε τις ενότητες <code>git-tfs-id</code> από το κάτω μέρος των μηνυμάτων υποβολής.
Αυτό μπορεί να γίνει με την ακόλουθη εντολή:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-powershell" data-lang="powershell">PS&gt; git filter-branch -f --msg-filter 'sed "s/^git-tfs-id:.*$//g"' -- --all</code></pre>
</div>
</div>
<div class="paragraph">
<p>Αυτό χρησιμοποιεί την εντολή <code>sed</code> από το περιβάλλον Git-bash για να αντικαταστήσει οποιαδήποτε γραμμή που ξεκινά με  <code>git-tfs-id:</code> με κενό, το οποίο το Git θα αγνοήσει.</p>
</div>
<div class="paragraph">
<p>Μόλις γίνει αυτό, είμαστε έτοιμοι να προσθέσουμε ένα νέο απομακρυσμένο αποθετήριο, να ωθήσουμε όλους τους κλάδους μας και να αρχίσουμε να εργαζόμαστε στο Git.</p>
</div>
</div>
<div class="sect3">
<h3 id="r_custom_importer">Ένας εξατομικευμένος εισαγωγέας</h3>
<div class="paragraph">
<p>

Εάν το σύστημά μας δεν είναι ένα από τα παραπάνω, θα πρέπει να αναζητήσουμε έναν εισαγωγέα σε απευθείας σύνδεση —διατίθενται ποιοτικοί εισαγωγείς για πολλά άλλα συστήματα, όπως τα CVS, Clear Case, Visual Source Safe, ακόμη και έναν κατάλογο αρχειοθηκών.
Εάν κανένα από αυτά τα εργαλεία δεν μας κάνει, έχουμε ένα πιο ανιγματώδες εργαλείο ή τέλος πάντων χρειαζόμαστε μια πιο εξατομικευμένη διαδικασία εισαγωγής, θα πρέπει να χρησιμοποιήσουμε την <code>git fast-import</code>.
Αυτή η εντολή διαβάζει απλές οδηγίες από τη stdin και γράφει συγκεκριμένα δεδομένα Git.
Είναι πολύ πιο εύκολο να δημιουργήσουμε αντικείμενα Git με αυτόν τον τρόπο από το να εκτελέσουμε τις εντολές του Git ή να προσπαθήσουμε να γράψουμε τα ανεπεξέργαστα αντικείμενα (για περισσότερες πληροφορίες, βλ. το <a href="ch00/ch10-git-internals">[ch10-git-internals]</a>).
Με αυτόν τον τρόπο, μπορούμε να γράψουμε ένα script εισαγωγής που διαβάζει τις απαραίτητες πληροφορίες από το σύστημα από το οποίο εισάγουμε και εκτυπώνει απλές οδηγίες στη stdout.
Στη συνέχεια μπορούμε να εκτελέσουμε αυτό το πρόγραμμα και να παροχετεύσουμε την έξοδό του μέσω της <code>git fast-import</code>.</p>
</div>
<div class="paragraph">
<p>Για μία γρήγορη επίδειξη, θα γράψουμε έναν απλό εισαγωγέα.
Ας υποθέσουμε ότι εργαζόμαστε στον <code>current</code>, δημιουργούμε αντίγραφα ασφαλείας του έργου μας αντιγράφοντας περιστασιακά τον κατάλογο σε έναν χρονοσημασμένο <code>back_YYYY_MM_DD</code> κατάλογο αντιγράφων ασφαλείας και θέλουμε να τον εισαγάγουμε στο Git.
Η δομή του καταλόγου μας μοιάζει με αυτό:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ ls /opt/import_from
back_2014_01_02
back_2014_01_04
back_2014_01_14
back_2014_02_03
current</code></pre>
</div>
</div>
<div class="paragraph">
<p>Για να εισαγάγουμε έναν κατάλογο Git, θα πρέπει να θυμηθούμε τον τρόπο με τον οποίο το Git αποθηκεύει δεδομένα.
Όπως έχει αναφερθεί, το Git είναι βασικά μια συνδεδεμένη λίστα αντικειμένων υποβολής που δείχνουν σε ένα στιγμιότυπο του περιεχομένου.
Το μόνο που έχουμε να κάνουμε είναι να πούμε στην <code>fast-import</code> ποια είναι τα στιγμιότυπα του περιεχομένου, ποια δεδομένα υποβολών δείχνουν σε αυτά και τη χρονική σειρά τους.
Η στρατηγική μας θα είναι να περάσουμε από όλα τα στιγμιότυπα ένα προς ένα και να δημιουργήσουμε υποβολές με τα περιεχόμενα κάθε καταλόγου, συνδέοντας κάθε υποβολή με την προηγούμενη.</p>
</div>
<div class="paragraph">
<p>Όπως κάναμε στην ενότητα <a href="ch00/r_an_example_git_enforced_policy">Ένα παράδειγμα επιβολής πολιτικής από το Git</a>, θα το γράψουμε σε Ruby, επειδή είναι αυτό που γενικά δουλεύουμε και είναι εύκολο να το διαβαστεί.
Μπορούμε να γράψουμε αρκετά εύκολα το συγκεκριμένο script σε οποιαδήποτε γλώσσα με την οποία είμαστε εξοικειωμένοι —χρειάζεται μόνο να τυπώσουμε τις κατάλληλες πληροφορίες στη <code>stdout</code>.
Και αν έχουμε Windows, αυτό σημαίνει ότι θα πρέπει να προσέξουμε να μην εισάγουμε χαρακτήρες επαναφοράς (CR) στο τέλος των γραμμών μας —η <code>git fast-import</code> είναι πολύ ιδιότροπη σε αυτό το θέμα και θέλει μόνο χαρακτήρες τροφοδότησης γραμμής (LF) και όχι χαρακτήρες επαναφοράς και τροφοδότησης γραμμής(CRLF) που χρησιμοποιούν τα Windows.</p>
</div>
<div class="paragraph">
<p>Αρχικά, θα μεταβούμε στον κατάλογο-στόχο και θα αναγνωρίσουμε κάθε υποκατάλογο, καθένας από τους οποίους είναι ένα στιγμιότυπο που θέλουμε να εισάγουμε ως υποβολή.
Θα μεταβούμε σε κάθε υποκατάλογο και θα εκτυπώσουμε τις εντολές που είναι απαραίτητες για την εξαγωγή του.
Ο βασικός μας κύριος βρόχος μοιάζει με αυτόν:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">last_mark = nil

# Βρόχος επανάληψης σε όλους τους υποκαταλόγους
Dir.chdir(ARGV[0]) do
  Dir.glob("*").each do |dir|
    next if File.file?(dir)

    # Μετακινήσου στον κατάλογο-στόχο
    Dir.chdir(dir) do
      last_mark = print_export(dir, last_mark)
    end
  end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Εκτελούμε την <code>print_export</code> μέσα σε κάθε κατάλογο, ο οποίος λαμβάνει το δηλωτικό και το σημάδι του προηγούμενου στιγμιότυπου και επιστρέφει το δηλωτικό και το σημάδι αυτού. Με αυτόν τον τρόπο, θα μπορέσουμε να τα συνδέσουμε σωστά.
“Σημάδι” (mark) είναι ο όρος της <code>fast-import</code> για ένα αναγνωριστικό που δίνουμε σε μια υποβολή· όταν δημιουργούμε υποβολές, δίνουμε σε καθεμία από αυτές ένα σημάδι το οποίο μπορούμε να χρησιμοποιήσουμε για να συνδεθούμε σε αυτήν από άλλες υποβολές.
Έτσι, το πρώτο πράγμα που πρέπει να κάνουμε στη μέθοδο <code>print_export</code> μας είναι να δημιουργήσουμε ένα σημάδι από το όνομα του καταλόγου:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">mark = convert_dir_to_mark(dir)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Θα το κάνουμε αυτό δημιουργώντας έναν πίνακα από καταλόγους και χρησιμοποιώντας την τιμή του δείκτη ως σημάδι, διότι το σημάδι πρέπει να είναι ένας ακέραιος αριθμός.
Η μέθοδος μας μοιάζει με αυτό:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">$marks = []
def convert_dir_to_mark(dir)
  if !$marks.include?(dir)
    $marks &lt;&lt; dir
  end
  ($marks.index(dir) + 1).to_s
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Τώρα που έχουμε μια ακέραια αναπαράσταση της υποβολής μας, χρειαζόμαστε μια ημερομηνία για τα μεταδεδομένα της υποβολής.
Επειδή η ημερομηνία εκφράζεται στο όνομα του καταλόγου, θα την εξάγουμε κάνοντας συντακτική ανάλυση.
Η επόμενη γραμμή στο αρχείο <code>print_export</code> είναι:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">date = convert_dir_to_date(dir)</code></pre>
</div>
</div>
<div class="paragraph">
<p>όπου η <code>convert_dir_to_date</code> ορίζεται ως:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">def convert_dir_to_date(dir)
  if dir == 'current'
    return Time.now().to_i
  else
    dir = dir.gsub('back_', '')
    (year, month, day) = dir.split('_')
    return Time.local(year, month, day).to_i
  end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Αυτό επιστρέφει μια ακέραια τιμή για την ημερομηνία κάθε καταλόγου.
Το τελευταίο κομμάτι των μετα-πληροφοριών που χρειάζεστε για κάθε υποβολή είναι τα δεδομένα αυτού που έκανε την υποβολή, τα οποία έχουμε κωδικοποιήσει σε μια καθολική μεταβλητή:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">$author = 'John Doe &lt;john@example.com&gt;'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Τώρα είμαστε έτοιμοι να ξεκινήσουμε να εκτυπώνουμε τα στοιχεία της υποβολής για τον εισαγωγέα μας.
Οι αρχικές πληροφορίες δηλώνουν ότι ορίζουμε ένα αντικείμενο υποβολής και σε ποιον κλάδο είναι, ακολουθούμενες από το σημάδι που δημιουργήσαμε, τις πληροφορίες αυτού που υπέβαλε, και το μήνυμα υποβολής και μετά την προηγούμενη υποβολή, εφόσον υπάρχει.
Ο κώδικας μοιάζει με αυτό:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby"># Εκτύπωσε τις πληροφορίες εισαγωγής
puts 'commit refs/heads/master'
puts 'mark :' + mark
puts "committer #{$author} #{date} -0700"
export_data('imported from ' + dir)
puts 'from :' + last_mark if last_mark</code></pre>
</div>
</div>
<div class="paragraph">
<p>Μπορούμε να θέσουμε τη ζώνη ώρας (-0700) αντί να τη διαβάσουμε, διότι αυτό είναι το πιο εύκολο.
Αν εισάγουμε από άλλο σύστημα, πρέπει να καθορίσουμε τη ζώνη ώρας ως διαφορά.
Το μήνυμα υποβολής πρέπει να εκφράζεται σε ειδική μορφή:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>data (size)\n(contents)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Η μορφή αποτελείται από τη λέξη data, το μέγεθος των προς ανάγνωση δεδομένων, μια νέα γραμμή και τελικά τα δεδομένα.
Επειδή πρέπει να χρησιμοποιήσουμε την ίδια μορφή για να καθορίσουμε αργότερα τα περιεχόμενα του αρχείου, δημιουργούμε μια βοηθητική μέθοδο, <code>export_data</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">def export_data(string)
  print "data #{string.size}\n#{string}"
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Το μόνο που έχει απομείνει είναι να καθορίσουμε τα περιεχόμενα του αρχείου για κάθε στιγμιότυπο.
Αυτό είναι εύκολο, επειδή το κάθε στιγμιότυπο είναι σε έναν κατάλογο —μπορούμε να εκτυπώσουμε την εντολή <code>deleteall</code> ακολουθούμενη από τα περιεχόμενα κάθε αρχείου στον κατάλογο.
Το Git θα καταγράψει στη συνέχεια κάθε στιγμιότυπο κατάλληλα:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">puts 'deleteall'
Dir.glob("**/*").each do |file|
  next if !File.file?(file)
  inline_data(file)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Σημείωση: Επειδή πολλά συστήματα ντιμετωπίζουν τις αναθεωρήσεις τους ως μεταβολές από μία υποβολή σε μία άλλη, η <code>fast-import</code> μπορεί επίσης να λάβει εντολές με κάθε υποβολή για να καθορίσει ποια αρχεία έχουν προστεθεί, αφαιρεθεί ή τροποποιηθεί και ποια είναι τα νέα περιεχόμενα.
Θα μπορούσαμε να υπολογίσουμε τις διαφορές μεταξύ των στιγμιότυπων και να δώσουμε μόνο αυτά τα δεδομένα, αλλά αυτό είναι πιο περίπλοκο —μπορούμε απλά να δώσουμε στο Git όλα τα δεδομένα και να αφήσουμε αυτό να καταλάβει τι γίνεται.
Αν κάτι τέτοιο ταιριάζει καλύτερα στα δεδομένα μας, καλό είναι να ελέγξουμε τη σελίδα του εγχειριδίου για την <code>fast-import</code> για λεπτομέρειες σχετικά με τον τρόπο παροχής των δεδομένων μας με αυτόν τον τρόπο.</p>
</div>
<div class="paragraph">
<p>Η μορφή εμφάνισης των νέων περιεχομένων του αρχείου ή ο προσδιορισμός ενός τροποποιημένου αρχείου με τα νέα περιεχόμενα είναι ο εξής:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>M 644 inline path/to/file
data (size)
(file contents)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Εδώ, <code>644</code> είναι ο τρόπος λειτουργίας (αν έχουμε εκτελέσιμα αρχεία, θα πρέπει να τα εντοπίσουμε και να θέσουμε τρόπο λειτουργίας <code>755</code> αντί <code>644</code>), και η <code>inline</code> λέει ότι θα παραθέσουμε το περιεχόμενο αμέσως μετά από αυτήν τη γραμμή.
Η μέθοδος <code>inline_data</code> μοιάζει με κάτι τέτοιο:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">def inline_data(file, code = 'M', mode = '644')
  content = File.read(file)
  puts "#{code} #{mode} inline #{file}"
  export_data(content)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Επαναχρησιμοποιούμε τη μέθοδο <code>export_data</code> που ορίσαμε νωρίτερα, επειδή είναι ο ίδιος τρόπος με αυτόν που καθορίσαμε τα δεδομένα του μηνύματος αποστολής.</p>
</div>
<div class="paragraph">
<p>Το τελευταίο πράγμα που πρέπει να κάνουμε είναι να επιστρέψουμε το τρέχον σημάδι ώστε να μπορεί να μεταβιβαστεί στην επόμενη επανάληψη:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">return mark</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Εάν τρέχουμε σε Windows, θα πρέπει οπωσδήποτε να προσθέτουμε ένα επιπλέον βήμα.
Όπως αναφέρθηκε προηγουμένως, τα Windows χρησιμοποιούν CRLF για χαρακτήρες νέας γραμμής ενώ η <code>git fast-import</code> αναμένει μόνο LF.
Για να αντιμετωπίσουμε αυτό το πρόβλημα και να κάνουμε την <code>git fast-import</code> ευτυχισμένη, πρέπει πρέπει να πούμε στη Ruby να χρησιμοποιήσει τον LF αντί του CRLF:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">$stdout.binmode</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Αυτό ήταν.
Ακολουθεί ολόκληρο το script:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">#!/usr/bin/env ruby

$stdout.binmode
$author = "John Doe &lt;john@example.com&gt;"

$marks = []
def convert_dir_to_mark(dir)
    if !$marks.include?(dir)
        $marks &lt;&lt; dir
    end
    ($marks.index(dir)+1).to_s
end


def convert_dir_to_date(dir)
    if dir == 'current'
        return Time.now().to_i
    else
        dir = dir.gsub('back_', '')
        (year, month, day) = dir.split('_')
        return Time.local(year, month, day).to_i
    end
end

def export_data(string)
    print "data #{string.size}\n#{string}"
end

def inline_data(file, code='M', mode='644')
    content = File.read(file)
    puts "#{code} #{mode} inline #{file}"
    export_data(content)
end

def print_export(dir, last_mark)
    date = convert_dir_to_date(dir)
    mark = convert_dir_to_mark(dir)

    puts 'commit refs/heads/master'
    puts "mark :#{mark}"
    puts "committer #{$author} #{date} -0700"
    export_data("imported from #{dir}")
    puts "from :#{last_mark}" if last_mark

    puts 'deleteall'
    Dir.glob("**/*").each do |file|
        next if !File.file?(file)
        inline_data(file)
    end
    mark
end


# Βρόχος επανάληψης σε όλους τους υποκαταλόγους
last_mark = nil
Dir.chdir(ARGV[0]) do
    Dir.glob("*").each do |dir|
        next if File.file?(dir)

        # Μετακινήσου στον κατάλογο-στόχο
        Dir.chdir(dir) do
            last_mark = print_export(dir, last_mark)
        end
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Αν εκτελέσουμε αυτό το script, θα πάρουμε περιεχόμενο που μοιάζει με αυτό:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ ruby import.rb /opt/import_from
commit refs/heads/master
mark :1
committer John Doe &lt;john@example.com&gt; 1388649600 -0700
data 29
imported from back_2014_01_02deleteall
M 644 inline README.md
data 28
# Hello

This is my readme.
commit refs/heads/master
mark :2
committer John Doe &lt;john@example.com&gt; 1388822400 -0700
data 29
imported from back_2014_01_04from :1
deleteall
M 644 inline main.rb
data 34
#!/bin/env ruby

puts "Hey there"
M 644 inline README.md
(...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Για να τρέξουμε τον εισαγωγέα, παροχετεύουμε αυτήν την έξοδο μέσω της <code>git fast-import</code> ενώ βρισκόμαστε στον κατάλογο Git που θέλουμε να εισάγουμε.
Μπορούμε να δημιουργήσουμε ένα νέο κατάλογο και στη συνέχεια να εκτελέσουμε την <code>git init</code> μέσα σε αυτόν για να δημιουργήσουμε ένα σημείο εκκίνησης και στη συνέχεια να εκτελέσουμε το script μας:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git init
Initialized empty Git repository in /opt/import_to/.git/
$ ruby import.rb /opt/import_from | git fast-import
git-fast-import statistics:
---------------------------------------------------------------------
Alloc'd objects:       5000
Total objects:           13 (         6 duplicates                  )
      blobs  :            5 (         4 duplicates          3 deltas of          5 attempts)
      trees  :            4 (         1 duplicates          0 deltas of          4 attempts)
      commits:            4 (         1 duplicates          0 deltas of          0 attempts)
      tags   :            0 (         0 duplicates          0 deltas of          0 attempts)
Total branches:           1 (         1 loads     )
      marks:           1024 (         5 unique    )
      atoms:              2
Memory total:          2344 KiB
       pools:          2110 KiB
     objects:           234 KiB
---------------------------------------------------------------------
pack_report: getpagesize()            =       4096
pack_report: core.packedGitWindowSize = 1073741824
pack_report: core.packedGitLimit      = 8589934592
pack_report: pack_used_ctr            =         10
pack_report: pack_mmap_calls          =          5
pack_report: pack_open_windows        =          2 /          2
pack_report: pack_mapped              =       1457 /       1457
---------------------------------------------------------------------</code></pre>
</div>
</div>
<div class="paragraph">
<p>Όπως μπορούμε να δούμε, όταν ολοκληρώενται με επιτυχία, μας δίνει μια κάμποσα στατιστικά για το τι έχει επιτύχει.
Σε αυτήν την περίπτωση, εισάγαμε 13 αντικείμενα συνολικά για 4 υποβολές σε 1 υποκατάστημα.
Τώρα, μπορούμε να εκτελέσουμε την <code>git log</code> για να δούμε το νέο μας ιστορικό:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log -2
commit 3caa046d4aac682a55867132ccdfbe0d3fdee498
Author: John Doe &lt;john@example.com&gt;
Date:   Tue Jul 29 19:39:04 2014 -0700

    imported from current

commit 4afc2b945d0d3c8cd00556fbe2e8224569dc9def
Author: John Doe &lt;john@example.com&gt;
Date:   Mon Feb 3 01:00:00 2014 -0700

    imported from back_2014_02_03</code></pre>
</div>
</div>
<div class="paragraph">
<p>Αυτό ήταν! Ένα ωραίο, καθαρό αποθετήριο Git.
Είναι σημαντικό να σημειώσουμε ότι τίποτα δεν έχει ανακτηθεί —αρχικά δεν έχουμε αρχεία στον κατάλογο εργασίας μας.
Για να τα πάρουμε, πρέπει να επαναφέρουμε τον κλάδο μας στο σημείο όπου είναι τώρα ο <code>master</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ ls
$ git reset --hard master
HEAD is now at 3caa046 imported from current
$ ls
README.md main.rb</code></pre>
</div>
</div>
<div class="paragraph">
<p>Μπορούμε να κάνουμε πολλά περισσότερα με το εργαλείο <code>fast-import</code> —να χειριστούμε διαφορετικά είδη, δυαδικά δεδομένα, πολλαπλούς κλάδους και συγχωνεύσεις, ετικέτες, δείκτες προόδου και πολλά άλλα.
Ορισμένα παραδείγματα πιο σύνθετων σεναρίων είναι διαθέσιμα στον κατάλογο <code>contrib/fast-import</code> του πηγαίου κώδικα του Git.</p>
</div>
</div>
<div id="nav"><a href="{{ page.book.section.previous | relative_url }}">prev</a> | <a href="{{ page.book.section.next | relative_url }}">next</a></div>