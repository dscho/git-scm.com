---
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: gr
  chapter:
    title: Εσωτερική λειτουργία του Git
    number: 10
  section:
    title: Πρωτόκολλα μεταφοράς
    number: 6
    cs_number: '10.6'
    previous: book/gr/v2/Εσωτερική-λειτουργία-του-Git-Τα-refspec
    next: book/gr/v2/Εσωτερική-λειτουργία-του-Git-Διατήρηση-και-ανάκτηση-δεδομένων
title: Git - Πρωτόκολλα μεταφοράς

---
<h2 id="_πρωτόκολλα_μεταφοράς">Πρωτόκολλα μεταφοράς</h2>
<div class="paragraph">
<p>Το Git μπορεί να μεταφέρει δεδομένα μεταξύ δύο αποθετηρίων με δύο βασικούς τρόπους: το χαζό (“dumb”) πρωτόκολλο και το έξυπνο (“smart”) πρωτόκολλο.
Αυτή η ενότητα θα καλύψει γρήγορα τον τρόπο λειτουργίας αυτών των δύο βασικών πρωτοκόλλων.</p>
</div>
<div class="sect3">
<h3 id="_το_χαζό_πρωτόκολλο">Το χαζό πρωτόκολλο</h3>
<div class="paragraph">
<p>Εάν ρυθμίζουμε ένα αποθετήριο που θα εμφανίζεται μόνο για ανάγνωση μέσω HTTP, το χαζό πρωτόκολλο είναι πιθανότατα αυτό που θα χρησιμοποιηθεί.
Αυτό το πρωτόκολλο ονομάζεται “χαζό” επειδή δεν απαιτεί ειδικό κώδικα Git στην πλευρά του διακομιστή κατά τη διάρκεια της διαδικασίας μεταφοράς· η διαδικασία ανάκτησης είναι μια σειρά αιτημάτων <code>GET</code> HTTP, όπου ο πελάτης μπορεί να αναλάβει τη διάταξη του αποθετηρίου Git στον διακομιστή.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Το χαζό πρωτόκολλο χρησιμοποιείται σπάνια πλέον.
Παρουσιάζει δυσκολίες όσον αφορά στην ασφάλεια και την ιδιωτικότητα, έτσι ώστε οι περισσότεροι κεντρικοί υπολογιστές Git (τόσο στο cloud όσο και τοπικά) αρνούνται να το χρησιμοποιήσουν.
Συνήθως συνιστάται να χρησιμοποιήσουμε το έξυπνο πρωτόκολλο, το οποίο περιγράφουμε παρακάτω.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Ας ακολουθήσουμε τη διαδικασία <code>http-fetch</code> για τη βιβλιοθήκη simplegit:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clone http://server/simplegit-progit.git</code></pre>
</div>
</div>
<div class="paragraph">
<p>Το πρώτο πράγμα που κάνει αυτή η εντολή είναι να κατεβάσει το αρχείο <code>info/refs</code>.
Αυτό το αρχείο γράφεται με την εντολή <code>update-server-info</code>, γι' αυτό πρέπει να το ενεργοποιήσουμε ως άγκιστρο <code>post-receive</code> για να λειτουργήσει σωστά η μεταφορά HTTP:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>=&gt; GET info/refs
ca82a6dff817ec66f44342007202690a93763949     refs/heads/master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Τώρα έχουμε μια λίστα με τις απομακρυσμένες αναφορές και τους αριθμούς SHA-1.
Στη συνέχεια, αναζητάμε ποια είναι η αναφορά του HEAD, ώστε να ξέρουμε τι να ελέγξουμε όταν τελειώσουμε:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>=&gt; GET HEAD
ref: refs/heads/master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Θα πρέπει να μεταβούμε στον κλάδο <code>master</code>, όταν ολοκληρώσουμε τη διαδικασία.
Σε αυτό το σημείο, είμαστε έτοιμοι να ξεκινήσουμε τη διαδικασία.
Επειδή το σημείο εκκίνησής μας είναι το αντικείμενο υποβολής <code>ca82a6</code> που είδαμε στο αρχείο <code>info/refs</code>, ξεκινάμε με την ανάκτησή του:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>=&gt; GET objects/ca/82a6dff817ec66f44342007202690a93763949
(179 bytes of binary data)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Μας επιστρέφεται ένα αντικείμενο —το αντικείμενο βρίσκεται σε χαλαρή μορφή στον διακομιστή και το έχουμε ανακτήσει με ένα στατικό αίτημα GET HTTP.
Μπορούμε να το αποσυμπιέσουμε με το zlib, να αφαιρέσουμε την κεφαλίδα και να εξετάσουμε το περιεχόμενο της υποβολής:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git cat-file -p ca82a6dff817ec66f44342007202690a93763949
tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
parent 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
author Scott Chacon &lt;schacon@gmail.com&gt; 1205815931 -0700
committer Scott Chacon &lt;schacon@gmail.com&gt; 1240030591 -0700

changed the version number</code></pre>
</div>
</div>
<div class="paragraph">
<p>Έπειτα, έχουμε δύο επιπλέον αντικείμενα να ανακτήσουμε —το <code>cfda3b</code>, το δέντρο του περιεχομένου του οποίου την υποβολή μόλις ανακτήσαμε· και το <code>085bb3</code>, που είναι η μητρική υποβολή:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>=&gt; GET objects/08/5bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
(179 bytes of data)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Αυτό μας δίνει το επόμενο αντικείμενο υποβολής μας.
Παίρνουμε το αντικείμενο δέντρου:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>=&gt; GET objects/cf/da3bf379e4f8dba8717dee55aab78aef7f4daf
(404 - Not Found)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ωχ! Φαίνεται ότι το αντικείμενο δέντρου δεν είναι σε χαλαρή μορφή στον διακομιστή, οπότε παίρνουμε πίσω μια απάντηση 404.
Υπάρχουν δύο λόγοι γι' αυτό —το αντικείμενο μπορεί να βρίσκεται σε ένα εναλλακτικό αποθετήριο ή μπορεί να είναι σε ένα πακέτο σε αυτό το αποθετήριο.
Το Git ελέγχει πρώτα για καταχωρημένες εναλλακτικές:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>=&gt; GET objects/info/http-alternates
(empty file)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Αν αυτό μας επιστρέψει με μια λίστα εναλλακτικών διευθύνσεων URL, το Git ελέγχει τα χαλαρά αρχεία και πακέτα εκεί —αυτός είναι ένας ωραίος μηχανισμός για έργα που είναι διχάλες το ένα του άλλου για να μοιράζονται αντικείμενα στον δίσκο.
Ωστόσο, επειδή σε αυτήν την περίπτωση δεν επιστρέφονται εναλλακτικές, το αντικείμενο πρέπει να είναι ένα πακέτο.
Για να δούμε τι πακέτα είναι διαθέσιμα σε αυτόν τον διακομιστή, πρέπει να πάρουμε το αρχείο <code>objects/info/packs</code>, το οποίο περιέχει μια λίστα των πακέτων (που επίσης δημιουργείται από την <code>update-server-info</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>=&gt; GET objects/info/packs
P pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack</code></pre>
</div>
</div>
<div class="paragraph">
<p>Υπάρχει μόνο ένα πακέτο στον διακομιστή, οπότε το αντικείμενο μας είναι προφανώς εκεί, αλλά θα ελέγξουμε το αρχείο ευρετηρίου για να βεβαιωθούμε.
Αυτό είναι επίσης χρήσιμο εάν έχουμε πολλά πακέτα στον διακομιστή, έτσι ώστε να μπορούμε να δούμε ποιο πακέτο περιέχει το αντικείμενο που χρειαζόμαστε:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>=&gt; GET objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.idx
(4k of binary data)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Τώρα που έχουμε το ευρετήριο πακέτων, μπορούμε να δούμε αν το αντικείμενο είναι μέσα σε αυτό —επειδή το ευρετήριο παραθέτει τους αριθμούς SHA-1s των αντικειμένων που περιέχονται στο πακέτο και τη μετατόπιση (offset) σε αυτά τα αντικείμενα.
Το αντικείμενο μας είναι εκεί, συνεπώς προχωρούμε και παίρνουμε ολόκληρο το πακέτο:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>=&gt; GET objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack
(13k of binary data)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Έχουμε το αντικείμενο του δέντρου μας, έτσι συνεχίζουμε να προχωρούμε στις υποβολές μας.
Όλες είναι επίσης μέσα στο αρχείο πακέτου που μόλις κατεβάσαμε, οπότε δεν χρειάζεται να κάνουμε άλλα αιτήματα στον διακομιστή μας.
Το Git ανακτήσει ένα αντίγραφο εργασίας του κλάδου <code>master</code> στο οποίο έδειχνε η αναφορά HEAD που κατεβάσαμε στην αρχή.</p>
</div>
</div>
<div class="sect3">
<h3 id="_το_έξυπνο_πρωτόκολλο">Το έξυπνο πρωτόκολλο</h3>
<div class="paragraph">
<p>Το χαζό πρωτόκολλο είναι απλό, αλλά λίγο αναποτελεσματικό και δεν μπορεί να χειριστεί τη γραφή δεδομένων από τον πελάτη στον διακομιστή.
Το έξυπνο πρωτόκολλο είναι μια πιο κοινή μέθοδος μεταφοράς δεδομένων, αλλά απαιτεί μια διαδικασία στο απομακρυσμένο άκρο που είναι έξυπνη για το Git —μπορεί να διαβάσει τα τοπικά δεδομένα, να καταλάβει τι έχει και τι χρειάζεται ο πελάτης και να δημιουργήσει ένα προσαρμοσμένο πακέτο για αυτόν.
Υπάρχουν δύο ομάδες διαδικασιών για τη μεταφορά δεδομένων: ένα ζεύγος για την αποστολή δεδομένων και ένα ζεύγος για τη λήψη δεδομένων.</p>
</div>
<div class="sect4">
<h4 id="_αποστολή_δεδομένων">Αποστολή δεδομένων</h4>
<div class="paragraph">
<p> 
Για να μεταφορτώσει δεδομένα σε μια απομακρυσμένη τοποθεσία, το Git χρησιμοποιεί τις διαδικασίες <code>send-pack</code> και <code>receive-pack</code>.
Η διαδικασία <code>send-pack</code> εκτελείται στον πελάτη και συνδέεται με μια διαδικασία <code>receive-pack</code> στην απομακρυσμένη πλευρά.</p>
</div>
<div class="sect5">
<h6 id="_ssh">SSH</h6>
<div class="paragraph">
<p>Για παράδειγμα, ας πούμε ότι τρέχουμε την <code>git push master master</code> στο έργο μας, και ως <code>origin</code> ορίζεται μια διεύθυνση URL που χρησιμοποιεί το πρωτόκολλο SSH.
Το Git ενεργοποιεί τη διαδικασία <code>send-pack</code>, η οποία ενεργοποιεί μια σύνδεση μέσω SSH στον διακομιστή μας.
Προσπαθεί να εκτελέσει μια εντολή στον απομακρυσμένο διακομιστή μέσω μιας κλήσης SSH που μοιάζει με κάτι τέτοιο:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ ssh -x git@server "git-receive-pack 'simplegit-progit.git'"
00a5ca82a6dff817ec66f4437202690a93763949 refs/heads/master report-status \
	delete-refs side-band-64k quiet ofs-delta \
	agent=git/2:2.1.1+github-607-gfba4028 delete-refs
0000</code></pre>
</div>
</div>
<div class="paragraph">
<p>Η εντολή <code>git-receive-pack</code> αποκρίνεται αμέσως με μία γραμμή για κάθε αναφορά που έχει αυτήν τη στιγμή —την περίπτωση αυτή, μόνο τον κλάδο <code>master</code> και τον SHA-1 του.
Η πρώτη γραμμή περιέχει επίσης μια λίστα με τις δυνατότητες του διακομιστή (εδώ, <code>status-report</code>, <code>delete-refs</code> και μερικές άλλες, συμπεριλαμβανομένου του αναγνωριστικού του πελάτη).</p>
</div>
<div class="paragraph">
<p>Κάθε γραμμή ξεκινάει με μια τετραψήφια δεκαξαδική τιμή που καθορίζει πόσο μεγάλο είναι το υπόλοιπο της γραμμής.
Η πρώτη γραμμή ξεκινά με 005b, η οποία είναι δεκαεξαδική μορφή του 91, πράγμα που σημαίνει ότι 91 bytes παραμένουν στη γραμμή αυτή.
Η επόμενη γραμμή ξεκινά με 003e, δηλαδή 62, οπότε διαβάζουμε τα υπόλοιπα 62 byte.
Η επόμενη γραμμή είναι 0000, πράγμα που σημαίνει ότι ο διακομιστής τελειώσε με τη λίστα αναφοράς.</p>
</div>
<div class="paragraph">
<p>Τώρα που γνωρίζει την κατάσταση του διακομιστή, η διαδικασία <code>send-pack</code> καθορίζει ποιες υποβολές έχει που δεν έχει ο διακομιστής.
Για κάθε αναφορά που θα ενημερώσει αυτή η ώθηση, η διαδικασία <code>send-pack</code> αναφέρει αυτήν  την πληροφορία στη διαδικασία <code>receive-pack</code>.
Για παράδειγμα, εάν ενημερώνουμε τον κλάδο <code>master</code> και προσθέτουμε έναν κλάδο <code>experiment</code>, η απάντηση <code>send-pack</code> θα μοιάζει με κάτι σαν αυτό:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>0076ca82a6dff817ec66f44342007202690a93763949 15027957951b64cf874c3557a0f3547bd83b3ff6 \
	refs/heads/master report-status
006c0000000000000000000000000000000000000000 cdfdb42577e2506715f8cfeacdbabc092bf63e8d \
	refs/heads/experiment
0000</code></pre>
</div>
</div>
<div class="paragraph">
<p>Το Git στέλνει μια γραμμή για κάθε αναφορά που ενημερώνουμε με το μήκος της γραμμής, τον παλιό SHA-1, τον νέο SHA-1 και την αναφορά που ενημερώνεται.
Η πρώτη γραμμή έχει επίσης τις δυνατότητες του πελάτη.
Αν η τιμή SHA-1 αποτελείται μόνο από 0, αυτό σημαίνει ότι δεν υπήρχε τίποτα πριν —επειδή προσθέτουμε την αναφορά του <code>experiment</code>.
Εάν διαγράψαμε μια αναφορά, θα δούμε το αντίθετο: όλα τα <em>0</em> στη δεξιά πλευρά.</p>
</div>
<div class="paragraph">
<p>Στη συνέχεια, ο υπολογιστής-πελάτης στέλνει ένα πακέτο από όλα τα αντικείμενα που δεν έχει ακόμα ο διακομιστής.
Τέλος, ο διακομιστής αποκρίνεται με μια ένδειξη επιτυχίας (ή αποτυχίας):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>000eunpack ok</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_https">HTTP(S)</h6>
<div class="paragraph">
<p>Αυτή η διαδικασία είναι ως επί το πλείστον η ίδια σε σχέση με το HTTP, αν και η χειραψία είναι λίγο διαφορετική.
Η σύνδεση ξεκινά με αυτό το αίτημα:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>=&gt; GET http://server/simplegit-progit.git/info/refs?service=git-receive-pack
001f# service=git-receive-pack
00ab6c5f0e45abd7832bf23074a333f739977c9e8188 refs/heads/master report-status \
	delete-refs side-band-64k quiet ofs-delta \
	agent=git/2:2.1.1~vmg-bitmaps-bugaloo-608-g116744e
0000</code></pre>
</div>
</div>
<div class="paragraph">
<p>Αυτό είναι το τέλος της πρώτης ανταλλαγής πελάτη-εξυπηρετητή.
Στη συνέχεια ο πελάτης υποβάλλει ένα άλλο αίτημα, αυτήν τη φορά ένα <code>POST</code>, με τα δεδομένα που παρέχει το <code>git-upload-pack</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>=&gt; POST http://server/simplegit-progit.git/git-receive-pack</code></pre>
</div>
</div>
<div class="paragraph">
<p>Το αίτημα <code>POST</code> περιλαμβάνει την έξοδο <code>send-pack</code> και το πακέτο ως το ωφέλιμο φορτίο του.
Ο διακομιστής τότε υποδεικνύει επιτυχία ή αποτυχία με την απόκριση HTTP.</p>
</div>
</div>
</div>
<div class="sect4">
<h4 id="_λήψη_δεδομένων">Λήψη δεδομένων</h4>
<div class="paragraph">
<p> 
Όταν κάνουμε λήψη δεδομένων, εμπλέκονται οι διαδικασίες <code>fetch-pack</code> και <code>upload-pack</code>.
Ο πελάτης ξεκινά μια διαδικασία <code>fetch-pack</code> που συνδέεται με μια διαδικασία <code>upload-pack</code> στην απομακρυσμένη πλευρά για να διαπραγματευτεί ποια δεδομένα θα ληφθούν.</p>
</div>
<div class="sect5">
<h6 id="_ssh_2">SSH</h6>
<div class="paragraph">
<p>Αν κάνουμε την ανάκτηση μέσω SSH, η <code>fetch-pack</code> τρέχει κάτι τέτοιο:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ ssh -x git@server "git-upload-pack 'simplegit-progit.git'"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Αφού η <code>fetch-pack</code> συνδεθεί, η <code>upload-pack</code> επιστρέφει κάτι σαν αυτό:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>00dfca82a6dff817ec66f44342007202690a93763949 HEAD□multi_ack thin-pack \
	side-band side-band-64k ofs-delta shallow no-progress include-tag \
	multi_ack_detailed symref=HEAD:refs/heads/master \
	agent=git/2:2.1.1+github-607-gfba4028
003fe2409a098dc3e53539a9028a94b6224db9d6a6b6 refs/heads/master
0000</code></pre>
</div>
</div>
<div class="paragraph">
<p>Αυτό είναι πολύ παρόμοιο με αυτό που αποκρίνεται η <code>receive-pack</code>, αλλά οι δυνατότητες είναι διαφορετικές.
Επιπλέον, στέλνει πίσω αυτό στο οποίο δείχνει ο HEAD (<code>symref=HEAD:refs/heads/master</code>) έτσι ώστε ο πελάτης να ξέρει τι να ελέγξει εάν αυτό είναι κλώνος.</p>
</div>
<div class="paragraph">
<p>Σε αυτό το σημείο, η διαδικασία <code>fetch-pack</code> εξετάζει ποια αντικείμενα έχει και ανταποκρίνεται με τα αντικείμενα που χρειάζεται, στέλνοντας <code>want</code> και κατόπιν το SHA-1 που θέλει.
Αποστέλλει όλα τα αντικείμενα που έχει ήδη με <code>have</code> και στη συνέχεια το SHA-1.
Στο τέλος αυτής της λίστας, γράφει <code>done</code> ώστε να εκκινήσει τη διαδικασία <code>upload-pack</code> και η τελευταία να ξεκινήσει να στέλνει το πακέτο με τα δεδομένα που χρειάζεται:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>003cwant ca82a6dff817ec66f44342007202690a93763949 ofs-delta
0032have 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
0009done
0000</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_https_2">HTTP(S)</h6>
<div class="paragraph">
<p>Η χειραψία για μια λειτουργία ανάκτησης απαιτεί δύο αιτήματα HTTP.
Το πρώτο είναι ένα <code>GET</code> στο ίδιο σημείο σύνδεσης που χρησιμοποιείται στο χαζό πρωτόκολλο:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>=&gt; GET $GIT_URL/info/refs?service=git-upload-pack
001e# service=git-upload-pack
00e7ca82a6dff817ec66f44342007202690a93763949 HEAD□multi_ack thin-pack \
	side-band side-band-64k ofs-delta shallow no-progress include-tag \
	multi_ack_detailed no-done symref=HEAD:refs/heads/master \
	agent=git/2:2.1.1+github-607-gfba4028
003fca82a6dff817ec66f44342007202690a93763949 refs/heads/master
0000</code></pre>
</div>
</div>
<div class="paragraph">
<p>Αυτό είναι πολύ παρόμοιο με την κλήση του `git-upload-pack 'μέσω μιας σύνδεσης SSH, αλλά η δεύτερη ανταλλαγή γίνεται ως ξεχωριστό αίτημα:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>=&gt; POST $GIT_URL/git-upload-pack HTTP/1.0
0032want 0a53e9ddeaddad63ad106860237bbf53411d11a7
0032have 441b40d833fdfa93eb2908e52742248faf0ee993
0000</code></pre>
</div>
</div>
<div class="paragraph">
<p>Επαναλαμβάνουμε ότι αυτή είναι η ίδια μορφή όπως παραπάνω.
Η απάντηση σε αυτό το αίτημα υποδηλώνει επιτυχία ή αποτυχία και περιλαμβάνει το πακέτο.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_περίληψη_πρωτοκόλλων">Περίληψη πρωτοκόλλων</h3>
<div class="paragraph">
<p>Αυτή η ενότητα περιέχει μια πολύ βασική επισκόπηση των πρωτοκόλλων μεταφοράς.
Το πρωτόκολλο περιλαμβάνει πολλά άλλα χαρακτηριστικά, όπως δυνατότητες <code>multi_ack</code> ή <code>sideband</code>, αλλά η κάλυψή τους είναι εκτός του σκοπού αυτού του βιβλίου.
Προσπαθήσαμε να πάρουμε μια αίσθηση του γενικού πάρε-δώσε μεταξύ πελάτη και διακομιστή· για περισσότερες γνώσεις από αυτό, μάλλον χρειάζεται να ρίξουμε μια ματιά στον πηγαίο κώδικα του Git.</p>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>