---
category: manual
section: documentation
subsection: manual
title: Git - git-rebase Documentation
docname: git-rebase
lang: pt_BR
aliases:
- "/docs/git-rebase/pt_BR"
- "/docs/git-rebase/pt_BR.html"

---
<div class="sect1">
<h2 id="_nome"><a class="anchor" href="#_nome"></a>NOME</h2>
<div class="sectionbody">
<div class="paragraph">
<p>git-rebase - Reaplique os commits em cima do topo de outra base</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resumo"><a class="anchor" href="#_resumo"></a>RESUMO</h2>
<div class="sectionbody">
<div class="verseblock">
<pre class="content"><em>git rebase</em> [-i | --interactive] [&lt;opções&gt;] [--exec &lt;cmd&gt;]
	[--onto &lt;nova-base&gt; | --keep-base] [&lt;upstream&gt; [&lt;ramo&gt;]]
<em>git rebase</em> [-i | --interactive] [&lt;opções&gt;] [--exec &lt;cmd&gt;] [--onto &lt;nova-base&gt;]
	--root [&lt;ramo&gt;]
<em>git rebase</em> (--continue | --skip | --abort | --quit | --edit-todo | --show-current-patch)</pre>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_descrição"><a class="anchor" href="#_descrição"></a>DESCRIÇÃO</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Caso o <code>&lt;ramo&gt;</code> seja utilizado, o comando <code>git rebase</code> executará um <code>git switch &lt;ramo&gt;</code> automaticamente antes de fazer qualquer outra coisa. Caso contrário, ele permanecerá no ramo atual.</p>
</div>
<div class="paragraph">
<p>Caso o <code>&lt;upstream&gt;</code> não seja definido, as opções "upstream" configuradas em <code>branch.&lt;nome&gt;.remote</code> e no <code>branch.&lt;nome&gt;.merge</code> serão utilizadas (para mais detalhes consulte <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>), assim como será assumida a opção <code>--fork-point</code>. Caso você não esteja atualmente em nenhuma ramificação ou se a ramificação atual não tiver um "upstream" configurado, o "rebase" será cancelado.</p>
</div>
<div class="paragraph">
<p>Todas as alterações feitas através de commits no ramo atual, mas que não estão na <code>&lt;upstream&gt;</code>, são salvas numa área temporária. Este é o mesmo conjunto dos commits que seriam exibidos por <code>git log &lt;upstream&gt;..HEAD</code>; ou pelo comando <code>git log 'fork_point'..HEAD</code>, caso <code>--fork-point</code> esteja ativo (veja a descrição em <code>--fork-point</code> abaixo); ou através do <code>git log HEAD</code>, caso a opção <code>--root</code> for seja utilizada.</p>
</div>
<div class="paragraph">
<p>A ramificação atual é redefinida para <code>&lt;upstream&gt;</code> ou <code>&lt;newbase&gt;</code> caso a opção <code>--onto</code> seja utilizada. Isso tem exatamente o mesmo efeito que <code>git reset --hard &lt;upstream&gt;</code> (ou <code>&lt;newbase&gt;</code>). O <code>ORIG_HEAD</code> está definido para apontar no cume do ramo antes da redefinição.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Não é garantido que <code>ORIG_HEAD</code> ainda aponte para o cume de uma ramificação anterior no final do "rebase" caso os outros comandos que escrevem essa pseudo-ref (<code>git reset</code> por exemplo) sejam usados durante o "rebase". O cume da ramificação anterior, no entanto, é acessível usando o "reflog" da ramificação atual (ou seja, <code>@{1}</code>, consulte <a href='{{< relurl "docs/gitrevisions/pt_BR" >}}'>gitrevisions[7]</a>).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Os commits que foram salvos anteriormente na área temporária são reaplicadas no ramo atual, uma por uma e em ordem. Observe que quaisquer commits no <code>HEAD</code> que introduzam as mesmas alterações textuais que um commit no <code>HEAD..&lt;upstream&gt;</code> são omitidas (ou seja, um patch já aceito na inicial com uma mensagem de commit ou carimbo de data e hora diferente, serão ignorados).</p>
</div>
<div class="paragraph">
<p>É possível que uma falha da mesclagem impeça que este processo seja completamente automático. Você terá que resolver qualquer falha da mesclagem e executar o comando <code>git rebase --continue</code>. Outra opção é ignorar o commit que causou a falha da mesclagem com o comando <code>git rebase --skip</code>. Para verificar o &lt;ramo&gt; original e remover os arquivos de trabalho <code>.git/rebase-apply</code>, utilize o comando <code>git rebase --abort</code>.</p>
</div>
<div class="paragraph">
<p>Suponha que o seguinte histórico exista e que o ramo atual seja "topic":</p>
</div>
<div class="listingblock">
<div class="content">
<pre>          A---B---C topic
         /
    D---E---F---G master</pre>
</div>
</div>
<div class="paragraph">
<p>A partir deste ponto, o resultado de um dos seguintes comandos:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>git rebase master
git rebase master topic</pre>
</div>
</div>
<div class="paragraph">
<p>seria:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>                  A'--B'--C' topic
                 /
    D---E---F---G master</pre>
</div>
</div>
<div class="paragraph">
<p><strong>OBSERVAÇÃO:</strong> Este último formulário é apenas uma abreviação de <code>git checkout topic</code>
seguido por <code>git rebase master</code>. Quando a reconstrução (rebase) sair do <code>topic</code> será
mantido o ramo que foi averiguado.</p>
</div>
<div class="paragraph">
<p>Caso a ramificação upstream já contiver uma alteração que você fez (porque você enviou um patch que foi aplicado na upstream por exemplo), então este commit será ignorado e avisos serão emitidos (caso <em>merge</em> seja utilizado). Por exemplo, executando o comando <code>git rebase master</code> no histórico a seguir (onde <code>A'</code> e <code>A</code> introduzem o mesmo conjunto de alterações, mas possuem informações diferentes de quem fez o commit):</p>
</div>
<div class="listingblock">
<div class="content">
<pre>          A---B---C topic
         /
    D---E---A'---F master</pre>
</div>
</div>
<div class="paragraph">
<p>vai resultar em:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>                   B'---C' topic
                  /
    D---E---A'---F master</pre>
</div>
</div>
<div class="paragraph">
<p>Aqui está como você transplantaria um ramo do tópico com base num ramo para outro, para fingir que você bifurcou o ramo do tópico deste último ramo, utilizando <code>rebase --onto</code>.</p>
</div>
<div class="paragraph">
<p>Primeiro, vamos supor que o seu <em>tópico</em> seja baseado no ramo <em>next</em>. Por exemplo, um recurso desenvolvido em <em>topic</em> depende de algumas funcionalidades encontradas em <em>next</em>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    o---o---o---o---o  master
         \
          o---o---o---o---o  next
                           \
                            o---o---o  topic</pre>
</div>
</div>
<div class="paragraph">
<p>Queremos criar um <em>tópico</em> bifurcado no ramo <em>master</em>; porque a funcionalidade da qual o <em>tópico</em> depende foi mesclado na ramificação <em>master</em> mais estável. Queremos que a nossa árvore fique assim:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    o---o---o---o---o  master
        |            \
        |             o'--o'--o'  topic
         \
          o---o---o---o---o  next</pre>
</div>
</div>
<div class="paragraph">
<p>Podemos conseguir isso utilizando o seguinte comando:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>git rebase --onto master next topic</pre>
</div>
</div>
<div class="paragraph">
<p>Um outro exemplo da opção <code>--onto</code> é reconstruir a fundação da parte de uma ramificação. Se tivermos a seguinte situação:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>                            H---I---J topicB
                           /
                  E---F---G  topicA
                 /
    A---B---C---D  master</pre>
</div>
</div>
<div class="paragraph">
<p>então o comando</p>
</div>
<div class="literalblock">
<div class="content">
<pre>git rebase --onto master topicA topicB</pre>
</div>
</div>
<div class="paragraph">
<p>resultaria em:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>                 H'--I'--J'  topicB
                /
                | E---F---G  topicA
                |/
    A---B---C---D  master</pre>
</div>
</div>
<div class="paragraph">
<p>É útil quando o <em>topicB</em> não depender do <em>topicA</em>.</p>
</div>
<div class="paragraph">
<p>Um intervalo dos commits também pode ser removido com a reconstrução <em>rebase</em>. Se tivermos a seguinte situação:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    E---F---G---H---I---J  topicA</pre>
</div>
</div>
<div class="paragraph">
<p>então o comando</p>
</div>
<div class="literalblock">
<div class="content">
<pre>git rebase --onto topicA~5 topicA~3 topicA</pre>
</div>
</div>
<div class="paragraph">
<p>resultaria na remoção dos commits <em>F</em> e <em>G</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    E---H'---I'---J'  topicA</pre>
</div>
</div>
<div class="paragraph">
<p>É útil caso <em>F</em> e <em>G</em> estejam de alguma forma com defeitos ou não deveriam fazer parte do <em>topicA</em>. Observe que o argumento para <code>--onto</code> e o parâmetro <code>&lt;upstream&gt;</code> podem ser qualquer <em>commit-ish</em> válido.</p>
</div>
<div class="paragraph">
<p>Em caso de conflito, o <code>git rebase</code> irá parar no primeiro commit problemático e deixar os marcadores de conflito na árvore. Você pode utilizar o <code>git diff</code> para localizar os marcadores (&lt;&lt;&lt;&lt;&lt;&lt;) e fazer edições para resolver o conflito. Para cada arquivo que você edita, é necessário informar ao Git que o conflito foi resolvido, normalmente isso seria feito com</p>
</div>
<div class="literalblock">
<div class="content">
<pre>git add &lt;nome-do-arquivo&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Depois de resolver o conflito manualmente e atualizar o índice com a resolução desejada, você pode continuar o processo de reconstrução com o comando</p>
</div>
<div class="literalblock">
<div class="content">
<pre>git rebase --continue</pre>
</div>
</div>
<div class="paragraph">
<p>Como alternativa, você pode desfazer o <em>git rebase</em> com</p>
</div>
<div class="literalblock">
<div class="content">
<pre>git rebase --abort</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_mais_opções"><a class="anchor" href="#_mais_opções"></a>MAIS OPÇÕES</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As opções nesta seção, não podem ser usadas com nenhuma outra opção, inclusive entre si:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-rebase---continue"> <a class="anchor" href="#git-rebase---continue"></a>--continue </dt>
<dd>
<p>Reinicie o processo de reformulação após resolver um conflito de mesclagem.</p>
</dd>
<dt class="hdlist1" id="git-rebase---skip"> <a class="anchor" href="#git-rebase---skip"></a>--skip </dt>
<dd>
<p>Reinicie o processo de reconstrução da fundação ignorando o patch atual.</p>
</dd>
<dt class="hdlist1" id="git-rebase---abort"> <a class="anchor" href="#git-rebase---abort"></a>--abort </dt>
<dd>
<p>Interrompa a operação de reconstrução da fundação e redefina o <code>HEAD</code> para o ramo original. Caso <code>&lt;ramo&gt;</code> seja informado quando a operação de reconstrução da fundação seja iniciada, o <code>HEAD</code> será redefinido para <code>&lt;ramo&gt;</code>. Caso contrário, o <code>HEAD</code> será redefinido para onde estava quando a operação de reconstrução foi iniciada.</p>
</dd>
<dt class="hdlist1" id="git-rebase---quit"> <a class="anchor" href="#git-rebase---quit"></a>--quit </dt>
<dd>
<p>Interrompa a operação de reconstrução, porém o <code>HEAD</code> não será redefinido para o ramo original. Como resultado, o índice e a árvore de trabalho também permanecem inalterados. Caso uma entrada temporária "stash" seja criada utilizando <code>--autostash</code>, ela será salva na lista "stash".</p>
</dd>
<dt class="hdlist1" id="git-rebase---edit-todo"> <a class="anchor" href="#git-rebase---edit-todo"></a>--edit-todo </dt>
<dd>
<p>Edite a lista de tarefas durante uma nova reconstrução interativa.</p>
</dd>
<dt class="hdlist1" id="git-rebase---show-current-patch"> <a class="anchor" href="#git-rebase---show-current-patch"></a>--show-current-patch </dt>
<dd>
<p>Exiba o patch atual numa nova recuperação interativa ou quando a nova recuperação for interrompida por causa de conflitos. É o equivalente ao <code>git show REBASE_HEAD</code>.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_opções"><a class="anchor" href="#_opções"></a>OPÇÕES</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-rebase---ontoltnova-basegt"> <a class="anchor" href="#git-rebase---ontoltnova-basegt"></a>--onto &lt;nova-base&gt; </dt>
<dd>
<p>Ponto de partida onde criar os novos commits. Caso a opção <code>--onto</code> não seja utilizada, o ponto inicial é <code>&lt;upstream&gt;</code>. Pode ser qualquer commit válido e não apenas um nome de um ramo já existente.</p>
<div class="paragraph">
<p>Como um caso especial, você pode utilizar "A...B" como um atalho para a base de mesclagem <em>A</em> e <em>B</em> caso haja exatamente uma base para mesclagem. Você pode deixar de fora no máximo um de <em>A</em> e <em>B</em>; nesse caso, a predefinição retorna para <code>HEAD</code>.</p>
</div>
</dd>
<dt class="hdlist1" id="git-rebase---keep-base"> <a class="anchor" href="#git-rebase---keep-base"></a>--keep-base </dt>
<dd>
<p>Defina o ponto de partida para criar os novos commits para a mesclagem base do <code>&lt;upstream&gt;</code> e <code>&lt;ramo&gt;</code>. Executando o comando <code>git rebase --keep-base &lt;upstream&gt; &lt;ramo&gt;</code> é o mesmo que executar o comando <code>git rebase --reapply-cherry-picks --no-fork-point --onto &lt;upstream&gt;...&lt;ramo&gt; &lt;upstream&gt; &lt;ramo&gt;</code>.</p>
<div class="paragraph">
<p>Esta opção é útil no caso onde se está desenvolvendo um recurso em cima de um ramo <em>upstream</em>. Enquanto o recurso está sendo trabalhado, o ramo <em>upstream</em> pode avançar e talvez não seja a melhor ideia continuar reconstruindo no topo do <em>upstream</em>, porém manter a base do commit como está. Como a base do commit permanece inalterado, esta opção implica no uso da opção <code>--reapply-cherry-picks</code> para evitar a perda dos commits.</p>
</div>
<div class="paragraph">
<p>Embora esta opção e o <code>--fork-point</code> encontrem a base da mesclagem entre <code>&lt;upstream&gt;</code> e <code>&lt;ramo&gt;</code>, esta opção utiliza a base da mesclagem como o <em>ponto inicial</em> onde os novos commits serão criados, enquanto <code>--fork-point</code> utiliza a mesclagem da base para determinar o <em>conjunto dos commits</em> que serão reconstruídos.</p>
</div>
<div class="paragraph">
<p>Consulte também a seção "OPÇÕES INCOMPATÍVEIS" logo abaixo.</p>
</div>
</dd>
<dt class="hdlist1" id="git-rebase-ltupstreamgt"> <a class="anchor" href="#git-rebase-ltupstreamgt"></a>&lt;upstream&gt; </dt>
<dd>
<p>Ramo upstream para fazer a comparação. Pode ser qualquer commit válido, não apenas um nome de uma ramo já existente. A predefinição retorna para "upstream" configurada para o ramo atual.</p>
</dd>
<dt class="hdlist1" id="git-rebase-ltramogt"> <a class="anchor" href="#git-rebase-ltramogt"></a>&lt;ramo&gt; </dt>
<dd>
<p>Ramo de trabalho; A predefinição retorna para <code>HEAD</code>.</p>
</dd>
<dt class="hdlist1" id="git-rebase---apply"> <a class="anchor" href="#git-rebase---apply"></a>--apply </dt>
<dd>
<p>Utilize estratégias para aplicar a reestruturação da base "rebase" (invocando <code>git-am</code> internamente). Esta opção poderá se tornar não operacional no futuro uma vez que o processo interno da mesclagem processe tudo o que a opção <em>--apply</em> fizer.</p>
<div class="paragraph">
<p>Consulte também a seção "OPÇÕES INCOMPATÍVEIS" logo abaixo.</p>
</div>
</dd>
<dt class="hdlist1" id="git-rebase---emptydropkeepask"> <a class="anchor" href="#git-rebase---emptydropkeepask"></a>--empty={drop,keep,ask} </dt>
<dd>
<p>Como lidar com commits que não estão vazias para iniciar e não são escolhas seletivas limpas de nenhum commit upstream, mas que ficam vazias após a reconstrução (porque elas já contêm um subconjunto de alterações na upstream). Com drop (a predefinição), os commits que ficam vazias são descartadas. Com keep, estes commits são mantidos. Com o comando <em>ask</em> (implícito através da opção <code>--interactive</code>), uma reconstrução <em>rebase</em> será interrompida quando um commit vazia for aplicado, permitindo que você escolha se elimina, edita mais arquivos ou apenas faça o commit das alterações vazias. Outras opções, como <code>--exec</code>, utilizarão a predefinição <em>drop</em>, a menos que a opção <code>-i</code>/<code>--interactive</code> seja usado explicitamente.</p>
<div class="paragraph">
<p>Observe que, os commits que começam vazios são mantidos (a menos que a opção <code>--no-keep-empty</code> seja utilizado) e os commits que são escolhas limpas (conforme determinado pelo comando <code>git log --cherry-mark ...</code>) são detectados e descartados como uma etapa preliminar (a menos que a opção <code>--reapply-cherry-picks</code> ou <code>--keep-base</code> seja utilizado).</p>
</div>
<div class="paragraph">
<p>Consulte também a seção "OPÇÕES INCOMPATÍVEIS" logo abaixo.</p>
</div>
</dd>
<dt class="hdlist1" id="git-rebase---no-keep-empty"> <a class="anchor" href="#git-rebase---no-keep-empty"></a>--no-keep-empty </dt>
<dt class="hdlist1" id="git-rebase---keep-empty"> <a class="anchor" href="#git-rebase---keep-empty"></a>--keep-empty </dt>
<dd>
<p>Não mantenha os commits que começam vazios antes da reconstrução (ou seja, que não alteram em nada a origem) no resultado. A predefinição é manter os commits que começam vazios, pois a criação destes commits requer passar o sinalizador de substituição <code>--allow-empty</code> para o comando <code>git commit</code>, significa que um usuário está criando intencionalmente tal commit e portanto, deseja mantê-lo.</p>
<div class="paragraph">
<p>A utilização desta opção é bem rara, já que você pode se livrar dos commits que iniciam vazios simplesmente executando uma reconstrução interativa e removendo as linhas correspondentes ao commit que você não quer. Está opção existe como um atalho por mera conveniência, para casos onde as ferramentas externas gerem muitos commits vazios e você que todos eles sejam removidos.</p>
</div>
<div class="paragraph">
<p>Para os commits que não começam vazios, mas ficam vazios após o <em>rebase</em>, consulte a opção <code>--empty</code>.</p>
</div>
<div class="paragraph">
<p>Consulte também a seção "OPÇÕES INCOMPATÍVEIS" logo abaixo.</p>
</div>
</dd>
<dt class="hdlist1" id="git-rebase---reapply-cherry-picks"> <a class="anchor" href="#git-rebase---reapply-cherry-picks"></a>--reapply-cherry-picks </dt>
<dt class="hdlist1" id="git-rebase---no-reapply-cherry-picks"> <a class="anchor" href="#git-rebase---no-reapply-cherry-picks"></a>--no-reapply-cherry-picks </dt>
<dd>
<p>Reaplique todas as escolhas seletivas que estejam limpas de qualquer commit "upstream" em vez inviabilizá-los por completo. (Então, caso estes commits se tornem vazios depois da reconstrução, por conter um subconjunto de alterações da "upstream", o comportamento em direção à eles é controlado através da opção <code>--empty</code>.)</p>
<div class="paragraph">
<p>Na ausência da opção <code>--keep-base</code> (ou se <code>--no-reapply-cherry-picks 'for fornecido), estes commits serão automaticamente eliminados. Como isso requer a leitura de todos os commits upstream, isso pode custar caro nos repositórios com uma grande quantidade de commits na upstream que precisam ser lidos. Ao utilizar `merge</code>, avisos serão emitidos para cada commit abandonado (a menos que <code>--quiet</code> seja usado). Os avisos também serão emitidos a menos que a variável <code>advice.skippedCherryPicks</code> seja definida como falso (consulte <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>).</p>
</div>
<div class="paragraph">
<p>A opção <code>--reapply-cherry-picks</code> permite que a reconstrução anteceda a leitura de todos os commits "upstream", melhorando muito o desempenho.</p>
</div>
<div class="paragraph">
<p>Consulte também a seção "OPÇÕES INCOMPATÍVEIS" logo abaixo.</p>
</div>
</dd>
<dt class="hdlist1" id="git-rebase---allow-empty-message"> <a class="anchor" href="#git-rebase---allow-empty-message"></a>--allow-empty-message </dt>
<dd>
<p>No-op. A reconstrução dos commits com uma mensagem vazia costumava falhar, esta opção substitui este comportamento, permitindo que os commits com mensagens vazias sejam refeitas. Agora os commits com uma mensagem vazia não causam mais a interrupção do "rebasing".</p>
<div class="paragraph">
<p>Consulte também a seção "OPÇÕES INCOMPATÍVEIS" logo abaixo.</p>
</div>
</dd>
<dt class="hdlist1" id="git-rebase--m"> <a class="anchor" href="#git-rebase--m"></a>-m </dt>
<dt class="hdlist1" id="git-rebase---merge"> <a class="anchor" href="#git-rebase---merge"></a>--merge </dt>
<dd>
<p>Usando estratégias de mesclagem para o rebase (padrão).</p>
<div class="paragraph">
<p>Observe que uma mesclagem de reconstrução (rebase) funciona repetindo cada commit da ramificação de trabalho na parte do topo <code>&lt;upstream&gt;</code>. Por esse motivo, quando ocorre um conflito na mesclagem, o lado relatado como <em>nosso</em> é a série até agora reformulada, começando com <code>&lt;upstream&gt;</code> e <em>deles</em> é o ramo de trabalho. Em outras palavras, os lados são trocados.</p>
</div>
<div class="paragraph">
<p>Consulte também a seção "OPÇÕES INCOMPATÍVEIS" logo abaixo.</p>
</div>
</dd>
<dt class="hdlist1" id="git-rebase--sltestratgiagt"> <a class="anchor" href="#git-rebase--sltestratgiagt"></a>-s &lt;estratégia&gt; </dt>
<dt class="hdlist1" id="git-rebase---strategyltestratgiagt"> <a class="anchor" href="#git-rebase---strategyltestratgiagt"></a>--strategy=&lt;estratégia&gt; </dt>
<dd>
<p>Use a estratégia de mesclagem informada, em vez do padrão <code>ort</code>. Isso implica no uso da opção <code>--merge</code>.</p>
<div class="paragraph">
<p>Como o <code>git rebase</code> repete cada commit do ramo de trabalho no cume do ramo &lt;upstream&gt; utilizando a estratégia informada, o uso da <code>nossa</code> estratégia simplesmente esvazia todos os patches do <code>&lt;ramo&gt;</code>, que faz pouco sentido.</p>
</div>
<div class="paragraph">
<p>Consulte também a seção "OPÇÕES INCOMPATÍVEIS" logo abaixo.</p>
</div>
</dd>
<dt class="hdlist1" id="git-rebase--Xltopo-da-estratgiagt"> <a class="anchor" href="#git-rebase--Xltopo-da-estratgiagt"></a>-X &lt;opção-da-estratégia&gt; </dt>
<dt class="hdlist1" id="git-rebase---strategy-optionltopo-da-estratgiagt"> <a class="anchor" href="#git-rebase---strategy-optionltopo-da-estratgiagt"></a>--strategy-option=&lt;opção-da-estratégia&gt; </dt>
<dd>
<p>Encaminhe a &lt;opção-de-estratégia&gt; para a estratégia da mesclagem. implica no uso da opção <code>--merge</code> e caso nenhuma estratégia tenha sido definida, <code>-s ort</code>. Observe a reversão do <em>ours</em> (nossos) e <em>theirs</em> (deles), conforme observado acima para a opção <code>-m</code>.</p>
<div class="paragraph">
<p>Consulte também a seção "OPÇÕES INCOMPATÍVEIS" logo abaixo.</p>
</div>
</dd>
<dt class="hdlist1" id="git-rebase---rerere-autoupdate"> <a class="anchor" href="#git-rebase---rerere-autoupdate"></a>--rerere-autoupdate </dt>
<dt class="hdlist1" id="git-rebase---no-rerere-autoupdate"> <a class="anchor" href="#git-rebase---no-rerere-autoupdate"></a>--no-rerere-autoupdate </dt>
<dd>
<p>Após o mecanismo rerere reutilizar uma resolução gravada no conflito atual para atualizar os arquivos na árvore de trabalho, permita que ele também atualize o índice com o resultado da resolução. A opção <code>--no-rerere-autoupdate</code> é uma boa maneira de verificar novamente o que o <code>rerere</code> fez e também detectar possíveis erros da mesclagem antes de enviar o resultado para o índice com um <code>git add</code> separado.</p>
</dd>
</dl>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-rebase--Sltkeyidgt"> <a class="anchor" href="#git-rebase--Sltkeyidgt"></a>-S[&lt;keyid&gt;] </dt>
<dt class="hdlist1" id="git-rebase---gpg-signltkeyidgt"> <a class="anchor" href="#git-rebase---gpg-signltkeyidgt"></a>--gpg-sign[=&lt;keyid&gt;] </dt>
<dt class="hdlist1" id="git-rebase---no-gpg-sign"> <a class="anchor" href="#git-rebase---no-gpg-sign"></a>--no-gpg-sign </dt>
<dd>
<p>Commits assinados com o GPG O argumento <code>keyid</code> é opcional e a predefinição retorna para a identidade de quem fez o commit; caso seja utilizado, deve estar anexado a opção e sem espaço. A opção <code>--no-gpg-sign</code> é útil para revogar a variável de configuração <code>commit.gpgSign</code> e a anterior <code>--gpg-sign</code>.</p>
</dd>
<dt class="hdlist1" id="git-rebase--q"> <a class="anchor" href="#git-rebase--q"></a>-q </dt>
<dt class="hdlist1" id="git-rebase---quiet"> <a class="anchor" href="#git-rebase---quiet"></a>--quiet </dt>
<dd>
<p>Fique em silêncio. Implica no uso da opção <code>--no-stat</code>.</p>
</dd>
<dt class="hdlist1" id="git-rebase--v"> <a class="anchor" href="#git-rebase--v"></a>-v </dt>
<dt class="hdlist1" id="git-rebase---verbose"> <a class="anchor" href="#git-rebase---verbose"></a>--verbose </dt>
<dd>
<p>Seja loquaz. Implica no uso de <code>--stat</code>.</p>
</dd>
<dt class="hdlist1" id="git-rebase---stat"> <a class="anchor" href="#git-rebase---stat"></a>--stat </dt>
<dd>
<p>Exiba uma descrição do que mudou na upstream desde a última reconstrução (rebase). O diffstat também é controlado pela opção de configuração <code>rebase.stat</code>.</p>
</dd>
<dt class="hdlist1" id="git-rebase--n"> <a class="anchor" href="#git-rebase--n"></a>-n </dt>
<dt class="hdlist1" id="git-rebase---no-stat"> <a class="anchor" href="#git-rebase---no-stat"></a>--no-stat </dt>
<dd>
<p>Não mostre um "diffstat" como parte do processo de reconstrução da fundação (rebase).</p>
</dd>
<dt class="hdlist1" id="git-rebase---no-verify"> <a class="anchor" href="#git-rebase---no-verify"></a>--no-verify </dt>
<dd>
<p>Este comando ignora o gancho "pre-rebase". Consulte também <a href='{{< relurl "docs/githooks/pt_BR" >}}'>githooks[5]</a>.</p>
</dd>
<dt class="hdlist1" id="git-rebase---verify"> <a class="anchor" href="#git-rebase---verify"></a>--verify </dt>
<dd>
<p>É predefinido que seja permitido que o gancho "pre-rebase" seja executado. Esta opção pode ser usada para substituir o comando ` --no-verify`. Consulte também <a href='{{< relurl "docs/githooks/pt_BR" >}}'>githooks[5]</a>.</p>
</dd>
<dt class="hdlist1" id="git-rebase--Cltngt"> <a class="anchor" href="#git-rebase--Cltngt"></a>-C&lt;n&gt; </dt>
<dd>
<p>Assegure que pelo menos <code>&lt;n&gt;</code> linhas ao redor do contexto coincidente antes e após cada alteração. Quando há menos linhas de contexto ao redor, todas elas devem coincidir. É predefinido que nenhum contexto seja ignorado. Implica no uso da opção <code>--apply</code>.</p>
<div class="paragraph">
<p>Consulte também a seção "OPÇÕES INCOMPATÍVEIS" logo abaixo.</p>
</div>
</dd>
<dt class="hdlist1" id="git-rebase---no-ff"> <a class="anchor" href="#git-rebase---no-ff"></a>--no-ff </dt>
<dt class="hdlist1" id="git-rebase---force-rebase"> <a class="anchor" href="#git-rebase---force-rebase"></a>--force-rebase </dt>
<dt class="hdlist1" id="git-rebase--f"> <a class="anchor" href="#git-rebase--f"></a>-f </dt>
<dd>
<p>Reproduza individualmente todos os commits reconstruídos em vez de avançar rapidamente sobre os que estejam inalterados. Isso garante que todo o histórico do ramo reconstruído seja composto por novos commits.</p>
<div class="paragraph">
<p>Pode ser útil após reverter uma mesclagem do ramo "topic", pois esta opção recria o ramo "topic" com os novos commits, para que possa ser recuperado com êxito sem precisar "reverter a reversão" (para mais detalhes, consulte o link: howto/revert-a-fafe-merge.html [Como reverter uma falha da mesclagem]).</p>
</div>
</dd>
<dt class="hdlist1" id="git-rebase---fork-point"> <a class="anchor" href="#git-rebase---fork-point"></a>--fork-point </dt>
<dt class="hdlist1" id="git-rebase---no-fork-point"> <a class="anchor" href="#git-rebase---no-fork-point"></a>--no-fork-point </dt>
<dd>
<p>Utilize reflog para encontrar um ancestral comum melhor entre a <code>&lt;upstream&gt;</code> e o <code>&lt;ramo&gt;</code> ao calcular quais os commits foram introduzidos pelo <code>&lt;ramo&gt;</code>.</p>
<div class="paragraph">
<p>Quando <code>--fork-point</code> está ativo o <em>fork_point</em> será utilizado em vez do <code>&lt;upstream&gt;</code> calcular o conjunto dos commits para fazer o "rebase" onde <em>fork_point</em> é o resultado do comando <code>git merge-base --fork-point &lt;upstream&gt; &lt;ramo&gt;</code> (consulte <a href='{{< relurl "docs/git-merge-base/pt_BR" >}}'>git-merge-base[1]</a>). Caso o <em>fork_point</em> termine vazio, o <code>&lt;upstream&gt;</code> será utilizado como substituto.</p>
</div>
<div class="paragraph">
<p>Caso a <code>&lt;upstream&gt;</code> ou a opção <code>--keep-base</code> seja utilizada na linha de comando, a predefinição será <code>--no-fork-point</code>, caso contrário, a predefinição será <code>--fork-point</code>. Consulte também <code>rebase.forkpoint</code> em <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>.</p>
</div>
<div class="paragraph">
<p>Caso o seu ramo teve como base no <code>&lt;upstream&gt;</code>, porém <code>&lt;upstream&gt;</code> foi retrocedido e o seu ramo contém commits que foram eliminados, esta opção pode ser utilizada com a opção <code>--keep-base</code> para eliminar estes commits do seu ramo.</p>
</div>
<div class="paragraph">
<p>Consulte também a seção "OPÇÕES INCOMPATÍVEIS" logo abaixo.</p>
</div>
</dd>
<dt class="hdlist1" id="git-rebase---ignore-whitespace"> <a class="anchor" href="#git-rebase---ignore-whitespace"></a>--ignore-whitespace </dt>
<dd>
<p>Ignore as diferenças dos espaços ao tentar reconciliar as diferenças. Atualmente, cada estrutura implementa uma aproximação deste comportamento:</p>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-rebase-aplicaobackend"> <a class="anchor" href="#git-rebase-aplicaobackend"></a>aplica o "backend" </dt>
<dd>
<p>Ao aplicar um patch, ignore as alterações no espaço das linhas do contexto. Infelizmente, isto significa que caso as linhas "antigas" sendo substituídas pelo patch difiram apenas pelo espaço do arquivo existente haverá um conflito de integração em vez da aplicação bem sucedida do patch.</p>
</dd>
<dt class="hdlist1" id="git-rebase-mesclaobackend"> <a class="anchor" href="#git-rebase-mesclaobackend"></a>mescla o "backend" </dt>
<dd>
<p>Trate apenas as linhas com alterações no espaço como inalteradas durante a mesclagem. Infelizmente, isto significa que quaisquer pedaços do patch que se destinavam a alterar o espaço, nada mais será descartado, mesmo que o outro lado não tivesse alterações conflitantes.</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1" id="git-rebase---whitespaceltopogt"> <a class="anchor" href="#git-rebase---whitespaceltopogt"></a>--whitespace=&lt;opção&gt; </dt>
<dd>
<p>Esta opção é repassada para o comando <code>git apply</code> que aplica o patch (consulte <a href='{{< relurl "docs/git-apply/pt_BR" >}}'>git-apply[1]</a>). Implica no uso da opção <code>--apply</code>.</p>
<div class="paragraph">
<p>Consulte também a seção "OPÇÕES INCOMPATÍVEIS" logo abaixo.</p>
</div>
</dd>
<dt class="hdlist1" id="git-rebase---committer-date-is-author-date"> <a class="anchor" href="#git-rebase---committer-date-is-author-date"></a>--committer-date-is-author-date </dt>
<dd>
<p>Em vez de usar a hora atual como a data de quem fez o commit, utilize a data do autor que fez o rebase do commit como a data do commit. Esta opção implica no uso de <code>--force-rebase</code>.</p>
</dd>
<dt class="hdlist1" id="git-rebase---ignore-date"> <a class="anchor" href="#git-rebase---ignore-date"></a>--ignore-date </dt>
<dt class="hdlist1" id="git-rebase---reset-author-date"> <a class="anchor" href="#git-rebase---reset-author-date"></a>--reset-author-date </dt>
<dd>
<p>Em vez de usar a data de autor do commit original, use a hora atual como a data de autor que fez o rebase do commit. Esta opção implica no uso da opção &#8216;--force-rebase&#8217;.</p>
<div class="paragraph">
<p>Consulte também a seção "OPÇÕES INCOMPATÍVEIS" logo abaixo.</p>
</div>
</dd>
<dt class="hdlist1" id="git-rebase---signoff"> <a class="anchor" href="#git-rebase---signoff"></a>--signoff </dt>
<dd>
<p>Adicione uma resposta <code>Assinado-por</code> em todos os commits que tiveram a sua fundação reconstruída. Observe que caso a opção <code>--interactive</code> seja utilizada, apenas os commit marcados para serem selecionados, editados ou reformulados terão um caracteres de resposta adicionado.</p>
<div class="paragraph">
<p>Consulte também a seção "OPÇÕES INCOMPATÍVEIS" logo abaixo.</p>
</div>
</dd>
<dt class="hdlist1" id="git-rebase--i"> <a class="anchor" href="#git-rebase--i"></a>-i </dt>
<dt class="hdlist1" id="git-rebase---interactive"> <a class="anchor" href="#git-rebase---interactive"></a>--interactive </dt>
<dd>
<p>Faça uma lista dos commits que estão prestes a serem reconstruídos. Deixe que o usuário edite esta lista antes da reconstrução. Este modo também pode ser utilizado para dividir os commits (consulte <em>DIVIDINDO OS COMMITS</em> abaixo).</p>
<div class="paragraph">
<p>O formato da lista dos commits pode ser alterado definindo a opção de configuração <code>rebase.instructionFormat</code>. Um formato de instrução personalizado terá automaticamente o hash longo do commit anexado ao formato.</p>
</div>
<div class="paragraph">
<p>Consulte também a seção "OPÇÕES INCOMPATÍVEIS" logo abaixo.</p>
</div>
</dd>
<dt class="hdlist1" id="git-rebase--r"> <a class="anchor" href="#git-rebase--r"></a>-r </dt>
<dt class="hdlist1" id="git-rebase---rebase-mergesrebase-cousinsno-rebase-cousins"> <a class="anchor" href="#git-rebase---rebase-mergesrebase-cousinsno-rebase-cousins"></a>--rebase-merges[=(rebase-cousins|no-rebase-cousins)] </dt>
<dt class="hdlist1" id="git-rebase---no-rebase-merges"> <a class="anchor" href="#git-rebase---no-rebase-merges"></a>--no-rebase-merges </dt>
<dd>
<p>Por predefinição, um "rebase" excluirá os commits que foram mesclados da lista de tarefas e colocará os commits num ramo único e linear. Com a opção <code>--rebase-merges</code>, o "rebase" tentará preservar a estrutura de ramificação dentro dos commits que devem sofrer o "rebase", recriando os commits mesclados. Quaisquer conflitos resolvidos da mesclagem ou adendos manuais nestes commits mesclados terão que ser resolvidos/aplicados manualmente. A opção --no-signoff pode ser usada para contra-ordenar ambas as opções de configuração <code>rebase.rebaseMerges</code> e a opção anterior <code>--rebase-merges</code>.</p>
<div class="paragraph">
<p>Há dois modelos ao mesclar "rebases": <code>rebase-cousins</code> e <code>no-rebase-cousins</code>. Se o modo não for definido, a predefinição é <code>no-rebase-cousins</code>. No modo <code>no-rebase-cousins</code>, os commits que não possuam <code>&lt;upstream&gt;</code> como ancestral direto, manterão o seu ponto no ramo original, ou seja, os commits que seriam excluídos pela opção <a href='{{< relurl "docs/git-log/pt_BR" >}}'>git-log[1]</a> <code>--ancestry-path</code>, por predefinição, manterá a sua ancestralidade original. No modo <code>rebase-cousins</code>, tais commits serão reconstruídos no <code>&lt;upstream&gt;</code> (ou <code>&lt;onto&gt;</code>, caso seja definido).</p>
</div>
<div class="paragraph">
<p>Atualmente, só é possível recriar a mesclagem dos commits utilizando a estratégia de mesclagem <code>ort</code>; diferentes estratégias de mesclagem podem ser utilizadas somente através dos comandos explícitos como <code>exec git merge -s &lt;strategy&gt; [...]</code>.</p>
</div>
<div class="paragraph">
<p>Consulte também <em>RECONSTRUINDO AS MESCLAGENS</em> e <em>OPÇÕES INCOMPATÍVEIS</em> abaixo.</p>
</div>
</dd>
<dt class="hdlist1" id="git-rebase--xltcmdgt"> <a class="anchor" href="#git-rebase--xltcmdgt"></a>-x &lt;cmd&gt; </dt>
<dt class="hdlist1" id="git-rebase---execltcmdgt"> <a class="anchor" href="#git-rebase---execltcmdgt"></a>--exec &lt;cmd&gt; </dt>
<dd>
<p>Anexe "exec &lt;cmd&gt;" após cada linha, criando um commit no final do histórico. O <code>&lt;cmd&gt;</code> será interpretado como um ou mais comandos do shell. Qualquer comando que falhar interromperá a reconstrução da fundação, encerrando com o código 1.</p>
<div class="paragraph">
<p>É possível executar vários comandos utilizando uma instância da opção <code>--exec</code> com vários comandos:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>git rebase -i --exec "cmd1 &amp;&amp; cmd2 &amp;&amp; ..."</pre>
</div>
</div>
<div class="paragraph">
<p>ou utilizando mais de um <code>--exec</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>git rebase -i --exec "cmd1" --exec "cmd2" --exec ...</pre>
</div>
</div>
<div class="paragraph">
<p>Caso a opção <code>--autosquash</code> seja utilizado, as linhas <code>exec</code> não serão anexadas aos commits intermediários e aparecerão apenas no final de cada série de compressão/correção.</p>
</div>
<div class="paragraph">
<p>Utiliza o mecanismo <code>--interactive</code> internamente, porém pode ser executado sem a opção <code>--interactive</code> de forma explicita.</p>
</div>
<div class="paragraph">
<p>Consulte também a seção "OPÇÕES INCOMPATÍVEIS" logo abaixo.</p>
</div>
</dd>
<dt class="hdlist1" id="git-rebase---root"> <a class="anchor" href="#git-rebase---root"></a>--root </dt>
<dd>
<p>Reconstrói todos os commits acessíveis a partir do <code>&lt;ramo&gt;</code>, em vez de limitá-los com a <code>&lt;upstream&gt;</code>. Isso permite a reestruturação dos commit da raiz num ramo.</p>
<div class="paragraph">
<p>Consulte também a seção "OPÇÕES INCOMPATÍVEIS" logo abaixo.</p>
</div>
</dd>
<dt class="hdlist1" id="git-rebase---autosquash"> <a class="anchor" href="#git-rebase---autosquash"></a>--autosquash </dt>
<dt class="hdlist1" id="git-rebase---no-autosquash"> <a class="anchor" href="#git-rebase---no-autosquash"></a>--no-autosquash </dt>
<dd>
<p>Quando a mensagem do registro log do commit começar com "squash! &#8230;&#8203;" ou "fixup! &#8230;&#8203;", já existe um commit na lista de tarefas que coincidem com o mesmo <code>...</code>, altera a lista de tarefas automaticamente do <code>rebase -i</code> para que o commit marcado para ser comprimido venha logo após o commit que será modificado e altere a ação do commit movido de <code>pick</code> para <code>squash</code>, <code>fixup</code> ou <code>fixup -C</code> respectivamente. Um commit coincide com <code>...</code> caso haja a coincidência do assunto do commit ou se o <code>...</code> se referir ao hash do commit. Como alternativa, as coincidências que forem parciais ao assunto do commit, também funcionam. A maneira recomendada para se criar os commits para fixup/amend/squash é utilizando as opções <code>--fixup</code>, <code>--fixup=amend:</code> ou <code>--fixup=reword:</code> e <code>--squash</code> respectivamente do comando <a href='{{< relurl "docs/git-commit/pt_BR" >}}'>git-commit[1]</a>.</p>
<div class="paragraph">
<p>Caso a opção <code>--autosquash</code> esteja predefinitivamente ativada utilizando a variável de configuração <code>rebase.autoSquash</code>, esta opção poderá ser utilizada para substituir e desativar esta configuração.</p>
</div>
<div class="paragraph">
<p>Consulte também a seção "OPÇÕES INCOMPATÍVEIS" logo abaixo.</p>
</div>
</dd>
<dt class="hdlist1" id="git-rebase---autostash"> <a class="anchor" href="#git-rebase---autostash"></a>--autostash </dt>
<dt class="hdlist1" id="git-rebase---no-autostash"> <a class="anchor" href="#git-rebase---no-autostash"></a>--no-autostash </dt>
<dd>
<p>Crie automaticamente uma entrada "stash" temporária antes do início da operação e as aplique ao finalizar. Isso significa que é possível executar uma reconstrução (rebase) numa árvore de trabalho suja. No entanto, use com cuidado: a aplicação "stash" final após uma nova reconstrução bem-sucedida pode acabar em conflitos não triviais.</p>
</dd>
<dt class="hdlist1" id="git-rebase---reschedule-failed-exec"> <a class="anchor" href="#git-rebase---reschedule-failed-exec"></a>--reschedule-failed-exec </dt>
<dt class="hdlist1" id="git-rebase---no-reschedule-failed-exec"> <a class="anchor" href="#git-rebase---no-reschedule-failed-exec"></a>--no-reschedule-failed-exec </dt>
<dd>
<p>Reagende automaticamente os comandos <code>exec</code> que falharam. Isso só faz sentido no modo interativo (ou quando uma opção <code>--exec</code> for utilizada).</p>
<div class="paragraph">
<p>Ainda que esta opção se aplique quando uma reconstrução for iniciada, é definido para que toda a reconstrução no início, tenha como base a configuração <code>rebase.rescheduleFailedExec</code> (consulte <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a> ou a "CONFIGURAÇÃO" abaixo) ou se esta opção é oferecida. Caso contrário, uma opção explícita <code>--no-reschedule-failed-exec</code> no início no início seria sobrescrito pela presença da configuração <code>rebase.rescheduleFailedExec=true</code>.</p>
</div>
</dd>
<dt class="hdlist1" id="git-rebase---update-refs"> <a class="anchor" href="#git-rebase---update-refs"></a>--update-refs </dt>
<dt class="hdlist1" id="git-rebase---no-update-refs"> <a class="anchor" href="#git-rebase---no-update-refs"></a>--no-update-refs </dt>
<dd>
<p>Atualize automaticamente todas as ramificações que apontem para os commits onde os "rebases" estejam sendo feitos. Quaisquer ramificações forem verificadas numa árvore de trabalho não são atualizadas desta maneira.</p>
<div class="paragraph">
<p>Caso a variável de configuração <code>rebase.updateRefs</code> esteja definida, então esta opção pode ser usada para substituir e desativar esta configuração.</p>
</div>
<div class="paragraph">
<p>Consulte também a seção "OPÇÕES INCOMPATÍVEIS" logo abaixo.</p>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_opções_incompatíveis"><a class="anchor" href="#_opções_incompatíveis"></a>OPÇÕES INCOMPATÍVEIS</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As seguintes opções:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>--apply</p>
</li>
<li>
<p>--whitespace</p>
</li>
<li>
<p>-C</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>são incompatíveis com as seguintes opções:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>--merge</p>
</li>
<li>
<p>--strategy</p>
</li>
<li>
<p>--strategy-option</p>
</li>
<li>
<p>--autosquash</p>
</li>
<li>
<p>--rebase-merges</p>
</li>
<li>
<p>--interactive</p>
</li>
<li>
<p>--exec</p>
</li>
<li>
<p>--no-keep-empty</p>
</li>
<li>
<p>--empty=</p>
</li>
<li>
<p>--[no-]reapply-cherry-picks quando utilizado com --keep-base</p>
</li>
<li>
<p>--update-refs</p>
</li>
<li>
<p>--root quando utilizado sem o --onto</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Além disso, os seguintes pares de opções são incompatíveis:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>--keep-base e --onto</p>
</li>
<li>
<p>--keep-base e --root</p>
</li>
<li>
<p>--fork-point e --root</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_diferenças_comportamentais"><a class="anchor" href="#_diferenças_comportamentais"></a>DIFERENÇAS COMPORTAMENTAIS</h2>
<div class="sectionbody">
<div class="paragraph">
<p>O <code>git rebase</code> possui duas estruturas primárias: <em>apply</em> e <em>merge</em>. (A estrutura <em>apply</em> era conhecido como <em>am</em>, porém o nome causava confusão já que parecia um verbo em vez de um substantivo. Além disso, a estrutura <em>merge</em> era informada como uma estrutura interativa, porém agora também é usado para casos não interativos. Ambos foram renomeados com base na funcionalidade de baixo nível que sustentava cada um.) Há algumas diferenças sutis em como estes dois processos internos se comportam:</p>
</div>
<div class="sect2">
<h3 id="_os_commits_vazios"><a class="anchor" href="#_os_commits_vazios"></a>Os commits vazios</h3>
<div class="paragraph">
<p>A estrutura <em>apply</em> infelizmente descarta os commits vazios de forma intencional, ou seja, os commits que começaram vazios, contudo na prática é algo raro. Também descarta os commits que se tornam vazios e não há uma opção para controlar este comportamento.</p>
</div>
<div class="paragraph">
<p>É predefinido que a estrutura <em>merge</em> mantenha os commits intencionalmente vazios (com <code>-i</code> são marcados como vazio no editor da lista de tarefas ou podem ser descartados automaticamente com a opção <code>--no-keep-empty</code>).</p>
</div>
<div class="paragraph">
<p>Semelhante à estrutura aplicada, é predefinido que a estrutura da mesclagem derrube os commits que se tornaram vazios a menos que as opções <code>-i</code> ou <code>--interactive</code> sejam utilizadas (nesse caso o comando para e pergunta ao usuário o que fazer). A estrutura da mesclagem também possui uma opção <code>--empty={drop,keep,ask}</code> para alterar o comportamento da manipulação dos commits que se tornaram vazios.</p>
</div>
</div>
<div class="sect2">
<h3 id="_detecção_da_renomeação_do_diretório"><a class="anchor" href="#_detecção_da_renomeação_do_diretório"></a>Detecção da renomeação do diretório</h3>
<div class="paragraph">
<p>Devido à falta de informações precisas sobre as árvores (que surge das construções dos ancestrais falsos com informações limitadas disponíveis nos patches), a detecção da renomeação do diretório é desativado na estrutura <em>apply</em>. A desativação da detecção da renomeação do diretório, significa que se um lado do histórico renomear um diretório e o outro adicionar novos arquivos no diretório antigo, então os novos arquivos serão deixados para trás no diretório antigo sem qualquer aviso durante a reconstrução onde você talvez queira mover estes arquivos para o novo diretório.</p>
</div>
<div class="paragraph">
<p>A detecção da renomeação do diretório funciona com a estrutura <em>merge</em>, neste caso, fornecendo informações para você.</p>
</div>
</div>
<div class="sect2">
<h3 id="_contexto"><a class="anchor" href="#_contexto"></a>Contexto</h3>
<div class="paragraph">
<p>A estrutura <em>apply</em> funciona durante a criação de uma sequencia de patches (chamando o <code>format-patch</code> internalmente), então os patches são aplicados em sequência (invocando o <code>am</code> internamente). Os patches são compostos de vários pedaços, cada um com linhas numeradas, o contexto da região e as alterações atuais. As linhas numeradas devem ser tomadas com alguma imprecisão já que antes o outro lado provavelmente terá inserido ou terá excluído as linhas no arquivo. O contexto da região destina-se no auxílio para encontrar como ajustar as linhas numeradas na ordem para aplicar as alterações nas linhas corretas. No entanto, caso ao redor das várias áreas do código tenham as mesmas linhas de contexto, um código errado pode ser selecionado. Existem casos no mundo real onde isso fez com que os commits fossem reaplicados de forma incorreta e nenhum conflito foi relatado. Definindo o <code>diff.context</code> para um valor maior, isso pode impedir que estes tipos de problemas ocorram, porém aumenta a chance de conflitos espúrios (uma vez que exigirá mais linhas que coincidam com o contexto para serem aplicados).</p>
</div>
<div class="paragraph">
<p>A estrutura <em>merge</em> trabalha com a cópia completa de casa arquivo relevante isolando-os destes tipos de problemas.</p>
</div>
</div>
<div class="sect2">
<h3 id="_a_rotulagem_dos_marcadores_de_conflitos"><a class="anchor" href="#_a_rotulagem_dos_marcadores_de_conflitos"></a>A rotulagem dos marcadores de conflitos</h3>
<div class="paragraph">
<p>Quando há conteúdos conflitantes o mecanismo da mesclagem tenta anotar os marcadores de conflito de cada lado com os commits de onde o conteúdo veio. Como a estrutura <em>apply</em> descarta o original, as informações sobre os commits reconstruídos e seus pais (em vez disso, gera novos commits falsos com base nas informações limitadas no patches que foram gerados), estes commits não podem ser identificados; em vez disso tem que retornar para um resumo do commit. Além disso, quando o <code>merge.conflictStyle</code> é definido para <code>diff3</code> ou <code>zdiff3</code>, a estrutura <em>apply</em> utilizará uma "mesclagem reconstruída da base" para rotular o conteúdo da base mesclada e portanto, não fornece qualquer informações sobre o commit da base mesclada.</p>
</div>
<div class="paragraph">
<p>A estrutura <em>merge</em> funciona com commits completos nos dois lados do histórico e portanto não possuem tais limitações.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ganchos"><a class="anchor" href="#_ganchos"></a>Ganchos</h3>
<div class="paragraph">
<p>A estrutura <em>apply</em> não chama tradicionalmente o gancho pós-commit, enquanto a estrutura <em>merge</em> chama. Ambos chamaram o gancho pós-averiguação, embora a estrutura <em>merge</em> reduza a sua saída. Além disso, ambas as estruturas chamam apenas o gancho pós-averiguação com o ponto de partida para fazer o commit da reconstrução da fundação (rebase), nem o commit intermediário, nem o commit final. Em cada caso, o chamado desses ganchos foi por acidente de implementação em vez de design (os dois processos internos eram originalmente implementados como scripts shell e passaram a chamar outros comandos como o <code>git checkout</code> ou o <code>git commit</code> que seriam chamados de ganchos). Ambos os processos internos devem ter o mesmo comportamento, embora não seja totalmente claro qual (caso existam), está correto. Provavelmente faremos o rebase parar chamando um destes ganchos no futuro.</p>
</div>
</div>
<div class="sect2">
<h3 id="_interruptabilidade"><a class="anchor" href="#_interruptabilidade"></a>Interruptabilidade</h3>
<div class="paragraph">
<p>A estrutura <em>apply</em> possui problemas de segurança relacionada com interrupção de tempo; caso o usuário pressione Ctrl+C no momento errado ao tentar interromper o processo rebase, o processo então pode entrar em uma condição ele não pode ser parado posteriormente com um comando <code>git rebase --abort</code>. A estrutura <em>merge</em> não parece sofrer da mesma deficiência. (Consulte <a href="https://lore.kernel.org/git/20200207132152.GC2868@szeder.dev/" class="bare">https://lore.kernel.org/git/20200207132152.GC2868@szeder.dev/</a> para obter mais detalhes.)</p>
</div>
</div>
<div class="sect2">
<h3 id="_reescrevendo_os_commits"><a class="anchor" href="#_reescrevendo_os_commits"></a>Reescrevendo os Commits</h3>
<div class="paragraph">
<p>Quando ocorre um conflito durante o processo <em>rebase</em>, o processo para e pergunta ao usuário para resolver o problema. Como o usuário pode precisar fazer muitas alterações enquanto resolve os conflitos, depois que os conflitos forem resolvidos e o usuário tenha executado o comando <code>git rebase --continue</code>, o <em>rebase</em> deverá abrir o editor e perguntar ao usuário para atualizar a mensagem do commit. A estrutura <em>merge</em> faz isso, enquanto a estrutura <em>apply</em> aplica cegamente a mensagem do commit original.</p>
</div>
</div>
<div class="sect2">
<h3 id="_diferenças_diversas"><a class="anchor" href="#_diferenças_diversas"></a>Diferenças diversas</h3>
<div class="paragraph">
<p>Existem mais algumas diferenças comportamentais que a maioria das pessoas considerariam fazer de forma inconsequente, porém são mencionadas por questões de integridade:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Reflog: As duas estruturas que utilizarão palavras diferentes durante a descrição das alterações feitas no reflog, embora ambos façam a utilização da palavra "rebase".</p>
</li>
<li>
<p>As mensagens de progresso, informacionais e de erro: As duas estruturas fornecem um progresso ligeiramente diferente das mensagens de informação. Além disso, a estrutura aplicada grava uma mensagens de erro (como "Os seus arquivos serão substituídos&#8230;&#8203;") para o stdout, enquanto a mesclagem da estrutura escrevem eles no stderr.</p>
</li>
<li>
<p>Diretórios de estado: As duas estruturas mantêm a sua condição em diferentes diretórios dentro do <code>.git/</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_estratégias_de_mesclagem"><a class="anchor" href="#_estratégias_de_mesclagem"></a>ESTRATÉGIAS DE MESCLAGEM</h2>
<div class="sectionbody">
<div class="paragraph">
<p>O mecanismo da mesclagem (comandos <code>git merge</code> e <code>git pull</code>) permite que as estruturas das <em>estratégias de mesclagem</em> sejam escolhidas com a opção <code>-s</code>. Algumas estratégias também podem ter suas próprias opções, que podem ser passadas usando <code>-X&lt;opção&gt;</code> como argumentos para o comando <code>git merge</code> e/ou <code>git pull</code>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-rebase-ort"> <a class="anchor" href="#git-rebase-ort"></a>ort </dt>
<dd>
<p>Isso é a estratégia predefinida ao obter o mesclar um ramo. Esta estratégia pode resolver apenas duas cabeças usando o algoritmo da mesclagem de 3 vias. Quando há mais de um ancestral comum que pode ser usado para a mesclagem de 3 vias, ele cria uma árvore mesclada dos ancestrais comuns e o usa como a árvore de referência para a mesclagem de 3 vias. Foi informado que isso resulta em menos conflitos durante mesclagem sem causar distorções pelos testes feitos nas mesclagens reais dos commits, retiradas do histórico de desenvolvimento do Linux kernel 2.6. Além disso, essa estratégia pode detectar e manipular as mesclagens envolvendo renomeações, não faz uso das cópias detectadas. O nome para este algoritmo é uma sigla de ("Ostensibly Recursive&#8217;s Twin") ele foi escrito como um substituto para o algoritmo padrão anterior, o <code>recursive</code>.</p>
<div class="paragraph">
<p>A estratégia <em>ort</em> pode adotar as seguintes opções:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-rebase-ours"> <a class="anchor" href="#git-rebase-ours"></a>ours </dt>
<dd>
<p>Esta opção impõem que os pedaços conflitantes que sejam resolvidos de forma automática e de maneira limpa, favorecendo a <em>nossa</em> versão. As alterações vindos de outra árvore que não conflitam com o nosso lado são refletidas no resultado da mesclagem. Para um arquivo binário, todo o conteúdo é retirado do nosso lado.</p>
<div class="paragraph">
<p>Isso não deve ser confundido com a estratégia da <em>nossa</em> de mesclagem, que sequer olha para o que a outra árvore contém. Descarta tudo o que a outra árvore fez, declarando que o <em>nosso</em> histórico contém tudo o que aconteceu nela.</p>
</div>
</dd>
<dt class="hdlist1" id="git-rebase-theirs"> <a class="anchor" href="#git-rebase-theirs"></a>theirs </dt>
<dd>
<p>Este é o oposto do <em>nosso</em>; observe que, diferentemente do <em>nosso</em>, não existe uma estratégia de mesclagem <em>deles</em> para confundir esta opção de mesclagem.</p>
</dd>
<dt class="hdlist1" id="git-rebase-ignore-space-change"> <a class="anchor" href="#git-rebase-ignore-space-change"></a>ignore-space-change </dt>
<dt class="hdlist1" id="git-rebase-ignore-all-space"> <a class="anchor" href="#git-rebase-ignore-all-space"></a>ignore-all-space </dt>
<dt class="hdlist1" id="git-rebase-ignore-space-at-eol"> <a class="anchor" href="#git-rebase-ignore-space-at-eol"></a>ignore-space-at-eol </dt>
<dt class="hdlist1" id="git-rebase-ignore-cr-at-eol"> <a class="anchor" href="#git-rebase-ignore-cr-at-eol"></a>ignore-cr-at-eol </dt>
<dd>
<p>Trata as linhas com o tipo indicado da mudança do espaço como inalterado por uma mesclagem de três vias. As alterações de espaço combinadas com outras alterações em uma linha não são ignoradas. Consulte também <a href='{{< relurl "docs/git-diff/pt_BR" >}}'>git-diff[1]</a> <code>-b</code>, <code>-w</code>, <code>--ignore-space-at-eol</code>, e <code>--ignore-cr-at-eol</code>.</p>
<div class="ulist">
<ul>
<li>
<p>Caso a versão <em>their</em> (dele) introduzir apenas as alterações de espaço em uma linha, a <em>our</em> (nossa) versão será utilizada;</p>
</li>
<li>
<p>Caso a <em>our</em> (nossa) versão introduzir alterações nos espaços, porém a versão <em>their</em> (dele) incluir uma alteração substancial, a versão <em>their</em> (dele) será utilizada;</p>
</li>
<li>
<p>Caso contrário, a mesclagem continuará de forma usual.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1" id="git-rebase-renormalize"> <a class="anchor" href="#git-rebase-renormalize"></a>renormalize </dt>
<dd>
<p>Executa uma averiguação e um check-in virtual de três estágios em um arquivo ao resolver uma mesclagem de três vias. Esta opção deve ser utilizada ao mesclar os ramos com diferentes filtros que estejam limpos ou as regras normais para a quebra de linha. Para obter mais detalhes, consulte "Mesclando ramificações com diferentes atributos de check-in/check-out" em <a href='{{< relurl "docs/gitattributes/pt_BR" >}}'>gitattributes[5]</a>.</p>
</dd>
<dt class="hdlist1" id="git-rebase-no-renormalize"> <a class="anchor" href="#git-rebase-no-renormalize"></a>no-renormalize </dt>
<dd>
<p>Desativa a opção <code>renormalize</code>. Substitui a variável de configuração <code>merge.renormalize</code>.</p>
</dd>
<dt class="hdlist1" id="git-rebase-find-renamesltngt"> <a class="anchor" href="#git-rebase-find-renamesltngt"></a>find-renames[=&lt;n&gt;] </dt>
<dd>
<p>Liga a detecção de renomeação, configurando opcionalmente o limite de similaridade. Esta é a predefinição. Isso substitui a configuração da variável <em>merge.renames</em>. Consulte também <a href='{{< relurl "docs/git-diff/pt_BR" >}}'>git-diff[1]</a> <code>--find-renames</code>.</p>
</dd>
<dt class="hdlist1" id="git-rebase-rename-thresholdltngt"> <a class="anchor" href="#git-rebase-rename-thresholdltngt"></a>rename-threshold=&lt;n&gt; </dt>
<dd>
<p>É um sinônimo obsoleto para <code>find-renames=&lt;n&gt;</code>.</p>
</dd>
<dt class="hdlist1" id="git-rebase-subtreeltcaminhogt"> <a class="anchor" href="#git-rebase-subtreeltcaminhogt"></a>subtree[=&lt;caminho&gt;] </dt>
<dd>
<p>Essa opção é uma forma mais avançada da estratégia da <em>subárvore</em>, onde a estratégia adivinha como as duas árvores devem ser deslocadas para coincidirem uma com a outra durante a mesclagem. Em vez disso, o caminho definido é prefixado (ou removido desde o início) para criar a forma das duas árvores que serão coincididas.</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1" id="git-rebase-recursive"> <a class="anchor" href="#git-rebase-recursive"></a>recursive </dt>
<dd>
<p>Isso pode resolver apenas duas cabeças usando o algoritmo da mesclagem de 3 vias. Quando há mais de um ancestral comum que pode ser usado para a mesclagem de 3 vias, ele cria uma árvore mesclada dos ancestrais comuns e o usa como a árvore de referência para a mesclagem de 3 vias. Foi informado que isso resulta em menos conflitos durante mesclagem sem causar distorções pelos testes feitos nas mesclagens reais dos commits, retiradas do histórico de desenvolvimento do Linux kernel 2.6. Adicionalmente, pode detectar e lidar com mesclagens envolvendo renomeações. Não faz uso das cópias que forem detectadas. Esta foi a estratégia padrão para resolver dois heads do Git v0.99.9k até a v2.33.0.</p>
<div class="paragraph">
<p>A estratégia <em>recursive</em> (recursiva) tem as mesmas opções que <em>ort</em>. Contudo, existem três opções adicionais que <em>ort</em> ignora (não documentada acima) que são potencialmente úteis com a estratégia <em>recursiva</em>:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-rebase-patience"> <a class="anchor" href="#git-rebase-patience"></a>patience </dt>
<dd>
<p>É um sinônimo obsoleto para <code>diff-algorithm=patience</code>.</p>
</dd>
<dt class="hdlist1" id="git-rebase-diff-algorithmpatienceminimalhistogrammyers"> <a class="anchor" href="#git-rebase-diff-algorithmpatienceminimalhistogrammyers"></a>diff-algorithm=[patience|minimal|histogram|myers] </dt>
<dd>
<p>Usa um algoritmo diff diferente durante a mesclagem, pode ajudar a evitar as distorções que ocorrem devido as linhas coincidentes sem importância (como chaves das funções distintas). Consulte também <a href='{{< relurl "docs/git-diff/pt_BR" >}}'>git-diff[1]</a> <code>--diff-algorithm</code>. Observe que o <code>ort</code> utiliza especificamente o <code>diff-algorithm=histogram</code> enquanto <code>recursive</code> é a predefinição para a configuração <code>diff.algorithm</code>.</p>
</dd>
<dt class="hdlist1" id="git-rebase-no-renames"> <a class="anchor" href="#git-rebase-no-renames"></a>no-renames </dt>
<dd>
<p>Desativa a detecção de renomeação. Isso substitui a variável de configuração <code>merge.renames</code>. Consulte também<a href='{{< relurl "docs/git-diff/pt_BR" >}}'>git-diff[1]</a> <code>--no-renames</code>.</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1" id="git-rebase-resolve"> <a class="anchor" href="#git-rebase-resolve"></a>resolve </dt>
<dd>
<p>Isso só pode resultar em dois cabeçalhos (ou seja, a ramificação atual e uma outra ramificada da que você obteve) utilizando um algoritmo de mesclagem de três vias. Ele tenta detectar cuidadosamente as ambiguidades cruzadas da mesclagem. Ele não lida com renomeações.</p>
</dd>
<dt class="hdlist1" id="git-rebase-octopus"> <a class="anchor" href="#git-rebase-octopus"></a>octopus </dt>
<dd>
<p>Isso resolve os casos com mais de dois cabeçalhos, porém se recusa a fazer uma mesclagem complexa que precise de uma resolução manual. Destina-se primeiramente para ser usado para agrupar junto o tópico dos cabeçalhos. Esra é a estratégia de mesclagem predefinida durante a extração ou a mesclagem com mais de um ramo.</p>
</dd>
<dt class="hdlist1" id="git-rebase-ours-1"> <a class="anchor" href="#git-rebase-ours-1"></a>ours </dt>
<dd>
<p>Isso resolve qualquer quantidade dos cabeçalhos, porém a árvore resultante da mesclagem é sempre a do cabeçalho atual do ramo, ignorando efetivamente todas as alterações de todas os outros ramos. Ele deve ser usado para substituir o histórico antigo de desenvolvimento das ramificações laterais. Observe que isso é diferente da opção <code>-Xours</code> da estratégia de mesclagem <em>recursiva</em>.</p>
</dd>
<dt class="hdlist1" id="git-rebase-subtree"> <a class="anchor" href="#git-rebase-subtree"></a>subtree </dt>
<dd>
<p>Esta é uma estratégia <code>ort</code> modificada. Ao mesclar as árvores <em>A</em> e <em>B</em>, caso <em>B</em> corresponda a uma subárvore de <em>A</em>, o <em>B</em> será ajustado primeiro para coincidir à estrutura da árvore <em>A</em>, em vez de ler as árvores no mesmo nível. Esse ajuste também é feito na árvore ancestral comum.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Com as estratégias que usma a mesclagem de 3 vias (incluindo a predefinição, <em>ort</em>), caso uma alteração seja feita em ambas as ramificações, porém depois revertida em uma das ramificações, essa alteração estará presente no resultado mesclado; algumas pessoas acham este comportamento confuso. Isso ocorre porque apenas os cabeçalhos e a base da mesclagem são consideradas ao fazer uma mesclagem, e não os commits individuais. Portanto, o algoritmo da mesclagem considera a alteração revertida como nenhuma alteração e substitui a versão alterada.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_observações"><a class="anchor" href="#_observações"></a>OBSERVAÇÕES</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Você deve compreender as implicações da utilização do comando <code>git rebase</code> num repositório que você compartilha. Consulte também SE RECUPERANDO DA RECONSTRUÇÃO DA FUNDAÇÃO INICIAL (UPSTREM REBASE) abaixo.</p>
</div>
<div class="paragraph">
<p>Quando o "rebase" é executado, ele primeiro executa um gancho <code>pre-rebase</code>, caso exista. Você pode usar este gancho para fazer as verificações de sanidade e rejeitar a nova reconstrução, caso não seja apropriado. Consulte o modelo do script do gancho <code>pre-rebase</code> para ter um exemplo.</p>
</div>
<div class="paragraph">
<p>Após a conclusão, o <code>&lt;ramo&gt;</code> será o ramo atual.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_modo_interativo"><a class="anchor" href="#_modo_interativo"></a>MODO INTERATIVO</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Reconstruir de forma interativa significa ter a chance de editar os commits que são reconstruídos. É possível reordenar os commits e removê-los (eliminando os patches ruins ou indesejados).</p>
</div>
<div class="paragraph">
<p>O modo interativo é destinado para este tipo de fluxo de trabalho:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>tenho uma ideia maravilhosa</p>
</li>
<li>
<p>hackear o código</p>
</li>
<li>
<p>preparar uma série para envio</p>
</li>
<li>
<p>enviar</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>onde o ponto 2. consiste em várias instâncias do</p>
</div>
<div class="paragraph">
<p>a) uso regular</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>termine algo digno de um commit</p>
</li>
<li>
<p>commit</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>b) correção independente</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>perceber que algo não funciona</p>
</li>
<li>
<p>conserte isso</p>
</li>
<li>
<p>faça o commit</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Às vezes, a coisa fixada em b.2. não pode ser alterado para o commit nem tão perfeito que ele corrige, porque este commit está enterrado profundamente numa série de correções. É exatamente para isso que a reconstrução interativa serve: use-o após muitos "a" e "b", reorganizando e editando os commits e comprimindo vários commits num.</p>
</div>
<div class="paragraph">
<p>Inicie-o com o último commit que você quer manter como está:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>git rebase -i &lt;após-este-commit&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Um editor será acionado com todos os commits no seu ramo atual (ignorando a mesclagem dos commits), que vêm após o commit informado. Você pode reordenar os commits nesta lista para o conteúdo do seu coração e pode removê-los. A lista é mais ou menos assim:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>pick deadbee Uma linha deste commit
pick fa1afe1 Uma linha do próximo commit
...</pre>
</div>
</div>
<div class="paragraph">
<p>As descrições on-line são puramente para o seu prazer; o comando <em>git rebase</em> não examinará eles, porém os nomes dos commits ("deadbee" e "fa1afe1" neste exemplo), portanto, não exclua ou edite os nomes.</p>
</div>
<div class="paragraph">
<p>Ao substituir o comando "pick" pelo comando "edit", é possível dizer ao comando <code>git rebase</code> para parar após aplicar este commit, para que seja possível editar os arquivos e/ou a mensagem do commit, alterar o commit e continuar com a reconstrução.</p>
</div>
<div class="paragraph">
<p>Para interromper um "rebase" (exatamente como um comando "edit" faria, mas sem fazer uma escolha seletiva de nenhum commit primeiro), use o comando "break".</p>
</div>
<div class="paragraph">
<p>Caso apenas queira editar a mensagem do commit para um commit, substitua o comando <code>pick</code> pelo comando <code>reword</code>.</p>
</div>
<div class="paragraph">
<p>Para eliminar um commit, substitua o comando "pick" por "drop" ou apenas exclua a linha coincidente.</p>
</div>
<div class="paragraph">
<p>Caso queira juntar dois ou mais commits em um, substitua o comando "pick" para o segundo commit e os commits subsequentes por "squash" ou "fixup". Caso os commits tenham diferentes autores, o commit que foi juntado será atribuído ao autor do primeiro commit. A mensagem sugerida do commit para o commit que foi juntado, é a concatenação da mensagem do primeiro commit com aquelas identificadas pelos comandos "squash", omitindo as mensagens dos commits identificados pelos comandos "fixup", a menos que a opção <code>fixup -c</code> seja utilizado. Nesse caso, a mensagem do commit sugerido é apenas a mensagem do commit <code>fixup -c</code> onde um editor é aberto permitindo que você edite a mensagem. O conteúdo (patch) do commit <code>fixup -c</code> ainda está incorporado ao commit que foi juntado. Caso haja mais de um commit <code>fixup -c</code>, a mensagem do último será usada. Você também pode usar a opção <code>fixup -C</code> para obter o mesmo comportamento que a opção <code>fixup -c</code>, sem a opção de abrir um editor.</p>
</div>
<div class="paragraph">
<p>O comando <code>git rebase</code> será interrompido quando o "pick" for substituído por "edit" ou quando um comando falhar devido aos erros da mesclagem. Quando você terminar de editar e/ou resolver os conflitos, será possível continuar utilizando <code>git rebase --continue</code>.</p>
</div>
<div class="paragraph">
<p>Como por exemplo, caso você queira reordenar os últimos 5 commits de maneira onde o que era <code>HEAD~4</code> se torne o novo <code>HEAD</code>. Para conseguir isso, você chamaria o comando <code>git rebase</code> assim:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git rebase -i HEAD~5</pre>
</div>
</div>
<div class="paragraph">
<p>E mova o primeiro patch para o ramo da lista.</p>
</div>
<div class="paragraph">
<p>Convém recriar a mesclagem dos commits, por exemplo, caso tenha um histórico como este:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>           X
            \
         A---M---B
        /
---o---O---P---Q</pre>
</div>
</div>
<div class="paragraph">
<p>Suponha que queira reconstruir o lado do ramo ao lado começando em "A" para "Q". Verifique se o <code>HEAD</code> atual é "B" e chame</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git rebase -i -r --onto Q O</pre>
</div>
</div>
<div class="paragraph">
<p>Reordenando e editando os commits geralmente cria etapas intermediárias não testadas. Convém verificar se a edição do seu histórico não quebrou nada durante a execução de um teste ou, pelo menos, recompilando em pontos intermediários do histórico utilizando o comando "exec" (atalho "x"). Você pode fazer isso criando uma lista de tarefas como esta:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>pick deadbee Implement feature XXX
fixup f1a5c00 Fix to feature XXX
exec make
pick c0ffeee The oneline of the next commit
edit deadbab The oneline of the commit after
exec cd subdir; make test
...</pre>
</div>
</div>
<div class="paragraph">
<p>A reconstrução interativa será interrompida quando um comando falhar (ou seja, encerra com uma condição diferente de 0) oferecendo uma oportunidade para a correção do problema. Você pode continuar com o comando <code>git rebase --continue</code>.</p>
</div>
<div class="paragraph">
<p>O comando "exec" inicia o comando num shell (aquele definido em <code>$SHELL</code>, ou o shell predefinido caso <code>$SHELL</code> não esteja definido), para que você possa utilizar os recursos do shell (como "cd", "&gt;", ";" &#8230;&#8203;). O comando é executado a partir da raiz da árvore de trabalho.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git rebase -i --exec "make test"</pre>
</div>
</div>
<div class="paragraph">
<p>Este comando permite verificar se os commits intermediários são compiláveis. A lista de tarefas fica assim:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>pick 5928aea one
exec make test
pick 04d0fda two
exec make test
pick ba46169 three
exec make test
pick f4593f9 four
exec make test</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_dividindo_os_commits"><a class="anchor" href="#_dividindo_os_commits"></a>DIVIDINDO OS COMMITS</h2>
<div class="sectionbody">
<div class="paragraph">
<p>No modo interativo, é possível marcar os commits com a ação "editar". No entanto, isso não significa necessariamente que o comando <code>git rebase</code> espere que o resultado dessa edição seja exatamente um commit. Na verdade, é possível desfazer o commit ou adicionar outros. Isso pode ser utilizado para dividir um commit em dois:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Inicie uma reconstrução interativa com <code>git rebase -i &lt;commit&gt;^</code>, onde <code>&lt;commit&gt;</code> é o que você quer dividir. De fato, qualquer intervalo do commit serve, desde que contenha aquele commit.</p>
</li>
<li>
<p>Marque o commit que deseja dividir com a ação "edit".</p>
</li>
<li>
<p>Quando se trata de editar este commit, execute o comando <code>git reset HEAD^</code>. O efeito é que o <code>HEAD</code> é retrocedido por um e o índice segue o conjunto. No entanto, a árvore de trabalho permanece a mesma.</p>
</li>
<li>
<p>Agora adicione as alterações ao índice que você queira ter no primeiro commit. Você pode utilizar o comando <code>git add</code> (possivelmente de forma interativa) ou o comando <code>git gui</code> (ou ambos) para fazer isso.</p>
</li>
<li>
<p>Faça o commit do índice agora atual com qualquer mensagem do commit que seja apropriada.</p>
</li>
<li>
<p>Repita as duas últimas etapas até que a sua árvore de trabalho esteja limpa.</p>
</li>
<li>
<p>Continue a reconstrução com <code>git rebase --continue</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Caso não tenha certeza absoluta que as revisões intermediárias são consistentes (elas compilam, passam no conjunto de testes, etc.), você deve usar o <code>git stash</code> para armazenar o commit das alterações que ainda não foram feitas após cada commit, teste e corrija o commit caso correções sejam necessárias.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_se_recuperando_da_reconstrução_da_fundação_inicial_upstrem_rebase"><a class="anchor" href="#_se_recuperando_da_reconstrução_da_fundação_inicial_upstrem_rebase"></a>SE RECUPERANDO DA RECONSTRUÇÃO DA FUNDAÇÃO INICIAL (UPSTREM REBASE)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Fazer a reconstrução da fundação (ou qualquer outra forma de reescrita) de um ramo onde outras pessoas tem a base de trabalho é uma péssima ideia: qualquer um que baixe dela é forçado a corrigir manualmente o seu histórico. Esta seção explica como fazer a correção do ponto de vista de quem baixou. A solução real, no entanto em primeiro lugar, seria evitar fazer a reconstrução da fundação de quem subiu (upstream).</p>
</div>
<div class="paragraph">
<p>Para ilustrar, suponha que esteja em uma situação onde alguém desenvolva um ramo de um <em>subsystem</em> e esteja trabalhando em um <em>topic</em> que depende desse <em>subsistema</em>. Você pode acabar com um histórico como este:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    o---o---o---o---o---o---o---o  master
	 \
	  o---o---o---o---o  subsystem
			   \
			    *---*---*  topic</pre>
</div>
</div>
<div class="paragraph">
<p>Caso a reconstrução da fundação do <em>subsystem</em> seja realizada contra o <em>master</em>, o seguinte acontece:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    o---o---o---o---o---o---o---o  master
	 \			 \
	  o---o---o---o---o	  o'--o'--o'--o'--o'  subsystem
			   \
			    *---*---*  topic</pre>
</div>
</div>
<div class="paragraph">
<p>Caso agora continue o desenvolvimento normalmente e eventualmente mescle o <em>topic</em> para <em>subsystem</em>, os commits do <em>subsystem</em> permanecerão duplicados para sempre:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    o---o---o---o---o---o---o---o  master
	 \			 \
	  o---o---o---o---o	  o'--o'--o'--o'--o'--M	 subsystem
			   \			     /
			    *---*---*-..........-*--*  topic</pre>
</div>
</div>
<div class="paragraph">
<p>Geralmente, essas duplicatas são desaprovadas porque desordenam a história, dificultando o acompanhamento. Para organizar as coisas, é necessário transplantar os commits no <em>topic</em> para o novo cume do <em>subsystem</em>, ou seja, reconstruir (rebase) o <em>topic</em>. Isso se torna um efeito cascata: qualquer um que baixe do <em>topic</em> é forçado a reconstruir (rebase) também e por aí vai!</p>
</div>
<div class="paragraph">
<p>Existem dois tipos de correções, discutidos nas seguintes subseções:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-rebase-Casofcilasalteraessoliteralmenteasmesmas"> <a class="anchor" href="#git-rebase-Casofcilasalteraessoliteralmenteasmesmas"></a>Caso fácil: as alterações são literalmente as mesmas. </dt>
<dd>
<p>Isso acontece caso a reconstrução do <em>subsystem</em> foi uma reconstrução simples e não houve conflitos.</p>
</dd>
<dt class="hdlist1" id="git-rebase-Casodifcilasalteraesnosoasmesmas"> <a class="anchor" href="#git-rebase-Casodifcilasalteraesnosoasmesmas"></a>Caso difícil: as alterações não são as mesmas. </dt>
<dd>
<p>Isso acontece caso a reconstrução da fundação (rebase) do <em>subsistema</em> tiver conflitos ou utilizar o <code>--interactive</code> para omitir, editar, esmagar ou consertar consertos; ou se a inicial utilizou um dos comandos <code>commit --amend</code>, <code>reset</code> ou um histórico completo da reescrita como <a href="https://github.com/newren/git-filter-repo"><code>filter-repo</code></a>.</p>
</dd>
</dl>
</div>
<div class="sect2">
<h3 id="_o_caso_fácil"><a class="anchor" href="#_o_caso_fácil"></a>O caso fácil</h3>
<div class="paragraph">
<p>Funciona apenas se as alterações (IDs do patch com base no conteúdo do diff) no <em>subsystem</em> que forem literalmente as mesmas antes e depois da reconstrução do <em>subsystem</em>.</p>
</div>
<div class="paragraph">
<p>Nesse caso, a correção é fácil porque o comando <em>git rebase</em> sabe ignorar as alterações que já estão presentes no novo <em>upstream</em> (a menos que <code>--reapply-cherry-picks</code> seja utilizada). Então, se você diz (supondo que você esteja no <em>topic</em>)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    $ git rebase subsystem</pre>
</div>
</div>
<div class="paragraph">
<p>você vai acabar com o histórico fixo</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    o---o---o---o---o---o---o---o  master
				 \
				  o'--o'--o'--o'--o'  subsystem
						   \
						    *---*---*  topic</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_o_caso_difícil"><a class="anchor" href="#_o_caso_difícil"></a>O caso difícil</h3>
<div class="paragraph">
<p>As coisas ficam mais complicadas caso as alterações do "subsistema" não coincidam de forma exata aquelas antes da reconstrução.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Embora uma "recuperação fácil dos casos" às vezes pareça ser bem-sucedida
      mesmo no caso difícil, pode haver consequências não intencionais.  Para
      Por exemplo, um commit que foi removido através do comando <code>git rebase
      --interactive</code> será <strong>ressuscitado</strong>!
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A ideia é dizer manualmente ao comando <code>git rebase</code> "onde o <em>subsistema</em> antigo terminou e o seu <em>tópico</em> começou", ou seja, qual era a base da mesclagem antiga entre eles. Você precisará encontrar uma maneira de nomear o último commit do antigo <em>subsistema</em>, por exemplo:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Com o <em>subsistema</em> reflog: após <code>git fetch</code>, o antigo cume do <em>subsistema</em> fica em <code>subsystem@{1}</code>. As capturas subsequentes aumentarão este número. (Consulte <a href='{{< relurl "docs/git-reflog/pt_BR" >}}'>git-reflog[1]</a>.)</p>
</li>
<li>
<p>Em relação ao cume do <em>topic</em>: sabendo que o seu <em>topic</em> tem três commits, o cume antigo do <em>subsystem</em> deve ser <code>topic~3</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Você pode então transplantar o antigo <code>subsystem..topic</code> para o novo cume dizendo (para o caso do reflog e supondo que você já esteja no <em>topic</em>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    $ git rebase --onto subsystem subsystem@{1}</pre>
</div>
</div>
<div class="paragraph">
<p>O efeito cascata de uma recuperação "difícil" (hard case) é especialmente ruim: <em>todos</em> baixaram do <em>topic</em> e agora terão que executar também uma reconstrução "difícil"!</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_reconstruindo_as_mesclagens"><a class="anchor" href="#_reconstruindo_as_mesclagens"></a>RECONSTRUINDO AS MESCLAGENS</h2>
<div class="sectionbody">
<div class="paragraph">
<p>O comando de reconstrução interativa foi originalmente projetado para lidar com séries de patches individuais. Como tal, faz sentido excluir a mesclagem dos commits da lista de tarefas, pois o desenvolvedor pode ter mesclado o <code>master</code> atual enquanto trabalhava no ramo, apenas para redefinir todos os commits para <code>master</code> eventualmente (ignorando a mesclagem dos commits).</p>
</div>
<div class="paragraph">
<p>No entanto, existem razões legítimas pelas quais um desenvolvedor pode querer recriar as mesclagens dos commits: para manter a estrutura do ramo (ou a "topologia do commit") ao trabalhar em diversos ramos inter-relacionadas.</p>
</div>
<div class="paragraph">
<p>No exemplo a seguir, o desenvolvedor trabalha em um tópico no ramo que refatora a maneira como os botões são definidos, em outro tópico do ramo que utilize esta refatoração para implementar um botão "Relatar um bug". A saída do <code>git log --graph --format=%s -5</code> pode ficar assim:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>*   Mescla o ramo 'report-a-bug'
|\
| * Adiciona o botão de feedback
* | Mescla o ramo 'refactor-button'
|\ \
| |/
| * Utiliza a classe do Botão para todos os botões
| * Extrai o botão genérico do DownloadButton</pre>
</div>
</div>
<div class="paragraph">
<p>O desenvolvedor pode querer redefinir estes commits para um novo <code>master</code> enquanto mantém a topologia da ramificação. Quando se espera que o primeiro tópico do ramo que seja integrado ao` master` muito antes do segundo por exemplo. Para resolver os conflitos da mesclagem com as alterações para a classe <code>DownloadButton</code> que a transformou em <code>master</code> por exemplo.</p>
</div>
<div class="paragraph">
<p>Esta reconstrução pode ser realizada utilizando a opção <code>--rebase-merges</code>. Ele irá gerar uma lista de tarefas, assim:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>rotular para

# Branch: refactor-button
reset onto
pick 123456 Extrai o botão genérico do DownloadButton
pick 654321 Utiliza a classe do Botão para todos os botões
label refactor-button

# Branch: report-a-bug
reset refactor-button # Utiliza a classe do Botão para todos os botões
pick abcdef Adiciona o botão de feedback
label report-a-bug

reset onto
merge -C a1b2c3 refactor-button # Mescla o 'refactor-button'
merge -C 6f5e4d report-a-bug # Mescla o 'report-a-bug'</pre>
</div>
</div>
<div class="paragraph">
<p>Ao contrário de uma reconstrução interativa regular, existem os comandos <code>label</code>, <code>reset</code> e <code>merge</code> além dos comandos <code>pick</code>.</p>
</div>
<div class="paragraph">
<p>O comando <code>label</code> associa um rótulo ao <code>HEAD</code> atual quando este comando for executado. Estes rótulos são criados como refs locais da árvore de trabalho (<code>refs/rewritten/&lt;label&gt;</code>) que serão excluídos quando a reconstrução terminar. Dessa forma, as operações da reconstrução em várias árvores de trabalho vinculadas ao mesmo repositório não interferem entre si. Caso o comando <code>label</code> falhe, este é imediatamente reagendado, com uma mensagem útil sobre como proceder.</p>
</div>
<div class="paragraph">
<p>O comando <code>reset</code> redefine o <code>HEAD</code>, o índice e a árvore de trabalho para a revisão específica. É semelhante a um comando <code>exec git reset --hard &lt;label&gt;</code>, porém se recusa a sobrescrever os arquivos que não sejam monitorados. Se o comando <code>reset</code> falhar, ele será imediatamente reagendado, com uma mensagem útil sobre como editar a lista de tarefas (normalmente acontece quando um comando <code>reset</code> foi inserido manualmente na lista de tarefas e contém um erro de digitação).</p>
</div>
<div class="paragraph">
<p>O comando <code>merge</code> mesclará revisões usadas no que seja <code>HEAD</code> naquele momento. Com <code>-C &lt;original-commit&gt;</code>, a mensagem do commit de um determinada mesclagem será usada. Quando o <code>C</code> é alterado para minúsculo <code>-c</code>, a mensagem será aberta num editor após uma mesclagem bem-sucedida, para que o usuário possa edita-lá.</p>
</div>
<div class="paragraph">
<p>Caso um comando <code>merge</code> falhar por qualquer motivo que não seja um conflito da mesclagem (ou seja, quando a operação da mesclagem sequer iniciou), ele será reagendado imediatamente.</p>
</div>
<div class="paragraph">
<p>É predefinido que o comando <code>merge</code> utiliza a estratégia <code>ort</code> para mesclagens regulares e <code>octopus</code> para fusões "octopus" (polvo). É possível especificar uma estratégia padrão para todas as mesclagens utilizando a opção <code>--strategy</code> ao invocar um "rebase" ou é possível substituir mesclagens específicas na lista interativa dos comandos utilizando um comando <code>exec</code> para invocar explicitamente o comando <code>git merge</code> com a opção <code>--strategy</code>. Note que ao invocar explicitamente o comando <code>git merge</code>, é possível fazer uso do fato que as etiquetas são refs das árvores de trabalho locais (o ref <code>refs/rewritten/onto' corresponderiam à etiqueta `onto</code>, por exemplo) para se referir aos ramos que você deseja mesclar.</p>
</div>
<div class="paragraph">
<p>Observação: o primeiro comando (<code>label onto</code>) rotula a revisão onde os commits são refeitos; O nome <code>onto</code> é apenas uma convenção, como um aceno para a opção <code>--onto</code>.</p>
</div>
<div class="paragraph">
<p>Também é possível introduzir commits para mesclagem completamente novos, adicionando um comando no formato <code>merge &lt;merge-head&gt;</code>. Este formulário gera uma mensagem de commit provisória e sempre abre um editor para permitir que o usuário a edite. Pode ser útil quando por exemplo, um ramo de um tópico acaba resolvendo mais de um problema e quer ser dividido em dois ou mais ramos de tópico. Considere esta lista de tarefas:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>pick 192837 Alterna do GNU Makefiles para o CMake
pick 5a6c7e Documente a alteração para o CMake
pick 918273 Corrija a detecção do OpenSSL no CMake
pick afbecd http: adicione a compatibilidade com o TLS v1.3
pick fdbaec Corrija a detecção da cURL no CMake no Windows</pre>
</div>
</div>
<div class="paragraph">
<p>O único commit nesta lista que não está relacionado ao CMake pode muito bem ter sido motivado ao trabalhar na correção de todos os erros introduzidos durante a mudança para o CMake, porém ele lida com um interesse diferente. Para dividir esse ramo em dois tópicos, a lista de tarefas pode ser editada desta maneira:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>rotular para

escolha afbecd http: adicione a compatibilidade para o TLS v1.3
label tlsv1.3

redefinir para
pick 192837 Alterna do GNU Makefiles para o CMake
pick 918273 Corrija a detecção do OpenSSL no CMake
pick fdbaec Corrija a detecção da cURL no CMake no Windows
pick 5a6c7e Documente a alteração para o CMake
label cmake

reset onto
merge tlsv1.3
merge cmake</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_configuração"><a class="anchor" href="#_configuração"></a>CONFIGURAÇÃO</h2>
<div class="sectionbody">
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>Missing <code>pt_BR/includes/cmd-config-section-all.txt</code></p>
</div>
<div class="paragraph">
<p>See original version for this content.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>Missing <code>pt_BR/config/rebase.txt</code></p>
</div>
<div class="paragraph">
<p>See original version for this content.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>Missing <code>pt_BR/config/sequencer.txt</code></p>
</div>
<div class="paragraph">
<p>See original version for this content.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_git"><a class="anchor" href="#_git"></a>GIT</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Parte do conjunto <a href='{{< relurl "docs/git/pt_BR" >}}'>git[1]</a></p>
</div>
</div>
</div>