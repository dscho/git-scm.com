---
category: manual
section: documentation
subsection: manual
title: Git - git-update-index Documentation
docname: git-update-index
lang: pt_BR
aliases:
- "/docs/git-update-index/pt_BR"
- "/docs/git-update-index/pt_BR.html"

---
<div class="sect1">
<h2 id="_nome"><a class="anchor" href="#_nome"></a>NOME</h2>
<div class="sectionbody">
<div class="paragraph">
<p>git-update-index - Registra o conteúdo do arquivo no índice da árvore de trabalho</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resumo"><a class="anchor" href="#_resumo"></a>RESUMO</h2>
<div class="sectionbody">
<div class="verseblock">
<pre class="content"><em>git update-index</em>
	     [--add] [--remove | --force-remove] [--replace]
	     [--refresh] [-q] [--unmerged] [--ignore-missing]
	     [(--cacheinfo &lt;modo&gt;,&lt;objeto&gt;,&lt;arquivo&gt;)&#8230;&#8203;]
	     [--chmod=(+|-)x]
	     [--[no-]assume-unchanged]
	     [--[no-]skip-worktree]
	     [--[no-]ignore-skip-worktree-entries]
	     [--[no-]fsmonitor-valid]
	     [--ignore-submodules]
	     [--[no-]split-index]
	     [--[no-|test-|force-]untracked-cache]
	     [--[no-]fsmonitor]
	     [--really-refresh] [--unresolve] [--again | -g]
	     [--info-only] [--index-info]
	     [-z] [--stdin] [--index-version &lt;n&gt;]
	     [--verbose]
	     [--] [&lt;arquivo&gt;&#8230;&#8203;]</pre>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_descrição"><a class="anchor" href="#_descrição"></a>DESCRIÇÃO</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Modifica o índice. Cada arquivo mencionado é atualizado no índice e em qualquer estado <em>não mesclado</em> ou que <em>precise ser atualizado</em> será limpo.</p>
</div>
<div class="paragraph">
<p>Consulte também <a href='{{< relurl "docs/git-add/pt_BR" >}}'>git-add[1]</a> para conhecer uma maneira mais amigável ao usuário de executar algumas das operações mais comuns no índice.</p>
</div>
<div class="paragraph">
<p>A maneira como o <em>git update index</em> trata os arquivos mencionados pode ser alterada utilizando as várias opções:</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_opções"><a class="anchor" href="#_opções"></a>OPÇÕES</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-update-index---add"> <a class="anchor" href="#git-update-index---add"></a>--add </dt>
<dd>
<p>Caso um arquivo que foi especificado ainda não esteja no índice, este será adicionado. O comportamento predefinido é ignorar os novos arquivos.</p>
</dd>
<dt class="hdlist1" id="git-update-index---remove"> <a class="anchor" href="#git-update-index---remove"></a>--remove </dt>
<dd>
<p>Caso um arquivo especificado estiver no índice, porém esteja ausente, este será removido. O comportamento predefinido é ignorar o arquivo que foi removido.</p>
</dd>
<dt class="hdlist1" id="git-update-index---refresh"> <a class="anchor" href="#git-update-index---refresh"></a>--refresh </dt>
<dd>
<p>Examina o índice atual e verifica se as mesclagens são necessárias ou atualizações, verificando as informações do stat().</p>
</dd>
<dt class="hdlist1" id="git-update-index--q"> <a class="anchor" href="#git-update-index--q"></a>-q </dt>
<dd>
<p>Silêncio. Caso a opção <code>--refresh</code> descobra que o índice precisa de uma atualização, o comportamento padrão é gerar um erro. Esta opção faz com que o comando <em>git update-index</em> continue mesmo assim.</p>
</dd>
<dt class="hdlist1" id="git-update-index---ignore-submodules"> <a class="anchor" href="#git-update-index---ignore-submodules"></a>--ignore-submodules </dt>
<dd>
<p>Não tente atualizar os submódulos. Esta opção é respeitada apenas quando encaminhada antes da opção <code>--refresh</code>.</p>
</dd>
<dt class="hdlist1" id="git-update-index---unmerged"> <a class="anchor" href="#git-update-index---unmerged"></a>--unmerged </dt>
<dd>
<p>Caso a opção <code>--refresh</code> descubra alterações não mescladas no índice, o comportamento padrão é gerar um erro. Esta opção faz com que o comando <em>git update-index</em> continue mesmo assim.</p>
</dd>
<dt class="hdlist1" id="git-update-index---ignore-missing"> <a class="anchor" href="#git-update-index---ignore-missing"></a>--ignore-missing </dt>
<dd>
<p>Ignora os arquivos ausentes durante um <code>--refresh</code></p>
</dd>
<dt class="hdlist1" id="git-update-index---cacheinfoltmodogtltobjetogtltcaminhogt"> <a class="anchor" href="#git-update-index---cacheinfoltmodogtltobjetogtltcaminhogt"></a>--cacheinfo &lt;modo&gt;,&lt;objeto&gt;,&lt;caminho&gt; </dt>
<dt class="hdlist1" id="git-update-index---cacheinfoltmodogtltobjetogtltcaminhogt-1"> <a class="anchor" href="#git-update-index---cacheinfoltmodogtltobjetogtltcaminhogt-1"></a>--cacheinfo &lt;modo&gt; &lt;objeto&gt; &lt;caminho&gt; </dt>
<dd>
<p>Insira diretamente as informações definidas no índice. Por questões de compatibilidade com as versões anteriores, também é possível utilizar estes três argumentos como três parâmetros separados, porém os novos usuários são incentivados a utilizar um formulário com um único parâmetro.</p>
</dd>
<dt class="hdlist1" id="git-update-index---index-info"> <a class="anchor" href="#git-update-index---index-info"></a>--index-info </dt>
<dd>
<p>Leia a informação do índice a partir do stdin.</p>
</dd>
<dt class="hdlist1" id="git-update-index---chmod-x"> <a class="anchor" href="#git-update-index---chmod-x"></a>--chmod=(+|-)x </dt>
<dd>
<p>Defina as permissões de execução nos arquivos atualizados.</p>
</dd>
<dt class="hdlist1" id="git-update-index---no-assume-unchanged"> <a class="anchor" href="#git-update-index---no-assume-unchanged"></a>--[no-]assume-unchanged </dt>
<dd>
<p>Quando está opção é definida, os nomes dos objetos registrados para os caminhos não são atualizados. Em vez disso, esta opção define/desativa o bit "assuma como inalterado" nos caminhos. Quando o bit "assuma como inalterado" está ativado, o usuário promete não alterar o arquivo e permite que o Git assuma que o arquivo da árvore de trabalho coincida ao que está registrado no índice. Caso queira alterar o arquivo da árvore de trabalho, informe ao Git desativando o bit. Às vezes, isso é útil quando trabalhar com um grande projeto em um sistema de arquivos que possua uma chamada do sistema lstat(2) muito lenta (por exemplo, cifs).</p>
<div class="paragraph">
<p>O Git falhará (de forma elegante) caso precise modificar este arquivo no índice, quando for mesclar em um commit por exemplo; portanto, caso o arquivo assumido não monitorado seja alterado na upstream, você precisará lidar com a situação de forma manual.</p>
</div>
</dd>
<dt class="hdlist1" id="git-update-index---really-refresh"> <a class="anchor" href="#git-update-index---really-refresh"></a>--really-refresh </dt>
<dd>
<p>Como a opção <code>--refresh</code>, porém verifica as informações das estatísticas incondicionalmente, sem considerar a configuração "assuma como inalterado".</p>
</dd>
<dt class="hdlist1" id="git-update-index---no-skip-worktree"> <a class="anchor" href="#git-update-index---no-skip-worktree"></a>--[no-]skip-worktree </dt>
<dd>
<p>Quando uma destas opções é utilizada, o nome do objeto registrado para os caminhos não é atualizado. Em vez disso, estas opções definem e desabilitam o bit "skip-worktree" (ignore a árvore de trabalho) dos caminhos. Para mais informações, consulte a seção "Skip-worktree bit" abaixo.</p>
</dd>
<dt class="hdlist1" id="git-update-index---no-ignore-skip-worktree-entries"> <a class="anchor" href="#git-update-index---no-ignore-skip-worktree-entries"></a>--[no-]ignore-skip-worktree-entries </dt>
<dd>
<p>Não remova o <em>skip-worktree</em> (também informado como "index-only"), mesmo quando a opção <code>--remove</code> for utilizada.</p>
</dd>
<dt class="hdlist1" id="git-update-index---no-fsmonitor-valid"> <a class="anchor" href="#git-update-index---no-fsmonitor-valid"></a>--[no-]fsmonitor-valid </dt>
<dd>
<p>Quando uma destas opções é utilizada, o nome do objeto registrado para os caminhos não é atualizado. Em vez disso, essas opções definem e desabilitam o bit "fsmonitor valid" (fsmonitor válido) para os caminhos. Para mais informações, consulte a seção "Monitor do Sistema de Arquivos" abaixo.</p>
</dd>
<dt class="hdlist1" id="git-update-index--g"> <a class="anchor" href="#git-update-index--g"></a>-g </dt>
<dt class="hdlist1" id="git-update-index---again"> <a class="anchor" href="#git-update-index---again"></a>--again </dt>
<dd>
<p>Executa o próprio comando <em>git update index</em> nos caminhos cujas entradas do índice sejam diferentes daquelas do commit <code>HEAD</code>.</p>
</dd>
<dt class="hdlist1" id="git-update-index---unresolve"> <a class="anchor" href="#git-update-index---unresolve"></a>--unresolve </dt>
<dd>
<p>Restaura a condição <em>unmerged</em> (não mesclado) ou <em>needs updating</em> (precisa ser atualizado) de um arquivo, durante uma mesclagem caso ele tenha sudo eliminado por engano.</p>
</dd>
<dt class="hdlist1" id="git-update-index---info-only"> <a class="anchor" href="#git-update-index---info-only"></a>--info-only </dt>
<dd>
<p>Não crie os objetos no banco de dados dos objetos para todos os argumentos &lt;arquivo&gt; que seguem esta opção; basta inserir os seus IDs do objeto no índice.</p>
</dd>
<dt class="hdlist1" id="git-update-index---force-remove"> <a class="anchor" href="#git-update-index---force-remove"></a>--force-remove </dt>
<dd>
<p>Remova o arquivo do índice, mesmo quando o diretório ativo ainda tenha tal arquivo. (Implica no uso da opção <code>--remove</code>.)</p>
</dd>
<dt class="hdlist1" id="git-update-index---replace"> <a class="anchor" href="#git-update-index---replace"></a>--replace </dt>
<dd>
<p>É predefinido que quando um arquivo <code>path</code> exista no índice, o comando <em>git update-index</em> recusa uma tentativa de adicionar ao <code>path/file</code>. Da mesma forma, caso exista um arquivo <code>path/file</code>, um arquivo <code>path</code> não poderá ser adicionado. Com a opção <code>--replace</code>, serão removidas automaticamente e com mensagens de aviso todos os lançamentos já existentes que entrem em conflito com o lançamento que está sendo adicionado.</p>
</dd>
<dt class="hdlist1" id="git-update-index---stdin"> <a class="anchor" href="#git-update-index---stdin"></a>--stdin </dt>
<dd>
<p>Em vez de pegar a lista dos caminhos da linha de comando, leia a lista dos caminhos na entrada padrão. É predefinido que os caminhos sejam separados por LF (ou seja, um caminho por linha).</p>
</dd>
<dt class="hdlist1" id="git-update-index---verbose"> <a class="anchor" href="#git-update-index---verbose"></a>--verbose </dt>
<dd>
<p>Relate o que está sendo adicionado e removido do índice.</p>
</dd>
<dt class="hdlist1" id="git-update-index---index-versionltngt"> <a class="anchor" href="#git-update-index---index-versionltngt"></a>--index-version &lt;n&gt; </dt>
<dd>
<p>Escreva o índice resultante na versão informada no formato do disco. As versões compatíveis são 2, 3 e 4. A versão predefinida atualmente é 2 ou 3, dependendo dos recursos extras que serão utilizados, como <code>git add -N</code>.</p>
<div class="paragraph">
<p>A versão 4 executa uma compactação do nome do caminho simples que reduz o tamanho do índice em 30%-50% nos repositórios grandes, o que resulta em um tempo de carregamento mais rápido. A versão 4 é relativamente mais nova (lançada pela primeira vez na versão 1.8.0 em outubro de 2012). As outras implementações do Git, como <em>JGit</em> e <em>libgit2</em>, ainda não são compatíveis.</p>
</div>
</dd>
<dt class="hdlist1" id="git-update-index--z"> <a class="anchor" href="#git-update-index--z"></a>-z </dt>
<dd>
<p>Só faz algum sentido se for utilizado com <code>--stdin</code> or <code>--index-info</code>; os caminhos são separados com caracteres <code>NUL</code> em vez de <code>LF</code>.</p>
</dd>
<dt class="hdlist1" id="git-update-index---split-index"> <a class="anchor" href="#git-update-index---split-index"></a>--split-index </dt>
<dt class="hdlist1" id="git-update-index---no-split-index"> <a class="anchor" href="#git-update-index---no-split-index"></a>--no-split-index </dt>
<dd>
<p>Ativar ou desativar o modo com o índice dividido. Se o modo com índice dividido já estiver ativado e a opção <code>--split-index</code> for utilizada novamente, todas as alterações no <code>$GIT_DIR/index</code> serão retornadas ao arquivo do índice compartilhado.</p>
<div class="paragraph">
<p>Estas opções entram em vigor independente de quer configuração da variável existente no <code>core.splitIndex</code> (consulte <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>). Porém um aviso é emitido quando a alteração vai contra o valor configurado pois o valor configurado apenas entrará em vigor na próxima vez que o índice for lido, removendo o efeito pretendido da opção.</p>
</div>
</dd>
<dt class="hdlist1" id="git-update-index---untracked-cache"> <a class="anchor" href="#git-update-index---untracked-cache"></a>--untracked-cache </dt>
<dt class="hdlist1" id="git-update-index---no-untracked-cache"> <a class="anchor" href="#git-update-index---no-untracked-cache"></a>--no-untracked-cache </dt>
<dd>
<p>Ative ou desative o recurso de cache não rastreado. Antes de ativar utilize <code>--test-untracked-cache</code>.</p>
<div class="paragraph">
<p>Estas opções entram em vigor independente de quer configuração da variável existente no <code>core.untrackedCache</code> (consulte <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>). Porém um aviso é emitido quando a alteração vai contra o valor configurado pois o valor configurado apenas entrará em vigor na próxima vez que o índice for lido, removendo o efeito pretendido da opção.</p>
</div>
</dd>
<dt class="hdlist1" id="git-update-index---test-untracked-cache"> <a class="anchor" href="#git-update-index---test-untracked-cache"></a>--test-untracked-cache </dt>
<dd>
<p>Execute apenas os testes no diretório ativo para garantir que o cache não monitorado possa ser utilizado. Você deve habilitar manualmente o cache não monitorado utilizando a opção <code>--untracked-cache</code> ou <code>--force-untracked-cache</code> ou a variável de configuração <code>core.untrackedCache</code> posteriormente, caso realmente queira utilizá-lo. Caso um teste falhe, o código de encerramento gerado é <em>1</em> e uma mensagem explica o que não está funcionando, conforme necessário, caso contrário, o código de encerramento é <em>0</em> e um <em>OK</em> é impresso.</p>
</dd>
<dt class="hdlist1" id="git-update-index---force-untracked-cache"> <a class="anchor" href="#git-update-index---force-untracked-cache"></a>--force-untracked-cache </dt>
<dd>
<p>O mesmo que <code>--untracked-cache</code>. Fornece compatibilidade retroativa com as versões mais antigas do Git, onde <code>--untracked-cache</code> costumava implicar com a opção <code>--test-untracked-cache</code>, porém esta opção ativaria a extensão incondicionalmente.</p>
</dd>
<dt class="hdlist1" id="git-update-index---fsmonitor"> <a class="anchor" href="#git-update-index---fsmonitor"></a>--fsmonitor </dt>
<dt class="hdlist1" id="git-update-index---no-fsmonitor"> <a class="anchor" href="#git-update-index---no-fsmonitor"></a>--no-fsmonitor </dt>
<dd>
<p>Ativar ou desativar o recurso de monitoramento do sistema de arquivos. Estas opções entram em vigor independente de quer configuração da variável existente no <code>core.fsmonitor</code> (consulte <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>). Porém um aviso é emitido quando a alteração vai contra o valor configurado pois o valor configurado apenas entrará em vigor na próxima vez que o índice for lido, removendo o efeito pretendido da opção.</p>
</dd>
<dt class="hdlist1" id="git-update-index---"> <a class="anchor" href="#git-update-index---"></a>-- </dt>
<dd>
<p>Não interprete mais argumentos como opções.</p>
</dd>
<dt class="hdlist1" id="git-update-index-ltarquivogt"> <a class="anchor" href="#git-update-index-ltarquivogt"></a>&lt;arquivo&gt; </dt>
<dd>
<p>Arquivos para agir. Observe que os arquivos que começam com <em>.</em> são descartados. Isso inclui <code>./arquivo</code> e <code>dir/./arquivo</code>. Caso não queira isso, utilize nomes mais limpos. O mesmo se aplica aos diretórios que terminam com <em>/</em> e aos caminhos com <em>//</em></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_usando_a_opção_refresh"><a class="anchor" href="#_usando_a_opção_refresh"></a>USANDO A OPÇÃO --REFRESH</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A opção <code>--refresh</code> não calcula um novo arquivo sha1 ou atualiza o índice para as alterações do modo/conteúdo. Porém o que é <strong>feito</strong> é "repetir a coincidência" das informações estatísticas de um arquivo ao índice, para que você possa atualizar o índice de um arquivo que não foi alterado, porém onde a entrada da estatísticas esteja desatualizada.</p>
</div>
<div class="paragraph">
<p>Como por exemplo, você gostaria de fazer isso após fazer um comando <code>git read-tree</code>, para vincular os detalhes do índice estatístico aos arquivos adequados.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_usando_as_opções_cacheinfo_ou_info_only"><a class="anchor" href="#_usando_as_opções_cacheinfo_ou_info_only"></a>USANDO AS OPÇÕES --CACHEINFO OU --INFO-ONLY</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A opção <code>--cacheinfo</code> é usada para registrar um arquivo que não está no diretório de trabalho atual. É útil para mesclar a averiguação mínima.</p>
</div>
<div class="paragraph">
<p>Para fingir que você tem um arquivo no caminho com modo e o sha1, use:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git update-index --add --cacheinfo &lt;modo&gt;,&lt;sha1&gt;,&lt;caminho&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>A opção <code>--info-only</code> é usado para registrar os arquivos sem colocá-los no banco de dados do objeto. É útil apenas para os repositórios "condição-apenas".</p>
</div>
<div class="paragraph">
<p>Ambos os <code>--cacheinfo</code> e o <code>--info-only</code> se comportam da mesma maneira: o índice é atualizado, porém o banco de dados dos objetos não. A opção <code>--cacheinfo</code> é útil quando o objeto está no banco de dados, porém o arquivo não está disponível localmente. A opção <code>--info-only</code> é útil quando o arquivo está disponível, porém você não queira atualizar o banco de dados do objeto.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_usando_a_opção_index_info"><a class="anchor" href="#_usando_a_opção_index_info"></a>USANDO A OPÇÃO --INDEX-INFO</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A opção <code>--index-info</code> é um mecanismo mais poderoso que permite alimentar as várias definições da entrada a partir da entrada padrão e projetada especificamente para o uso com scripts. Pode receber as entradas de três formatos:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>mode SP type SP sha1          TAB path</p>
<div class="paragraph">
<p>Este formato serve para colocar a saída <code>git ls-tree</code> no índice.</p>
</div>
</li>
<li>
<p>mode         SP sha1 SP stage TAB path</p>
<div class="paragraph">
<p>Este formato serve para colocar os estágios na ordem superior do arquivo no índice e coincide à saída do <code>git ls-files --stage</code>.</p>
</div>
</li>
<li>
<p>mode         SP sha1          TAB path</p>
<div class="paragraph">
<p>Este formato não é mais gerado por nenhum comando Git, mas é e continuará sendo compatível através do comando <code>update-index --index-info</code>.</p>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>Para colocar um estágio de lançamento com prioridade mais alta ao índice, o caminho primeiro deve ser removido ao utilizar <code>mode=0</code> para o caminho e em seguida alimentando as linhas necessárias da entrada ao terceiro formato.</p>
</div>
<div class="paragraph">
<p>Como por exemplo, começando com este índice:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git ls-files -s
100644 8a1218a1024a212bb3db30becd860315f9f3ac52 0       frotz</pre>
</div>
</div>
<div class="paragraph">
<p>você pode alimentar a seguinte entrada para <code>--index-info</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git update-index --index-info
0 0000000000000000000000000000000000000000	frotz
100644 8a1218a1024a212bb3db30becd860315f9f3ac52 1	frotz
100755 8a1218a1024a212bb3db30becd860315f9f3ac52 2	frotz</pre>
</div>
</div>
<div class="paragraph">
<p>A primeira linha da entrada alimenta 0 como sendo o modo para remover o caminho; o SHA-1 não é importante, desde que esteja bem formatado. Em seguida, a segunda e a terceira linha alimentam as entradas <em>stage 1</em> e o <em>stage 2</em> para este caminho. Após o exposto, acabaríamos assim:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git ls-files -s
100644 8a1218a1024a212bb3db30becd860315f9f3ac52 1	frotz
100755 8a1218a1024a212bb3db30becd860315f9f3ac52 2	frotz</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_utilizando_o_bit_assume_unchanged"><a class="anchor" href="#_utilizando_o_bit_assume_unchanged"></a>UTILIZANDO O BIT &#8220;ASSUME UNCHANGED&#8221;</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Muitas operações no Git dependem do seu sistema de arquivos para ter uma implementação eficiente <code>lstat(2)</code>, de modo que as informações <code>st_mtime</code> para os arquivos da árvore de trabalho possam ser averiguadas com menos custo para ver se o conteúdo do arquivo foi alterado em relação à versão registrada no arquivo do índice. Infelizmente, alguns sistemas de arquivos têm um <code>lstat(2)</code> ineficiente. Caso o seu sistema de arquivos seja um deles, é possível definir o bit "assuma como inalterado" para os caminhos que não foram alterados, fazendo com que o Git não faça essa verificação. Observe que definir este bit em um caminho não significa que o Git verificará o conteúdo do arquivo para ver se ele foi alterado&#8201;&#8212;&#8201;le faz com que o Git omita qualquer verificação e presuma que ele não foi alterado. Quando você faz alterações nos arquivos da árvore de trabalho, é preciso informar ao Git de forma explicita, removendo o bit "assuma como inalterado", antes ou após modificá-los.</p>
</div>
<div class="paragraph">
<p>Para definir o bit "assume unchanged" (assuma como inalterado), utilize a opção <code>--assume-unchanged</code>. Para remover a definição utilize <code>--no-assume-unchanged</code>. Para ver quais os arquivos tem o bit "assume unchanged" definido, utilize <code>git ls-files -v</code> (consulte <a href='{{< relurl "docs/git-ls-files/pt_BR" >}}'>git-ls-files[1]</a>).</p>
</div>
<div class="paragraph">
<p>O comando analisa a variável de configuração <code>core.ignorestat</code>. Quando for <em>true</em>, os caminhos são atualizados com o comando <code>git update-index paths...</code> e os caminhos são atualizados com outros comandos Git que atualizam o índice e a árvore de trabalho (por exemplo, o <em>git apply --index</em>, <em>git checkout-index -u</em> e o <em>git read-tree -u</em>) são marcados automaticamente com o bit "assuma como inalterado". Observe que o bit "assuma como inalterado" <strong>não</strong> está definido caso o comando <code>git update-index --refresh</code> encontre o arquivo da árvore de trabalho que coincida com o índice (utilize o <code>git update-index --really-refresh</code> caso queira marcá-los com o bit "assuma como inalterado").</p>
</div>
<div class="paragraph">
<p>Às vezes, os usuários confundem o bit presumido inalterado com o bit do "skip-worktree". Consulte o parágrafo final na seção "Skip-worktree bit" abaixo para obter uma explicação das diferenças.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_exemplos"><a class="anchor" href="#_exemplos"></a>EXEMPLOS</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Para atualizar e renovar apenas os arquivos já averiguados:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git checkout-index -n -f -a &amp;&amp; git update-index --ignore-missing --refresh</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-update-index-Emumsistemadearquivosineficientecomoaopodaconfiguraocodecoreignorestatcodedefinida"> <a class="anchor" href="#git-update-index-Emumsistemadearquivosineficientecomoaopodaconfiguraocodecoreignorestatcodedefinida"></a>Em um sistema de arquivos ineficiente com o a opção da configuração <code>core.ignorestat</code> definida </dt>
<dd>
<div class="listingblock">
<div class="content">
<pre>$ git update-index --really-refresh              <b class="conum">(1)</b>
$ git update-index --no-assume-unchanged foo.c   <b class="conum">(2)</b>
$ git diff --name-only                           <b class="conum">(3)</b>
$ edit foo.c
$ git diff --name-only                           <b class="conum">(4)</b>
M foo.c
$ git update-index foo.c                         <b class="conum">(5)</b>
$ git diff --name-only                           <b class="conum">(6)</b>
$ edit foo.c
$ git diff --name-only                           <b class="conum">(7)</b>
$ git update-index --no-assume-unchanged foo.c   <b class="conum">(8)</b>
$ git diff --name-only                           <b class="conum">(9)</b>
M foo.c</pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>impõem ao lstat(2) que defina os bits "assuma como inalterado" para os caminhos que coincidam com o índice.</p>
</li>
<li>
<p>marque o caminho que será editado.</p>
</li>
<li>
<p>assim faz o lstat(1) e encontra o índice que coincida com o caminho.</p>
</li>
<li>
<p>assim faz o lstat(2) e encontra o índice que <strong>não</strong> coincida com o caminho.</p>
</li>
<li>
<p>registrando uma nova versão nos conjuntos dos índices do bit "assuma como inalterado".</p>
</li>
<li>
<p>e é assumido como inalterado.</p>
</li>
<li>
<p>mesmo depois que você o edite.</p>
</li>
<li>
<p>você pode contar sobre a alteração após o fato.</p>
</li>
<li>
<p>agora verifica com lstat(2) e descobre o que foi alterado.</p>
</li>
</ol>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_skip_worktree_bit"><a class="anchor" href="#_skip_worktree_bit"></a>SKIP-WORKTREE BIT</h2>
<div class="sectionbody">
<div class="paragraph">
<p>O bit do Skip-worktree pode ser definido numa (longa) frase: Diga ao git para evitar escrever o arquivo no diretório de trabalho quando for razoavelmente possível, e trate o arquivo como inalterado quando ele não estiver presente no diretório de trabalho.</p>
</div>
<div class="paragraph">
<p>Note que nem todos os comandos do git prestarão atenção a este bit, e alguns, só são parcialmente compatíveis.</p>
</div>
<div class="paragraph">
<p>Os sinalizadores do índice de atualização e os recursos da leitura da árvore relacionados ao bit skip-worktree, antecederam a introdução do comando <a href='{{< relurl "docs/git-sparse-checkout/pt_BR" >}}'>git-sparse-checkout[1]</a>, que fornece uma maneira muito mais fácil de configurar e manipular os bits skip-worktree . Caso queira reduzir a sua árvore de trabalho para lidar apenas com um subconjunto dos arquivos no repositório, nós encorajamos fortemente o uso de <a href='{{< relurl "docs/git-sparse-checkout/pt_BR" >}}'>git-sparse-checkout[1]</a> em preferência ao índice de atualização de baixo nível e leitura dos primitivos da árvore.</p>
</div>
<div class="paragraph">
<p>O objetivo principal do bit skip-worktree é ativar verificações esparsas, ou seja, ter os diretórios de trabalho com apenas um subconjunto de caminhos presentes. Quando o bit skip-worktree for definido, os comandos do Git (como <code>switch</code>, <code>pull</code>, <code>merge</code>) evitarão escrever esses arquivos. No entanto, esses comandos às vezes gravam esses arquivos de qualquer maneira em casos importantes, como conflitos durante uma mesclagem ou rebase. Os comandos do Git também evitarão tratar a falta de tais arquivos como uma exclusão intencional; por exemplo, <code>git add -u</code> irá realizar uma exclusão para estes arquivos e o comando <code>git commit -a</code> também não fará um commit deletando-os.</p>
</div>
<div class="paragraph">
<p>Embora este bit pareça ser semelhante ao bit inalterado assumido, o seu objetivo é diferente. O bit assumido não alterado é para ser deixado no arquivo da árvore de trabalho, mas fazer com que o Git omita a verificação das alterações e presumindo que o arquivo não foi alterado (embora se ele puder determinar sem declarar o arquivo que foi alterado, é livre para gravar as alterações). A opção <code>--skip-worktree</code> diz ao Git para ignorar a ausência do arquivo, evite atualizá-lo sempre quando for possível com os comandos que normalmente atualizam grande parte do diretório de trabalho (por exemplo, <code>checkout</code>, <code>switch</code>, <code>pull</code>, etc.), e para não ter a sua ausência registrada nos commits. Observe que com os check-outs esparsos (configurados através da opção <code>git sparse-checkout</code> ou configurando "true" em core.sparseCheckout), caso um arquivo esteja marcado como skip-worktree no índice mas seja encontrado na árvore de trabalho, o Git limpará o bit do skip-worktree na árvore de trabalho neste arquivo.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_índice_dividido"><a class="anchor" href="#_índice_dividido"></a>ÍNDICE DIVIDIDO</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Este modo é projetado para repositórios com índices muito grandes e visa reduzir o tempo necessário para gravar repetidamente tais índices.</p>
</div>
<div class="paragraph">
<p>Nesse modo, o índice é dividido em dois arquivos, <code>$GIT_DIR/index</code> e <code>$GIT_DIR/sharedindex.&lt;SHA-1&gt;</code>. As alterações são acumuladas no <code>$GIT_DIR/index</code>, o índice dividido, enquanto o arquivo do índice compartilhado contém todas os lançamentos no índice e permanece inalterado.</p>
</div>
<div class="paragraph">
<p>Todas as alterações feitas índice que foi dividido são retornadas ao arquivo do índice compartilhado quando a quantidade de entradas no índice atinge um nível especificado através da variável de configuração <code>splitIndex.maxPercentChange</code> (consulte <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>).</p>
</div>
<div class="paragraph">
<p>Sempre que um novo arquivo do índice compartilhado for criado, os arquivos do índice antigos que foram compartilhados são excluídos caso o tempo de alteração seja mais antigo do que o definido pela variável de configuração <code>splitIndex.sharedIndexExpire</code> (consulte <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>).</p>
</div>
<div class="paragraph">
<p>Para evitar a exclusão de um arquivo do índice compartilhado que ainda esteja em uso, o seu horário de modificação é atualizado para o horário atual sempre que um novo índice dividido tiver como base o arquivo do índice compartilhado seja criado ou lido.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_cache_não_monitorado"><a class="anchor" href="#_cache_não_monitorado"></a>CACHE NÃO MONITORADO</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Esse cache destina-se a acelerar os comandos que envolvem a determinação dos arquivos não monitorados, como o <code>git status</code>.</p>
</div>
<div class="paragraph">
<p>Esse recurso funciona gravando o <em>mtime</em> dos diretórios da árvore de trabalho e em seguida, omitindo a leitura dos diretórios e as chamadas da condição nos arquivos dos diretórios cujo <em>mtime</em> não tenha sido alterado. Para que isso funcione, o sistema operacional e o sistema de arquivos subjacentes devem alterar o campo do diretório <code>st_mtime</code> caso os arquivos no diretório forem adicionados, modificados ou excluídos.</p>
</div>
<div class="paragraph">
<p>Você pode testar se o sistema de arquivos é compatível com a opção <code>--test-untracked-cache</code>. A opção <code>--untracked-cache</code> usada para executar este teste de forma implícita nas versões mais antigas do Git, porém este não é mais o caso.</p>
</div>
<div class="paragraph">
<p>Caso queira ativar (ou desativar) este recurso, é mais fácil utilizar a variável de configuração <code>core.untrackedCache</code> (consulte <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>) do que utilizar a opção <code>--untracked-cache</code> para o comando <code>git update-index</code> em cada repositório, especialmente se você quiser fazê-lo em todos os repositórios que você utiliza, pois é possível definir a variável de configuração como <code>true</code> (ou <code>false</code>) no seu <code>$HOME/.gitconfig</code> apenas uma vez e afetar todos os repositórios que você toque.</p>
</div>
<div class="paragraph">
<p>Quando a variável de configuração <code>core.untrackedCache</code> é alterada, o cache não monitorado é adicionado ou removido do índice da próxima vez que um comando lê o índice; enquanto quando <code>--[no-|force-]untracked-cache</code> são utilizados, o cache não monitorado é imediatamente adicionado ou removido do índice.</p>
</div>
<div class="paragraph">
<p>Antes da versão 2.17, o cache não monitorado apresentava um erro, ao substituir um diretório por um link simbólico para outro diretório, fazendo com que ele mostrasse de forma incorreta os arquivos monitorados pelo git como não monitorados. Consulte o "status: adicione um teste com falha mostrando um bug core.untrackedCache" commit com git.git. Uma solução alternativa para isso é (e isso pode funcionar para os outros erros que ainda não foram descobertos no futuro):</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git -c core.untrackedCache=false status</pre>
</div>
</div>
<div class="paragraph">
<p>Também foi demonstrado que este <em>bug</em> afeta os casos sem um link simbólico na reposição de um diretório por um arquivo quando se trata das estruturas internas do cache não monitorado, porém nenhum caso foi relatado onde isso tenha resultado na saída incorreta do comando "git status".</p>
</div>
<div class="paragraph">
<p>Também existem os casos onde os índices existentes escritos pelas versões do git anteriores a versão 2.17 referenciarem os diretórios que não existem mais, potencialmente fazendo com que muitos avisos de "não foi possível abrir o diretório" sejam impressos durante a execução do comando "git status". Estes são os novos avisos para problemas existentes que foram descartados anteriormente sem qualquer aviso prévio.</p>
</div>
<div class="paragraph">
<p>Assim como no bug descrito acima, a solução é executar um "status git" único com <code>core.untrackedCache=false</code> para liberar os dados ruins restantes.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_monitor_do_sistema_de_arquivos"><a class="anchor" href="#_monitor_do_sistema_de_arquivos"></a>MONITOR DO SISTEMA DE ARQUIVOS</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Este recurso visa acelerar as operações do git para os repositórios que possuem grandes diretórios de trabalho.</p>
</div>
<div class="paragraph">
<p>Ele permite que o git trabalhe em conjunto com um monitor do sistema de arquivos (consulte <a href='{{< relurl "docs/git-fsmonitor--&#x2d;&#x2d;daemon/pt_BR" >}}'>git-fsmonitor--&#x2d;&#x2d;daemon[1]</a> e a seção "fsmonitor-watchman" do <a href='{{< relurl "docs/githooks/pt_BR" >}}'>githooks[5]</a>) que pode informá-lo sobre quais os arquivos foram alterados. Isso permite que o git evite ter que fazer um <em>lstat()</em> em todo arquivo para localizar quais os arquivos que foram alterados.</p>
</div>
<div class="paragraph">
<p>Quando usado em conjunto com o cache não monitorado, pode melhorar ainda mais o desempenho, evitando o custo de varrer todo o diretório ativo à procura de novos arquivos.</p>
</div>
<div class="paragraph">
<p>Caso queira ativar (ou desativar) este recurso, é mais fácil utilizar a variável de configuração <code>core.fsmonitor</code> (consulte <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>) do que utilizar a opção <code>--fsmonitor</code> para o comando <code>git update-index</code> em cada repositório, especialmente se você quiser fazê-lo em todos os repositórios que você utiliza, pois é possível definir a variável de configuração no seu <code>$HOME/.gitconfig</code> apenas uma vez e afetar todos os repositórios que você toque.</p>
</div>
<div class="paragraph">
<p>Quando a variável de configuração <code>core.fsmonitor</code> é alterada, o monitor do sistema de arquivos é adicionado ou removido do índice na próxima vez que um comando leia o índice. Quando <code>--[no-]fsmonitor</code> é usado, o monitor do sistema de arquivos é imediatamente adicionado ou removido do índice.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_configuração"><a class="anchor" href="#_configuração"></a>CONFIGURAÇÃO</h2>
<div class="sectionbody">
<div class="paragraph">
<p>O comando honra a variável de configuração <code>core.filemode</code>.  Defina como <em>false</em>
caso o seu repositório esteja em um sistema de arquivos cujos bits
dos executáveis não sejam confiáveis (consulte <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>).
Isso faz com que o comando ignore as diferenças nos modos do arquivo registrados
no índice e no modo do arquivo do sistema de arquivos caso eles divirjam apenas
no bit executável.   Em um sistema de arquivos tão infeliz, talvez seja
necessário usar o comando <em>git update-index --chmod =</em>.</p>
</div>
<div class="paragraph">
<p>De maneira semelhante, caso a variável de configuração <code>core.symlinks</code> esteja definida como <em>false</em> (consulte <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>) os links simbólicos serão verificados como arquivos simples e esse comando não modificará o modo de gravação do arquivo vindo de link simbólico para um arquivo regular.</p>
</div>
<div class="paragraph">
<p>O comando analisa a variável de configuração <code>core.ignorestat</code>. Consulte a seção <em>Usando o bit "assuma como inalterado"</em> acima.</p>
</div>
<div class="paragraph">
<p>O comando também analisa a variável de configuração <code>core.trustctime</code>. Pode ser útil quando o tempo da alteração do "inode" for alterado regularmente por algo fora do Git (os rastreadores do sistema dos arquivos e os sistemas de backup utilizam o "ctime" para marcar os arquivos que forem processados) (consulte <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>).</p>
</div>
<div class="paragraph">
<p>A extensão do cache não rastreado pode ser ativado através da configuração de variável <code>core.untrackedCache</code> (consulte <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_observações"><a class="anchor" href="#_observações"></a>OBSERVAÇÕES</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Os usuários geralmente tentam usar os bits "assuma como inalterado" e ignoram a árvore de trabalho para dizer ao Git para ignorar as alterações nos arquivos monitorados. Isso não funciona conforme o esperado, pois o Git ainda pode verificar os arquivos da árvore de trabalho em relação ao índice durante a execução de determinadas operações. Em geral, o Git não fornece uma maneira de ignorar as alterações nos arquivos monitorados, portanto, as soluções alternativas são recomendadas.</p>
</div>
<div class="paragraph">
<p>Como por exemplo, caso o arquivo que você deseja alterar seja algum tipo de arquivo de configuração, o repositório poderá incluir um arquivo de configuração de amostra que poderá ser copiado no nome que foi ignorado e modificado. O repositório pode até incluir um script para tratar o arquivo de amostra como um modelo, modificando e copiando-o automaticamente.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_veja_também"><a class="anchor" href="#_veja_também"></a>VEJA TAMBÉM</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>, <a href='{{< relurl "docs/git-add/pt_BR" >}}'>git-add[1]</a>, <a href='{{< relurl "docs/git-ls-files/pt_BR" >}}'>git-ls-files[1]</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_git"><a class="anchor" href="#_git"></a>GIT</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Parte do conjunto <a href='{{< relurl "docs/git/pt_BR" >}}'>git[1]</a></p>
</div>
</div>
</div>