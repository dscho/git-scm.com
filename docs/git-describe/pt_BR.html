---
title: Git - git-describe Documentation
docname: git-describe
lang: pt_BR
redirect_from:
- "/docs/git-describe/pt_BR/"

---
<div class="sect1">
<h2 id="_nome"><a class="anchor" href="#_nome"></a>NOME</h2>
<div class="sectionbody">
<div class="paragraph">
<p>git-describe - Atribua a um objeto um nome legível para humanos com base num "ref" disponível</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resumo"><a class="anchor" href="#_resumo"></a>RESUMO</h2>
<div class="sectionbody">
<div class="verseblock">
<pre class="content"><em>git describe</em> [--all] [--tags] [--contains] [--abbrev=&lt;n&gt;] [&lt;commit-ish&gt;&#8230;&#8203;]
<em>git describe</em> [--all] [--tags] [--contains] [--abbrev=&lt;n&gt;] --dirty[=&lt;mark&gt;]
<em>git describe</em> &lt;blob&gt;</pre>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_descrição"><a class="anchor" href="#_descrição"></a>DESCRIÇÃO</h2>
<div class="sectionbody">
<div class="paragraph">
<p>O comando localiza a tag mais recente que seja acessível a partir de um commit. Caso a tag aponte para o commit, somente a tag será exibida. Caso contrário, é adicionado um sufixo ao nome da tag com a quantidade adicionais de commits na parte superior do objeto marcado e o nome abreviado do objeto commit mais recente. O resultado é um nome do objeto que é "legível para humanos" que também pode ser utilizado para identificar o commit para outros comandos do git.</p>
</div>
<div class="paragraph">
<p>É predefinido que o comando <code>git description</code> exiba apenas as tags com anotações (sem --all ou --tags). Para mais informações sobre a criação das anotações das tags, consulte as opções <code>-a</code> e <code>-s</code> em <a href='/docs/git-tag/pt_BR'>git-tag[1]</a>.</p>
</div>
<div class="paragraph">
<p>Caso o objeto especificado se refera a uma bolha, este será descrito como <code>&lt;commit-ish&gt;:&lt;caminho&gt;</code>, de modo que a bolha possa ser encontrada em <code>&lt;caminho&gt;</code> que em si descreve o primeiro commit no qual essa bolha ocorre numa revisão reversa do <code>HEAD</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_opções"><a class="anchor" href="#_opções"></a>OPÇÕES</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-describe-ltcommit-ishgt82308203"> <a class="anchor" href="#git-describe-ltcommit-ishgt82308203"></a>&lt;commit-ish&gt;&#8230;&#8203; </dt>
<dd>
<p>Descrevendo os nomes dos objetos commit. Caso seja omitido, a predefinição retorna para que <code>HEAD</code> seja utilizado.</p>
</dd>
<dt class="hdlist1" id="git-describe---dirtyltmarkgt"> <a class="anchor" href="#git-describe---dirtyltmarkgt"></a>--dirty[=&lt;mark&gt;] </dt>
<dt class="hdlist1" id="git-describe---brokenltmarkgt"> <a class="anchor" href="#git-describe---brokenltmarkgt"></a>--broken[=&lt;mark&gt;] </dt>
<dd>
<p>Descreve a condição da árvore de trabalho. Quando a árvore de trabalho corresponder a um <code>HEAD</code>, a saída é a mesma que <code>git describe HEAD</code>. Caso a árvore de trabalho tenha sido modificada localmente, um "-dirty" será anexado a ela. Caso um repositório tenha sido corrompido e o Git não puder determinar se há uma modificação local, o Git exibirá uma mensagem de erro, a menos que a opção <code>--broken</code> seja utilizada.</p>
</dd>
<dt class="hdlist1" id="git-describe---all"> <a class="anchor" href="#git-describe---all"></a>--all </dt>
<dd>
<p>Em vez de usar apenas as tags anotadas, utilize qualquer "ref" encontrada no espaço de nomes <code>refs/</code>. Essa opção permite fazer com que coincida com qualquer ramificação conhecida, do ramo monitorado remotamente ou de uma tag leve (lightweight).</p>
</dd>
<dt class="hdlist1" id="git-describe---tags"> <a class="anchor" href="#git-describe---tags"></a>--tags </dt>
<dd>
<p>Em vez de usar apenas as anotações das tags, utilize qualquer tag que for encontrada no <code>namespace</code> <code>refs/tags</code>. Essa opção permite fazer a coincidência com uma tag "leve" (não anotada).</p>
</dd>
<dt class="hdlist1" id="git-describe---contains"> <a class="anchor" href="#git-describe---contains"></a>--contains </dt>
<dd>
<p>Em vez de encontrar a tag que anteceda um commit, localize a tag que vem após o commit e a contenha. Implica automaticamente no uso da opção <code>--tags</code>.</p>
</dd>
<dt class="hdlist1" id="git-describe---abbrevltngt"> <a class="anchor" href="#git-describe---abbrevltngt"></a>--abbrev=&lt;n&gt; </dt>
<dd>
<p>Em vez de usar o número padrão de dígitos hexadecimais (que variam de acordo com a quantidade de objetos no repositório com um padrão de 7) do nome abreviado do objeto, utilize <code>&lt;n&gt;</code> dígitos ou quantos dígitos forem necessários para formar um nome do objeto que seja único. Um <code>&lt;n&gt;</code> que seja 0, suprime o formato longo exibindo apenas a tag mais próxima.</p>
</dd>
<dt class="hdlist1" id="git-describe---candidatesltngt"> <a class="anchor" href="#git-describe---candidatesltngt"></a>--candidates=&lt;n&gt; </dt>
<dd>
<p>Em vez de considerar apenas as 10 tags mais recentes como candidatas para descrever o commit de entrada, considere até <code>&lt;n&gt;</code> candidatos. Aumentando <code>&lt;n&gt;</code> para acima de 10 haverá um consumo um pouco maior de tempo, no entanto, poderá produzir um resultado mais preciso. Um <code>&lt;n&gt;</code> que seja 0 fará com que apenas as coincidências exatas sejam exibidas.</p>
</dd>
<dt class="hdlist1" id="git-describe---exact-match"> <a class="anchor" href="#git-describe---exact-match"></a>--exact-match </dt>
<dd>
<p>Apenas os resultados exatos de saída (uma tag faz referência direta ao commit informado). Este é um sinônimo para <code>--candidates=0</code>.</p>
</dd>
<dt class="hdlist1" id="git-describe---debug"> <a class="anchor" href="#git-describe---debug"></a>--debug </dt>
<dd>
<p>Exibe de forma detalhada as informações sobre a estratégia de pesquisa que está sendo empregada para o erro predefinido. predefinida. O nome da tag ainda será impresso para a saída.</p>
</dd>
<dt class="hdlist1" id="git-describe---long"> <a class="anchor" href="#git-describe---long"></a>--long </dt>
<dd>
<p>Sempre imprima o formato longo (a tag, o a quantidade de commits e o nome abreviado do commit), mesmo quando coincidir com uma tag. Isso é útil quando você deseja ver as partes do nome do objeto commit na saída "describe", mesmo quando a confirmação em questão seja uma versão marcada. Em vez de apenas emitir o nome da tag, ele descreverá um commit como <code>v1.2-0-gdeadbee</code> (0º commit desde a tag <code>v1.2</code> que aponta para o objeto <code>deadbee</code>&#8230;&#8203;.).</p>
</dd>
<dt class="hdlist1" id="git-describe---matchltpadrogt"> <a class="anchor" href="#git-describe---matchltpadrogt"></a>--match &lt;padrão&gt; </dt>
<dd>
<p>Considere apenas as tags que coincidam ao padrão <code>glob (7)</code>, excluindo o prefixo "refs/tags/". Se utilizado com <code>--all</code>, também considera as ramificações locais e as referências do monitoramento remoto que coincidam com o padrão, excluindo respectivamente o prefixo "refs/heads/" e "refs/remotes/"; as referências dos outros tipos nunca são consideradas. Caso seja utilizado várias vezes, uma lista de padrões será acumulada e as tags que coincidam com qualquer um dos padrões serão consideradas. Utilize <code>--no-match</code> para limpar e redefinir a lista dos padrões.</p>
</dd>
<dt class="hdlist1" id="git-describe---excludeltpadrogt"> <a class="anchor" href="#git-describe---excludeltpadrogt"></a>--exclude &lt;padrão&gt; </dt>
<dd>
<p>Não considere as tags que coincidam com padrão <code>glob (7)</code>, excluindo o prefixo "refs/tags/". Se utilizado com <code>--all</code>, também não considera as ramificações locais e as referências do rastreamento remoto coincidentes ao padrão, excluindo respectivamente o prefixo "refs/heads/" e "refs/remotes/"; as referências de outros tipos nunca são consideradas. Caso seja utilizado várias vezes, uma lista de padrões será acumulada e as tags que coincidam a qualquer um dos padrões serão excluídas. Quando combinada com <code>--match</code>, uma tag será considerada quando coincidir a pelo menos um padrão <code>--match</code> e não corresponder a nenhum dos padrões <code>--exclude</code>. Utilize <code>--no-exclude</code> para limpar e redefinir a lista dos padrões.</p>
</dd>
<dt class="hdlist1" id="git-describe---always"> <a class="anchor" href="#git-describe---always"></a>--always </dt>
<dd>
<p>Exiba o objeto commit abreviado exclusivamente como "fallback" (retirada).</p>
</dd>
<dt class="hdlist1" id="git-describe---first-parent"> <a class="anchor" href="#git-describe---first-parent"></a>--first-parent </dt>
<dd>
<p>Siga apenas o primeiro commit da origem ao ver um commit de mesclagem. Isso é útil quando você quer que as tags não coincidam nos ramos mesclados do histórico do commit de destino.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_exemplos"><a class="anchor" href="#_exemplos"></a>EXEMPLOS</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Algo como a árvore atual do <code>git.git</code>, recebo:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>[torvalds@g5 git]$ git describe parent
v1.0.4-14-g2414721</pre>
</div>
</div>
<div class="paragraph">
<p>ou seja, o cabeçalho atual do meu ramo "original" tem base na versão <code>v1.0.4</code>, mas como ele tem alguns commits a mais, o description adicionou a quantidade de commits adicionais ("14") e um nome do objeto abreviado para o próprio commit ("2414721") no final.</p>
</div>
<div class="paragraph">
<p>A quantidade de commits adicionais é a quantidade de commits que seriam exibidas com "git log v1.0.4..parent". O sufixo hash é "-g" + uma abreviação inequívoca para o commit como uma dica da origem (que era <code>2414721b194453f058079d897d13c4e377f92dc6</code>). O comprimento da abreviatura é escalonado conforme o repositório cresce, utilizando a quantidade aproximada de objetos no repositório e um pouco de matemática em torno do paradoxo da criação, a predefinição é o mínimo de 7. O prefixo "g" significa "git" e é utilizado para permitir a descrição da versão de um software, dependendo do SCM com o qual o software é gerenciado. Isso é útil em um ambiente onde as pessoas podem usar diferentes SCMs.</p>
</div>
<div class="paragraph">
<p>Ao executar o comando <em>git description</em> no nome de uma tag exibirá apenas o seu nome:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>[torvalds@g5 git]$ git describe v1.0.4
v1.0.4</pre>
</div>
</div>
<div class="paragraph">
<p>Com a opção <code>--all</code>, o comando pode utilizar os <code>heads</code> (cabeçalhos) do ramo como referência, portanto a saída exibe também o caminho de referência:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>[torvalds@g5 git]$ git describe --all --abbrev=4 v1.0.5^2
tags/v1.0.0-21-g975b</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>[torvalds@g5 git]$ git describe --all --abbrev=4 HEAD^
heads/lt/describe-7-g975b</pre>
</div>
</div>
<div class="paragraph">
<p>Com a opção <code>--abbrev</code> definido como 0, o comando pode ser utilizado para encontrar o nome da tag mais próximo sem nenhum sufixo:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>[torvalds@g5 git]$ git describe --abbrev=0 v1.0.5^2
tags/v1.0.0</pre>
</div>
</div>
<div class="paragraph">
<p>Observe que o sufixo que você recebe caso digite estes comandos hoje, pode ser que ele pareça ser mais longo do que foi antes quando Linus executou estes mesmos comandos, pois o seu repositório Git pode ter novos commits cujos nomes do objeto saem com 975b que não existiam naquela época, e o sufixo "-g975b" sozinho pode não ser suficiente para desambiguar estes commits.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_estratégia_de_pesquisa"><a class="anchor" href="#_estratégia_de_pesquisa"></a>ESTRATÉGIA DE PESQUISA</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Para cada <em>commit-ish</em> informado, o comando <em>git description</em> procurará primeiro numa tag que identifique exatamente este commit. As tags anotadas sempre serão preferidas às tags leves, as tags com datas mais recentes sempre serão preferidas às tags com datas mais antigas. Em caso de uma coincidência exata ser encontrada, o seu nome será exibido e a pesquisa será interrompida.</p>
</div>
<div class="paragraph">
<p>Caso uma coincidência exata não seja encontrada, o comando <em>git description</em> retornará ao histórico do commit para encontrar um commit ancestral que tenha sido marcado. A tag do ancestral será gerada juntamente com uma abreviação do SHA-1 do <em>commit-ish</em> da entrada. Caso <code>--first-parent</code> teha sido utilizado, será considerada apenas o primeiro pai de cada commit.</p>
</div>
<div class="paragraph">
<p>No caso várias tags serem localizadas durante o procedimento, será selecionada e gerada a tag que possuir a menor quantidade de "commit-ish" diferentes na entrada. Aqui, a menor quantidade de commits diferentes é definido pela quantidade de commits que seriam exibidos através do comando <code>git log tag..input</code>, o seu resultado será a menor quantidade de commits possíveis.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_bugs"><a class="anchor" href="#_bugs"></a>BUGS</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Os objetos árvore assim como os objetos tag que não apontem para um commit não podem ser descritos. Ao descrever as bolhas, as tags mais leves que apontam para as bolhas são ignoradas, porém a bolha ainda é descrita como &lt;committ-ish&gt;:&lt;caminho&gt; apesar da tag mais leve ser favorável.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_git"><a class="anchor" href="#_git"></a>GIT</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Parte do conjunto <a href='/docs/git/pt_BR'>git[1]</a></p>
</div>
</div>
</div>